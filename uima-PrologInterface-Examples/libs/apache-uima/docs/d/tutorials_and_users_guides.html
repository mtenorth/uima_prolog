<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>UIMA Tutorial and Developers' Guides</title><link rel="stylesheet" href="css/stylesheet-html.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div lang="en" class="book" title="UIMA Tutorial and Developers' Guides" id="d4e1"><div xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div><h1 class="title">UIMA Tutorial and Developers' Guides</h1></div><div><div class="authorgroup">
      <h3 class="corpauthor">Written and maintained by the Apache UIMA Development Community</h3>
    </div></div><div><p class="releaseinfo">Version 2.3.1</p></div><div><p class="copyright">Copyright &copy; 2006, 2010 The Apache Software Foundation</p></div><div><p class="copyright">Copyright &copy; 2004, 2006 International Business Machines Corporation</p></div><div><div class="legalnotice" title="Legal Notice"><a name="d4e8"></a>
      <p> </p>
      <p title="License and Disclaimer">
        <b>License and Disclaimer.&nbsp;</b>

        The ASF licenses this documentation
           to you under the Apache License, Version 2.0 (the
           "License"); you may not use this documentation except in compliance
           with the License.  You may obtain a copy of the License at
         
         </p><div class="blockquote"><blockquote class="blockquote">
           <a class="ulink" href="http://www.apache.org/licenses/LICENSE-2.0" target="_top">http://www.apache.org/licenses/LICENSE-2.0</a>
         </blockquote></div><p title="License and Disclaimer">
         
           Unless required by applicable law or agreed to in writing,
           this documentation and its contents are distributed under the License 
           on an 
           "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
           KIND, either express or implied.  See the License for the
           specific language governing permissions and limitations
           under the License.
         
      </p>
      <p> </p>
      <p> </p>
      <p title="Trademarks">
        <b>Trademarks.&nbsp;</b>
        All terms mentioned in the text that are known to be trademarks or 
        service marks have been appropriately capitalized.  Use of such terms
        in this book should not be regarded as affecting the validity of the
        the trademark or service mark.
        
      </p>
    </div></div><div><p class="pubdate">December, 2010</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#ugr.tug.aae">1. Annotator &amp; AE Developer's Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.aae.getting_started">1.1. Getting Started</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.aae.defining_types">1.1.1. Defining Types</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.generating_jcas_sources">1.1.2. Generating Java Source Files for CAS Types</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.developing_annotator_code">1.1.3. Developing Your Annotator Code</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.creating_xml_descriptor">1.1.4. Creating the XML Descriptor</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.testing_your_annotator">1.1.5. Testing Your Annotator</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.aae.configuration_logging">1.2. Configuration and Logging</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.aae.configuration_parameters">1.2.1. Configuration Parameters</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.logging">1.2.2. Logging</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.aae.building_aggregates">1.3. Building Aggregate Analysis Engines</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.aae.combining_annotators">1.3.1. Combining Annotators</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.aaes_can_contain_cas_consumers">1.3.2. AAEs can also contain CAS Consumers</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.reading_results_previous_annotators">1.3.3. Reading the Results of Previous Annotators</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.aae.other_examples">1.4. Other examples</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.additional_topics">1.5. Additional Topics</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.aae.contract_for_annotator_methods">1.5.1. Annotator Methods</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.reporting_errors_from_annotators">1.5.2. Reporting errors from Annotators</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.throwing_exceptions_from_annotators">1.5.3. Throwing Exceptions from Annotators</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.accessing_external_resource_files">1.5.4. Accessing External Resource Files</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.result_specification_setting">1.5.5. Result Specifications</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.classpath_when_using_jcas">1.5.6. Class path setup when using JCas</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.using_shell_scripts">1.5.7. Using the Shell Scripts</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.aae.common_pitfalls">1.6. Common Pitfalls</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.viewing_UIMA_objects_in_eclipse_debugger">1.7. UIMA Objects in Eclipse Debugger</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.xml_intro_ae_descriptor">1.8. Analysis Engine XML Descriptor</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.aae.header_annotator_class_identification">1.8.1. Header and Annotator Class Identification</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.xml_intro_simple_metadata_attributes">1.8.2. Simple Metadata Attributes</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.xml_intro_type_system_definition">1.8.3. Type System Definition</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.xml_intro_capabilities">1.8.4. Capabilities</a></span></dt><dt><span class="section"><a href="#ugr.tug.aae.xml_intro.configuration_parameters">1.8.5. Configuration Parameters (Optional)</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ugr.tug.cpe">2. CPE Developer's Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.cpe.concepts">2.1. CPE Concepts</a></span></dt><dt><span class="section"><a href="#ugr.tug.cpe.configurator_and_viewer">2.2. CPE Configurator and CAS viewer</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.cpe.cpe_configurator">2.2.1. Using the CPE Configurator</a></span></dt><dt><span class="section"><a href="#ugr.tug.cpe.running_cpe_configurator_from_eclipse">2.2.2. Running the CPE Configurator from Eclipse</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.cpe.running_cpe_from_application">2.3. Running a CPE from Your Own Java Application</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.cpe.using_listeners">2.3.1. Using Listeners</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.cpe.developing_collection_processing_components">2.4. Developing Collection Processing Components</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.cpe.collection_reader.developing">2.4.1. Developing Collection Readers</a></span></dt><dt><span class="section"><a href="#ugr.tug.cpe.cas_initializer.developing">2.4.2. Developing CAS
      Initializers</a></span></dt><dt><span class="section"><a href="#ugr.tug.cpe.cas_consumer.developing">2.4.3. Developing CAS
      Consumers</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.cpe.deploying_a_cpe">2.5. Deploying a CPE</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.cpe.managed_deployment">2.5.1. Deploying Managed CAS Processors</a></span></dt><dt><span class="section"><a href="#ugr.tug.cpe.deploying_nonmanaged_cas_processors">2.5.2. Deploying Non-managed CAS Processors</a></span></dt><dt><span class="section"><a href="#ugr.tug.cpe.integrated_deployment">2.5.3. Deploying Integrated CAS Processors</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.cpe.collection_processing_examples">2.6. Collection Processing Examples</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ugr.tug.application">3. Application Developer's Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.appication.uimaframework_class">3.1. The UIMAFramework Class</a></span></dt><dt><span class="section"><a href="#ugr.tug.application.using_aes">3.2. Using Analysis Engines</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.application.instantiating_an_ae">3.2.1. Instantiating an Analysis Engine</a></span></dt><dt><span class="section"><a href="#ugr.tug.application.analyzing_text_documents">3.2.2. Analyzing Text Documents</a></span></dt><dt><span class="section"><a href="#ugr.tug.applications.analyzing_non_text_artifacts">3.2.3. Analyzing Non-Text Artifacts</a></span></dt><dt><span class="section"><a href="#ugr.tug.applications.accessing_analysis_results">3.2.4. Accessing Analysis Results</a></span></dt><dt><span class="section"><a href="#ugr.tug.applications.multi_threaded">3.2.5. Multi-threaded Applications</a></span></dt><dt><span class="section"><a href="#ugr.tug.application.using_multiple_aes">3.2.6. Multiple AEs &amp; Creating Shared CASes</a></span></dt><dt><span class="section"><a href="#ugr.tug.application.saving_cases_to_file_systems">3.2.7. Saving CASes to file systems</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.application.using_cpes">3.3. Using Collection Processing Engines</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.application.running_a_cpe_from_a_descriptor">3.3.1. Running a CPE from a Descriptor</a></span></dt><dt><span class="section"><a href="#ugr.tug.application.configuring_a_cpe_descriptor_programmatically">3.3.2. Configuring a CPE Descriptor Programmatically</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.application.setting_configuration_parameters">3.4. Setting Configuration Parameters</a></span></dt><dt><span class="section"><a href="#ugr.tug.application.integrating_text_analysis_and_search">3.5. Integrating Text Analysis and Search</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.application.building_an_index">3.5.1. Building an Index</a></span></dt><dt><span class="section"><a href="#ugr.tug.application.search.query_tool">3.5.2. Semantic Search Query Tool</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.application.remote_services">3.6. Working with Remote Services</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.application.how_to_deploy_as_soap">3.6.1. Deploying as SOAP Service</a></span></dt><dt><span class="section"><a href="#ugr.tug.application.how_to_deploy_a_vinci_service">3.6.2. Deploying as a Vinci Service</a></span></dt><dt><span class="section"><a href="#ugr.tug.application.how_to_call_a_uima_service">3.6.3. Calling a UIMA Service</a></span></dt><dt><span class="section"><a href="#ugr.tug.application.restrictions_on_remotely_deployed_services">3.6.4. Restrictions on remotely deployed services</a></span></dt><dt><span class="section"><a href="#ugr.tug.application.vns">3.6.5. The Vinci Naming Services (VNS)</a></span></dt><dt><span class="section"><a href="#ugr.tug.configuring_timeout_settings">3.6.6. Configuring Timeout Settings</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.application.increasing_performance_using_parallelism">3.7. Increasing performance using parallelism</a></span></dt><dt><span class="section"><a href="#ugr.tug.application.jmx">3.8. Monitoring AE Performance using JMX</a></span></dt><dt><span class="section"><a href="#tug.application.pto">3.9. Performance Tuning Options</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ugr.tug.fc">4. Flow Controller Developer's Guide</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.fc.developing_fc_code">4.1. Developing the Flow Controller Code</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.fc.fc_interface_overview">4.1.1. Flow Controller Interface Overview</a></span></dt><dt><span class="section"><a href="#ugr.tug.fc.example_code">4.1.2. Example Code</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.fc.creating_fc_descriptor">4.2. Creating the Flow Controller Descriptor</a></span></dt><dt><span class="section"><a href="#ugr.tug.fc.adding_fc_to_aggregate">4.3. Adding Flow Controller to an Aggregate</a></span></dt><dt><span class="section"><a href="#ugr.tug.fc.adding_fc_to_cpe">4.4. Adding Flow Controller to CPE</a></span></dt><dt><span class="section"><a href="#ugr.tug.fc.using_fc_with_cas_multipliers">4.5. Using Flow Controllers with CAS Multipliers</a></span></dt><dt><span class="section"><a href="#ugr.tug.fc.continuing_when_exceptions_occur">4.6. Continuing the Flow When Exceptions Occur</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ugr.tug.aas">5. Annotations, Artifacts &amp; Sofas</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.aas.terminology">5.1. Terminology</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.aas.artifact">5.1.1. Artifact</a></span></dt><dt><span class="section"><a href="#ugr.tug.aas.sofa">5.1.2. Subject of Analysis &#8212; Sofa</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.aas.sofa_data_formats">5.2. Formats of Sofa Data</a></span></dt><dt><span class="section"><a href="#ugr.tug.aas.setting_accessing_sofa_data">5.3. Setting and Accessing Sofa Data</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.aas.setting_sofa_data">5.3.1. Setting Sofa Data</a></span></dt><dt><span class="section"><a href="#ugr.tug.aas.accessing_sofa_data">5.3.2. Accessing Sofa Data</a></span></dt><dt><span class="section"><a href="#ugr.tug.aas.accessing_sofa_data_using_java_stream">5.3.3. Accessing Sofa Data using a Java Stream</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.aas.sofa_fs">5.4. The Sofa Feature Structure</a></span></dt><dt><span class="section"><a href="#ugr.tug.aas.annotations">5.5. Annotations</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.aas.built_in_annotation_types">5.5.1. Built-in Annotation types</a></span></dt><dt><span class="section"><a href="#ugr.tug.aas.annotations_associated_sofa">5.5.2. Annotations have an associated Sofa</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.aas.annotationbase">5.6. AnnotationBase</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ugr.tug.mvs">6. Multiple CAS Views</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.mvs.cas_views_and_sofas">6.1. CAS Views and Sofas</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.mvs.naming_views_sofas">6.1.1. Naming CAS Views and Sofas</a></span></dt><dt><span class="section"><a href="#ugr.tug.mvs.multi_view_and_single_view">6.1.2. Multi/Single View parts in Applications</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.mvs.multi_view_components">6.2. Multi-View Components</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.mvs.deciding_multi_view">6.2.1. Deciding: Multi-View</a></span></dt><dt><span class="section"><a href="#ugr.tug.mvs.additional_capabilities">6.2.2. Multi-View: additional capabilities</a></span></dt><dt><span class="section"><a href="#ugr.tug.mvs.component_xml_metadata">6.2.3. Component XML metadata</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.mvs.sofa_capabilities_and_apis_for_apps">6.3. Sofa Capabilities &amp; APIs for Apps</a></span></dt><dt><span class="section"><a href="#ugr.tug.mvs.sofa_name_mapping">6.4. Sofa Name Mapping</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.mvs.name_mapping_aggregate">6.4.1. Name Mapping in an Aggregate Descriptor</a></span></dt><dt><span class="section"><a href="#ugr.tug.mvs.name_mapping_cpe">6.4.2. Name Mapping in a CPE
      Descriptor</a></span></dt><dt><span class="section"><a href="#ugr.tug.mvs.specifying_cas_view_for_single_view">6.4.3. CAS View for Single-View Parts</a></span></dt><dt><span class="section"><a href="#ugr.tug.mvs.name_mapping_application">6.4.4. Name Mapping in a UIMA Application</a></span></dt><dt><span class="section"><a href="#ugr.tug.mvs.name_mapping_remote_services">6.4.5. Name Mapping for Remote Services</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.mvs.jcas_extensions_for_multi_views">6.5. JCas extensions for Multiple Views</a></span></dt><dt><span class="section"><a href="#ugr.tug.mvs.sample_application">6.6. Sample Multi-View Application</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.mvs.sample_application.descriptor">6.6.1. Annotator Descriptor</a></span></dt><dt><span class="section"><a href="#ugr.tug.mvs.sample_application.setup">6.6.2. Application Setup</a></span></dt><dt><span class="section"><a href="#ugr.tug.mvs.sample_application.annotator_processing">6.6.3. Annotator Processing</a></span></dt><dt><span class="section"><a href="#ugr.tug.mvs.sample_application.accessing_results">6.6.4. Accessing the results of analysis</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.mvs.views_api_summary">6.7. Views API Summary</a></span></dt><dt><span class="section"><a href="#ugr.tug.mvs.sofa_incompatibilities_v1_v2">6.8. Sofa Incompatibilities: V1 and V2</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ugr.tug.cm">7. CAS Multiplier</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.cm.developing_multiplier_code">7.1. Developing the CAS Multiplier Code</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.cm.cm_interface_overview">7.1.1. CAS Multiplier Interface Overview</a></span></dt><dt><span class="section"><a href="#ugr.tug.cm.how_to_get_empty_cas_instance">7.1.2. Getting an empty CAS Instance</a></span></dt><dt><span class="section"><a href="#ugr.tug.cm.example_code">7.1.3. Example Code</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.cm.creating_cm_descriptor">7.2. CAS Multiplier Descriptor</a></span></dt><dt><span class="section"><a href="#ugr.tug.cm.using_cm_in_aae">7.3. Using CAS Multipliers in Aggregates</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.cm.adding_cm_to_aggregate">7.3.1. Aggregate: Adding the CAS Multiplier</a></span></dt><dt><span class="section"><a href="#ugr.tug.cm.cm_and_fc">7.3.2. CAS Multipliers and Flow Control</a></span></dt><dt><span class="section"><a href="#ugr.tug.cm.aggregate_cms">7.3.3. Aggregate CAS Multipliers</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.cm.using_cm_in_cpe">7.4. CAS Multipliers in CPE's</a></span></dt><dt><span class="section"><a href="#ugr.tug.cm.calling_cm_from_app">7.5. Applications: Calling CAS Multipliers</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.cm.retrieving_output_cases">7.5.1. Output CASes</a></span></dt><dt><span class="section"><a href="#ugr.tug.cm.using_cm_with_other_aes">7.5.2. CAS Multipliers with other AEs</a></span></dt></dl></dd><dt><span class="section"><a href="#ugr.tug.cm.using_cm_to_merge_cases">7.6. Merging with CAS Multipliers</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.cm.overview_of_how_to_merge_cases">7.6.1. CAS Merging Overview</a></span></dt><dt><span class="section"><a href="#ugr.tug.cm.example_cas_merger">7.6.2. Example CAS Merger</a></span></dt><dt><span class="section"><a href="#ugr.tug.cm.using_the_simple_text_merger_in_an_aggregate_ae">7.6.3. SimpleTextMerger in an Aggregate</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ugr.tug.xmi_emf">8. XMI &amp; EMF</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.xmi_emf.overview">8.1. Overview</a></span></dt><dt><span class="section"><a href="#ugr.tug.xmi_emf.converting_ecore_to_from_uima_type_system">8.2. Converting an Ecore Model to or from a UIMA Type System</a></span></dt><dt><span class="section"><a href="#ugr.tug.xmi_emf.using_xmi_cas_serialization">8.3. Using XMI CAS Serialization</a></span></dt><dd><dl><dt><span class="section"><a href="#ugr.tug.xmi_emf.xml_character_issues">8.3.1. Character Encoding Issues with XML Serialization</a></span></dt></dl></dd></dl></dd></dl></div>
  
  

  
  
  <div class="chapter" title="Chapter&nbsp;1.&nbsp;Annotator and Analysis Engine Developer's Guide" id="ugr.tug.aae"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;1.&nbsp;Annotator and Analysis Engine Developer's Guide</h2></div></div></div>
  
  
  
  <p>This chapter describes how to develop UIMA <span class="emphasis"><em>type systems</em></span>,
    <span class="emphasis"><em>Annotators</em></span> and <span class="emphasis"><em>Analysis Engines</em></span> using
    the UIMA SDK. It is helpful to read the UIMA Conceptual Overview chapter for a review on
    these concepts.</p>
  
  <p>An <span class="emphasis"><em>Analysis Engine (AE)</em></span> is a program that analyzes artifacts
    (e.g. documents) and infers information from them.</p>
  
  <p>Analysis Engines are constructed from building blocks called
    <span class="emphasis"><em>Annotators</em></span>. An annotator is a component that contains analysis
    logic. Annotators analyze an artifact (for example, a text document) and create
    additional data (metadata) about that artifact. It is a goal of UIMA that annotators need
    not be concerned with anything other than their analysis logic &#8211; for example the
    details of their deployment or their interaction with other annotators.</p>
  
  <p>An Analysis Engine (AE) may contain a single annotator (this is referred to as a
    <span class="emphasis"><em>Primitive AE)</em></span>, or it may be a composition of others and therefore
    contain multiple annotators (this is referred to as an <span class="emphasis"><em>Aggregate
    AE</em></span>). Primitive and aggregate AEs implement the same interface and can be used
    interchangeably by applications.</p>
  
  <p>Annotators produce their analysis results in the form of typed <span class="emphasis"><em>Feature
    Structures</em></span>, which are simply data structures that have a type and a set of
    (attribute, value) pairs. An <span class="emphasis"><em>annotation</em></span> is a particular type of
    Feature Structure that is attached to a region of the artifact being analyzed (a span of
    text in a document, for example).</p>
  
  <p>For example, an annotator may produce an Annotation over the span of text
    <code class="literal">President Bush</code>, where the type of the Annotation is
    <code class="literal">Person</code> and the attribute <code class="literal">fullName</code> has the
    value <code class="literal">George W. Bush</code>, and its position in the artifact is character
    position 12 through character position 26.</p>
  
  <p>It is also possible for annotators to record information associated with the entire
    document rather than a particular span (these are considered Feature Structures but not
    Annotations).</p>
  
  <p>All feature structures, including annotations, are represented in the UIMA
    <span class="emphasis"><em>Common Analysis Structure(CAS)</em></span>. The CAS is the central data
    structure through which all UIMA components communicate. Included with the UIMA SDK is an
    easy-to-use, native Java interface to the CAS called the <span class="emphasis"><em>JCas</em></span>.
    The JCas represents each feature structure as a Java object; the example feature
    structure from the previous paragraph would be an instance of a Java class Person with
    getFullName() and setFullName() methods. Though the examples in this guide all use the
    JCas, it is also possible to directly access the underlying CAS system; for more
    information see <a href="references.html#ugr.ref.cas" class="olink">Chapter&nbsp;4, <i>CAS Reference</i></a>
    .</p>
  
  <p>The remainder of this chapter will refer to the analysis of text documents and the
    creation of annotations that are attached to spans of text in those documents. Keep in mind
    that the CAS can represent arbitrary types of feature structures, and feature structures
    can refer to other feature structures. For example, you can use the CAS to represent a parse
    tree for a document. Also, the artifact that you are analyzing need not be a text
    document.</p>
  
  <p>This guide is organized as follows:</p>
  
  <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
      <p><span class="bold-italic"><a class="xref" href="#ugr.tug.aae.getting_started" title="1.1.&nbsp;Getting Started">Section&nbsp;1.1, &#8220;Getting Started&#8221;</a></span> is a
        tutorial with step-by-step instructions for how to develop and test a simple UIMA annotator.</p>
    </li><li class="listitem">
      <p><span class="bold-italic"><a class="xref" href="#ugr.tug.aae.configuration_logging" title="1.2.&nbsp;Configuration and Logging">Section&nbsp;1.2, &#8220;Configuration and Logging&#8221;</a>
        </span> discusses how to make your UIMA annotator configurable, and how it can write messages to the UIMA
        log file.</p>
    </li><li class="listitem">
      <p> <span class="bold-italic"><a class="xref" href="#ugr.tug.aae.building_aggregates" title="1.3.&nbsp;Building Aggregate Analysis Engines">Section&nbsp;1.3, &#8220;Building Aggregate Analysis Engines&#8221;</a></span>
        describes how annotators can be combined into aggregate analysis engines. It also describes how one
        annotator can make use of the analysis results produced by an annotator that has run previously.</p>
    </li><li class="listitem">
      <p><span class="bold-italic"><a class="xref" href="#ugr.tug.aae.other_examples" title="1.4.&nbsp;Other examples">Section&nbsp;1.4, &#8220;Other examples&#8221;</a></span>
        describes several other examples you may find interesting, including</p>
      
      <div class="itemizedlist"><ul class="itemizedlist" type="circle" compact><li class="listitem">
          <p>SimpleTokenAndSentenceAnnotator
            &#8211; a simple tokenizer and sentence annotator.</p>
        </li><li class="listitem">
          <p>PersonTitleDBWriterCasConsumer &#8211; a sample CAS Consumer which populates a relational
            database with some annotations. It uses JDBC and in this example, hooks up with the Open Source Apache
            Derby database. </p>
        </li></ul></div>
    </li><li class="listitem">
      <p><span class="bold-italic"><a class="xref" href="#ugr.tug.aae.additional_topics" title="1.5.&nbsp;Additional Topics">Section&nbsp;1.5, &#8220;Additional Topics&#8221;</a></span>
        describes additional features of the UIMA SDK that may help you in building your own annotators and analysis
        engines.</p>
    </li><li class="listitem">
      <p><span class="bold-italic"><a class="xref" href="#ugr.tug.aae.common_pitfalls" title="1.6.&nbsp;Common Pitfalls">Section&nbsp;1.6, &#8220;Common Pitfalls&#8221;</a> </span>
        contains some useful guidelines to help you ensure that your annotators will work correctly in any UIMA
        application.</p>
    </li></ul></div>
  
  <p>This guide does not discuss how to build UIMA Applications, which are programs that
    use Analysis Engines, along with other components, e.g. a search engine, document store,
    and user interface, to deliver a complete package of functionality to an end-user. For
    information on application development, see <a href="tutorials_and_users_guides.html#ugr.tug.application" class="olink">Chapter&nbsp;3: &#8220;<ttl>Application Developer's Guide</ttl>&#8221;</a>
    .</p>
  
  <div class="section" title="1.1.&nbsp;Getting Started"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.aae.getting_started">1.1.&nbsp;Getting Started</h2></div></div></div>
    
    
    <p>This section is a step-by-step tutorial that will get you started developing UIMA
      annotators. All of the files referred to by the examples in this chapter are in the
      <code class="literal">examples</code> directory of the UIMA SDK. This directory is designed to
      be imported into your Eclipse workspace; see <a href="overview_and_setup.html#ugr.ovv.eclipse_setup.example_code" class="olink">Section&nbsp;3.2, &#8220;Setting up Eclipse to view Example Code&#8221;</a> for instructions on how to do
      this. 
      See <a href="overview_and_setup.html#ugr.ovv.eclipse_setup.linking_uima_javadocs" class="olink">Section&nbsp;3.4, &#8220;Attaching UIMA Javadocs&#8221;</a> for how to attach the UIMA 
        Javadocs to the jar files.
      Also you may wish to refer to the UIMA SDK Javadocs located in the <a class="ulink" href="file:../../api/index.html" target="_top">docs/api</a> directory.</p>
    
        <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In Eclipse 3.1, if you highlight a UIMA class or method defined in the UIMA SDK
    Javadocs, you can conveniently have Eclipse open the corresponding Javadoc for that
    class or method in a browser, by pressing Shift + F2.</p></div>
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>If you downloaded the source distribution for UIMA, you can attach that as
    well to the library Jar files; for information on how to do this, see
    <a href="references.html#ugr.ref.javadocs" class="olink">Chapter&nbsp;1, <i>Javadocs</i></a>.</p></div>

    <p>The example annotator that we are going to walk through will detect room numbers for
      rooms where the room numbering scheme follows some simple conventions. In our example,
      there are two kinds of patterns we want to find; here are some examples, together with
      their corresponding regular expression patterns:
      </p><div class="variablelist"><dl><dt><span class="term">Yorktown patterns:</span></dt><dd><p>20-001, 31-206, 04-123(Regular Expression Pattern:
            ##-[0-2]##)</p></dd><dt><span class="term">Hawthorne patterns:</span></dt><dd><p>GN-K35, 1S-L07, 4N-B21 (Regular Expression Pattern:
            [G1-4][NS]-[A-Z]##)</p></dd></dl></div><p> </p>
    
    <p>There are several steps to develop and test a simple UIMA annotator.</p>
    
    <div class="orderedlist"><ol class="orderedlist" type="1" compact><li class="listitem"><p>Define the CAS types that the
      annotator will use.</p></li><li class="listitem"><p>Generate the Java classes for these types.</p></li><li class="listitem"><p>Write the actual annotator Java code.</p></li><li class="listitem"><p>Create the Analysis Engine descriptor.</p></li><li class="listitem"><p>Test the annotator. </p></li></ol></div>
    
    <p>These steps are discussed in the next sections.</p>
    
    <div class="section" title="1.1.1.&nbsp;Defining Types"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.defining_types">1.1.1.&nbsp;Defining Types</h3></div></div></div>
      
      
      <p>The first step in developing an annotator is to define the CAS Feature Structure
        types that it creates. This is done in an XML file called a <span class="emphasis"><em>Type System
        Descriptor</em></span>. UIMA defines basic primitive types such as
        Boolean, Byte, Short, Integer, Long, Float, and Double, as well as Arrays of these primitive
        types.  UIMA also defines the built-in types <code class="literal">TOP</code>, which is the root 
        of the type system, analogous to Object in Java; <code class="literal">FSArray</code>, which is 
        an array of Feature Structures (i.e. an array of instances of TOP); and
        <code class="literal">Annotation</code>, which we will discuss in more detail in this section.</p>
      
      <p>UIMA includes an Eclipse plug-in that will help you edit Type System
        Descriptors, so if you are using Eclipse you will not need to worry about the details of
        the XML syntax. See <a href="overview_and_setup.html#ugr.ovv.eclipse_setup" class="olink">Chapter&nbsp;3, <i>Setting up the Eclipse IDE to work with UIMA</i></a> for instructions on setting up Eclipse and
        installing the plugin.</p>
      
      <p>The Type System Descriptor for our annotator is located in the file
        <code class="literal">descriptors/tutorial/ex1/TutorialTypeSystem.xml.</code> (This
        and all other examples are located in the <code class="literal">examples</code> directory of
        the installation of the UIMA SDK, which can be imported into an Eclipse project for
        your convenience, as described in <a href="overview_and_setup.html#ugr.ovv.eclipse_setup.example_code" class="olink">Section&nbsp;3.2, &#8220;Setting up Eclipse to view Example Code&#8221;</a>.)</p>
      
      <p>In Eclipse, expand the <code class="literal">uimaj-examples</code> project in the
        Package Explorer view, and browse to the file
        <code class="literal">descriptors/tutorial/ex1/TutorialTypeSystem.xml</code>.
        Right-click on the file in the navigator and select Open With <span class="symbol">&#8594;</span> Component
        Descriptor Editor. Once the editor opens, click on the <span class="quote">&#8220;<span class="quote">Type System</span>&#8221;</span>
        tab at the bottom of the editor window. You should see a view such as the
        following:</p>
      
      
      <div class="screenshot">
 <div class="mediaobject"><img src="images/tutorials_and_users_guides/tug.aae/image002.jpg" alt="Screenshot of editor for Type System Definitions"></div>
  </div>
      
      <p>Our annotator will need only one type &#8211;
        <code class="literal">org.apache.uima.tutorial.RoomNumber</code>. (We use the same
        namespace conventions as are used for Java classes.) Just as in Java, types have
        supertypes. The supertype is listed in the second column of the left table. In this
        case our RoomNumber annotation extends from the built-in type
        <code class="literal">uima.tcas.Annotation</code>.</p>
      
      <p>Descriptions can be included with types and features. In this example, there is a
        description associated with the <code class="literal">building</code> feature. To see it,
        hover the mouse over the feature.</p>
      
      <p>The bottom tab labeled <span class="quote">&#8220;<span class="quote">Source</span>&#8221;</span> will show you the XML source file
        associated with this descriptor.</p>
      
      <p>The built-in Annotation type declares three fields (called
        <span class="emphasis"><em>Features</em></span> in CAS terminology).  The features <code class="literal">begin</code>
        and <code class="literal">end</code> store the character offsets of the span of text to which the 
        annotation refers.  The feature <code class="literal">sofa</code> (Subject of Analysis) indicates
        which document the begin and end offsets point into.  The <code class="literal">sofa</code> feature
        can be ignored for now since we assume in this tutorial that the CAS contains only one
        subject of analysis (document).</p>
      <p>Our RoomNumber type will inherit these three features from
        <code class="literal">uima.tcas.Annotation</code>, its supertype; they are not visible in
        this view because inherited features are not shown. One additional feature,
        <code class="literal">building</code>, is declared. It takes a String as its value. Instead
        of String, we could have declared the range-type of our feature to be any other CAS type
        (defined or built-in).</p>
      
      <p>If you are not using Eclipse, if you need to edit the type system, do so using any XML
        or text editor, directly. The following is the actual XML representation of the Type
        System displayed above in the editor:</p>
      
      
      <pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
  &lt;typeSystemDescription xmlns="http://uima.apache.org/resourceSpecifier"&gt;
    &lt;name&gt;TutorialTypeSystem&lt;/name&gt;
    &lt;description&gt;Type System Definition for the tutorial examples - 
        as of Exercise 1&lt;/description&gt;
    &lt;vendor&gt;Apache Software Foundation&lt;/vendor&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;types&gt;
      &lt;typeDescription&gt;
        &lt;name&gt;org.apache.uima.tutorial.RoomNumber&lt;/name&gt;
        &lt;description&gt;&lt;/description&gt;
        &lt;supertypeName&gt;uima.tcas.Annotation&lt;/supertypeName&gt;
        &lt;features&gt;
          &lt;featureDescription&gt;
            &lt;name&gt;building&lt;/name&gt;
            &lt;description&gt;Building containing this room&lt;/description&gt;
            &lt;rangeTypeName&gt;uima.cas.String&lt;/rangeTypeName&gt;
          &lt;/featureDescription&gt;
        &lt;/features&gt;
      &lt;/typeDescription&gt;
    &lt;/types&gt;
  &lt;/typeSystemDescription&gt;</pre>
      
    </div>
    
    <div class="section" title="1.1.2.&nbsp;Generating Java Source Files for CAS Types"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.generating_jcas_sources">1.1.2.&nbsp;Generating Java Source Files for CAS Types</h3></div></div></div>
      
      
      <p>When you save a descriptor that you have modified, the Component Descriptor
        Editor will automatically generate Java classes corresponding to the types that are
        defined in that descriptor (unless this has been disabled), using a utility called
        JCasGen. These Java classes will have the same name (including package) as the CAS
        types, and will have get and set methods for each of the features that you have
        defined.</p>
      
      <p>This feature is enabled/disabled using the UIMA menu pulldown (or the Eclipse
        Preferences <span class="symbol">&#8594;</span> UIMA). If automatic running of JCasGen is not happening, please
        make sure the option is checked:</p>
      
      
      <div class="screenshot">
      <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image004.jpg" width="564" alt="Screenshot of enabling automatic running of JCasGen"></td></tr></table></div>
  </div>
      
      <p>The Java class for the example org.apache.uima.tutorial.RoomNumber type can
        be found in <code class="literal">src/org/apache/uima/tutorial/RoomNumber.java</code>
        . You will see how to use these generated classes in the next section.</p>
      
      <p>If you are not using the Component Descriptor Editor, you will need to generate
        these Java classes by using the <span class="emphasis"><em>JCasGen</em></span> tool. JCasGen reads a
        Type System Descriptor XML file and generates the corresponding Java classes that
        you can then use in your annotator code. To launch JCasGen, run the jcasgen shell
        script located in the <code class="literal">/bin</code> directory of the UIMA SDK
        installation. This should launch a GUI that looks something like this:</p>
      
      
      <div class="screenshot">
        <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image006.jpg" width="564" alt="Screenshot of JCasGen"></td></tr></table></div>
</div>
      
      <p>Use the <span class="quote">&#8220;<span class="quote">Browse</span>&#8221;</span> buttons to select your input file
        (TutorialTypeSystem.xml) and output directory (the root of the source tree into
        which you want the generated files placed). Then click the <span class="quote">&#8220;<span class="quote">Go</span>&#8221;</span>
        button. If the Type System Descriptor has no errors, new Java source files will be
        generated under the specified output directory.</p>
      
      <p>There are some additional options to choose from when running JCasGen; please
        refer to the <a href="tools.html#ugr.tools.jcasgen" class="olink">Chapter&nbsp;7, <i>JCasGen User's Guide</i></a> for details.</p>
    </div>
    
    <div class="section" title="1.1.3.&nbsp;Developing Your Annotator Code"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.developing_annotator_code">1.1.3.&nbsp;Developing Your Annotator Code</h3></div></div></div>
      
      
      <p>Annotator implementations all implement a standard interface (AnalysisComponent), having several
        methods, the most important of which are:
        
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
            <p><code class="literal">initialize</code>, </p>
          </li><li class="listitem">
            <p><code class="literal">process</code>, and </p>
          </li><li class="listitem">
            <p><code class="literal">destroy</code>. </p>
          </li></ul></div>
      
      <p><code class="literal">initialize</code> is called by the framework once when it first creates an instance of the
        annotator class. <code class="literal">process</code> is called once per item being processed.
        <code class="literal">destroy</code> may be called by the application when it is done using your annotator. There is a 
        default implementation of this interface for annotators using the JCas, called JCasAnnotator_ImplBase, which 
        has implementations of all required methods except for the process method.</p>
      
      <p>Our annotator class extends the JCasAnnotator_ImplBase; most annotators that use the JCas will extend
        from this class, so they only have to implement the process method. This class is not restricted to handling
        just text; see <a href="tutorials_and_users_guides.html#ugr.tug.aas" class="olink">Chapter&nbsp;5, <i>Annotations, Artifacts, and Sofas</i></a>.</p>
      
      <p>Annotators are not required to extend from the JCasAnnotator_ImplBase class; they may instead
        directly implement the AnalysisComponent interface, and provide all method implementations themselves.
        <sup>[<a name="d4e215" href="#ftn.d4e215" class="footnote">1</a>]</sup> This allows you to have
        your annotator inherit from some other superclass if necessary. If you would like to do this, see the Javadocs
        for JCasAnnotator for descriptions of the methods you must implement.</p>
      
      <p>Annotator classes need to be public, cannot be declared abstract, and must have public, 0-argument 
        constructors, so that they can be instantiated by the framework. <sup>[<a name="d4e222" href="#ftn.d4e222" class="footnote">2</a>]</sup> .</p>
      
      <p>The class definition for our RoomNumberAnnotator implements the process method, and is shown here. You
        can find the source for this in the
        <code class="literal">uimaj-examples/src/org/apache/uima/tutorial/ex1/RoomNumberAnnotator.java</code> .
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
        <p>In Eclipse, in the <span class="quote">&#8220;<span class="quote">Package Explorer</span>&#8221;</span> view, this will appear by default in the project
          <code class="literal">uimaj-examples</code>, in the folder <code class="literal">src</code>, in the package
          <code class="literal">org.apache.uima.tutorial.ex1</code>.</p></div><p> In Eclipse, open the
        RoomNumberAnnotator.java in the uimaj-examples project, under the src directory.</p>
      
      
      <pre class="programlisting">package org.apache.uima.tutorial.ex1;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.uima.analysis_component.JCasAnnotator_ImplBase;
import org.apache.uima.jcas.JCas;
import org.apache.uima.tutorial.RoomNumber;

/**
 * Example annotator that detects room numbers using 
 * Java 1.4 regular expressions.
 */
public class RoomNumberAnnotator extends JCasAnnotator_ImplBase {
  private Pattern mYorktownPattern = 
        Pattern.compile("\\b[0-4]\\d-[0-2]\\d\\d\\b");

  private Pattern mHawthornePattern = 
        Pattern.compile("\\b[G1-4][NS]-[A-Z]\\d\\d\\b");

  public void process(JCas aJCas) {
    // Discussed Later
  }
}</pre>
      
      <p>The two Java class fields, mYorktownPattern and mHawthornePattern, hold regular expressions that
        will be used in the process method. Note that these two fields are part of the Java implementation of the
        annotator code, and not a part of the CAS type system. We are using the regular expression facility that is
        built into Java 1.4. It is not critical that you know the details of how this works, but if you are curious the
        details can be found in the Java API docs for the java.util.regex package.</p>
      
      <p>The only method that we are required to implement is <code class="literal">process</code>. This method is typically 
        called once for each document that is being analyzed. This method takes one argument, which is a JCas instance; 
        this holds the document to be analyzed and all of the analysis results. <sup>[<a name="d4e236" href="#ftn.d4e236" class="footnote">3</a>]</sup></p>
      
      
      <pre class="programlisting">public void process(JCas aJCas) {
  // get document text
  String docText = aJCas.getDocumentText();
  // search for Yorktown room numbers
  Matcher matcher = mYorktownPattern.matcher(docText);
  int pos = 0;
  while (matcher.find(pos)) {
    // found one - create annotation
    RoomNumber annotation = new RoomNumber(aJCas);
    annotation.setBegin(matcher.start());
    annotation.setEnd(matcher.end());
    annotation.setBuilding("Yorktown");
    annotation.addToIndexes();
    pos = matcher.end();
  }
  // search for Hawthorne room numbers
  matcher = mHawthornePattern.matcher(docText);
  pos = 0;
  while (matcher.find(pos)) {
    // found one - create annotation
    RoomNumber annotation = new RoomNumber(aJCas);
    annotation.setBegin(matcher.start());
    annotation.setEnd(matcher.end());
    annotation.setBuilding("Hawthorne");
    annotation.addToIndexes();
    pos = matcher.end();
  }
}</pre>
      
      <p>The Matcher class is part of the java.util.regex package and is used to find the room numbers in the
        document text. When we find one, recording the annotation is as simple as creating a new Java object and
        calling some set methods:</p>
      
      
      <pre class="programlisting">RoomNumber annotation = new RoomNumber(aJCas);
annotation.setBegin(matcher.start());
annotation.setEnd(matcher.end());
annotation.setBuilding("Yorktown");</pre>
      
      <p>The <code class="literal">RoomNumber</code> class was generated from the type system description by the
        Component Descriptor Editor or the JCasGen tool, as discussed in the previous section.</p>
      
      <p>Finally, we call <code class="literal">annotation.addToIndexes()</code> to add the new annotation to the
        indexes maintained in the CAS. By default, the CAS implementation used for analysis of text documents keeps
        an index of all annotations in their order from beginning to end of the document. Subsequent annotators or
        applications use the indexes to iterate over the annotations. </p>
      
      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
      <p> If you don't add the instance to the indexes, it cannot be retrieved by down-stream annotators,
        using the indexes. </p></div>
      
      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
      <p>You can also call <code class="literal">addToIndexes()</code> on Feature Structures that are not subtypes of
        <code class="literal">uima.tcas.Annotation</code>, but these will not be sorted in any particular way. If you want
        to specify a sort order, you can define your own custom indexes in the CAS: see <a href="references.html#ugr.ref.cas" class="olink">Chapter&nbsp;4, <i>CAS Reference</i></a> and <a href="references.html#ugr.ref.xml.component_descriptor.aes.index" class="olink">Section&nbsp;2.4.1.7, &#8220;Index Definition&#8221;</a> for details.</p></div>
      
      <p>We're almost ready to test the RoomNumberAnnotator. There is just one more step
        remaining.</p>
    </div>
    <div class="section" title="1.1.4.&nbsp;Creating the XML Descriptor"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.creating_xml_descriptor">1.1.4.&nbsp;Creating the XML Descriptor</h3></div></div></div>
      
      
      <p>The UIMA architecture requires that descriptive information about an
        annotator be represented in an XML file and provided along with the annotator class
        file(s) to the UIMA framework at run time. This XML file is called an
        <span class="emphasis"><em>Analysis Engine Descriptor</em></span>. The descriptor includes:
        
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Name, description, version, and vendor</p>
          </li><li class="listitem"><p>The annotator's inputs and outputs, defined in terms of
            the types in a Type System Descriptor</p></li><li class="listitem"><p>Declaration of the configuration parameters that the
            annotator accepts </p></li></ul></div><p> </p>
      
      <p>The <span class="emphasis"><em>Component Descriptor Editor</em></span> plugin, which we
        previously used to edit the Type System descriptor, can also be used to edit Analysis
        Engine Descriptors.</p>
      
      <p>A descriptor for our RoomNumberAnnotator is provided with the UIMA
        distribution under the name
        <code class="literal">descriptors/tutorial/ex1/RoomNumberAnnotator.xml.</code> To
        edit it in Eclipse, right-click on that file in the navigator and select Open With
        <span class="symbol">&#8594;</span> Component Descriptor Editor.</p> <div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>In Eclipse, you can double
      click on the tab at the top of the Component Descriptor Editor's window
      identifying the currently selected editor, and the window will
      <span class="quote">&#8220;<span class="quote">Maximize</span>&#8221;</span>. Double click it again to restore the original size.</p>
      </div>
      
      <p>If you are not using Eclipse, you will need to edit Analysis Engine descriptors
        manually. See <a class="xref" href="#ugr.tug.aae.xml_intro_ae_descriptor" title="1.8.&nbsp;Introduction to Analysis Engine Descriptor XML Syntax">Section&nbsp;1.8, &#8220;Analysis Engine XML Descriptor&#8221;</a> for an
        introduction to the Analysis Engine descriptor XML syntax. The remainder of this
        section assumes you are using the Component Descriptor Editor plug-in to edit the
        Analysis Engine descriptor.</p>
      
      <p>The Component Descriptor Editor consists of several tabbed pages; we will only
        need to use a few of them here. For more information on using this editor, see <a href="tools.html#ugr.tools.cde" class="olink">Chapter&nbsp;1, <i>Component Descriptor Editor User's Guide</i></a>.</p>
      
      <p>The initial page of the Component Descriptor Editor is the Overview page, which
        appears as follows:</p>
      
      
      <div class="screenshot">
  <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image008.jpg" width="564" alt="Screenshot of Component Descriptor Editor overview page"></td></tr></table></div>
</div>
      
      <p>This presents an overview of the RoomNumberAnnotator Analysis Engine (AE). The
        left side of the page shows that this descriptor is for a
        <span class="emphasis"><em>Primitive</em></span> AE (meaning it consists of a single annotator),
        and that the annotator code is developed in Java. Also, it specifies the Java class
        that implements our logic (the code which was discussed in the previous section).
        Finally, on the right side of the page are listed some descriptive attributes of our
        annotator.</p>
      
      <p>The other two pages that need to be filled out are the Type System page and the
        Capabilities page. You can switch to these pages using the tabs at the bottom of the
        Component Descriptor Editor. In the tutorial, these are already filled out for
        you.</p>
      
      <p>The RoomNumberAnnotator will be using the TutorialTypeSystem we looked at in
        Section <a class="xref" href="#ugr.tug.aae.defining_types" title="1.1.1.&nbsp;Defining Types">Section&nbsp;1.1.1, &#8220;Defining Types&#8221;</a>. To specify this, we add
        this type system to the Analysis Engine's list of Imported Type Systems, using
        the Type System page's right side panel, as shown here:</p>
      
      
      <div class="screenshot">
   <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image010.jpg" width="564" alt="Screenshot of CDE Type System page"></td></tr></table></div>
 </div>
      
      <p>On the Capabilities page, we define our annotator's inputs and outputs, in
        terms of the types in the type system. The Capabilities page is shown below:</p>
      
      
      <div class="screenshot">
   <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="525"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image012.jpg" width="525" alt="Screenshot of CDE Capabilities page"></td></tr></table></div>
 </div>
      
      <p>Although capabilities come in sets, having multiple sets is deprecated; here
        we're just using one set. The RoomNumberAnnotator is very simple. It requires
        no input types, as it operates directly on the document text -- which is supplied as a
        part of the CAS initialization (and which is always assumed to be present). It
        produces only one output type (RoomNumber), and it sets the value of the
        <code class="literal">building</code> feature on that type. This is all represented on the
        Capabilities page.</p>
      
      <p>The Capabilities page has two other parts for specifying languages and Sofas.
        The languages section allows you to specify which languages your Analysis Engine
        supports. The RoomNumberAnnotator happens to be language-independent, so we can
        leave this blank. The Sofas section allows you to specify the names of additional
        subjects of analysis. This capability and the Sofa Mappings at the bottom are
        advanced topics, described in <a href="tutorials_and_users_guides.html#ugr.tug.aas" class="olink">Chapter&nbsp;5, <i>Annotations, Artifacts, and Sofas</i></a>. </p>
      
      <p>This is all of the information we need to provide for a simple annotator. If you
        want to peek at the XML that this tool saves you from having to write, click on the
        <span class="quote">&#8220;<span class="quote">Source</span>&#8221;</span> tab at the bottom to view the generated XML.</p>
    </div>
    
    <div class="section" title="1.1.5.&nbsp;Testing Your Annotator"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.testing_your_annotator">1.1.5.&nbsp;Testing Your Annotator</h3></div></div></div>
      
      
      <p>Having developed an annotator, we need a way to try it out on some example
        documents. The UIMA SDK includes a tool called the Document Analyzer that will allow
        us to do this. To run the Document Analyzer, execute the documentAnalyzer shell
        script that is in the <code class="literal">bin</code> directory of your UIMA SDK
        installation, or, if you are using the example Eclipse project, execute the
        <span class="quote">&#8220;<span class="quote">UIMA Document Analyzer</span>&#8221;</span> run configuration supplied with that
        project. (To do this, click on the menu bar Run <span class="symbol">&#8594;</span> Run ... <span class="symbol">&#8594;</span> and under Java
        Applications in the left box, click on UIMA Document Analyzer.)</p>
      
      <p>You should see a screen that looks like this:</p>
      
      
      <div class="screenshot">
   <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image014.jpg" width="564" alt="Screenshot of UIMA Document Analyzer GUI"></td></tr></table></div>       
      </div>
      
      <p>There are six options on this screen:</p>
      
      <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Directory containing documents to analyze</p>
        </li><li class="listitem"><p>Directory where analysis results will be written</p>
        </li><li class="listitem"><p>The XML descriptor for the Analysis Engine (AE) you want to
          run</p></li><li class="listitem"><p>(Optional) an XML tag, within the input documents, that contains
          the text to be analyzed. For example, the value TEXT would cause the AE to only
          analyze the portion of the document enclosed within
          &lt;TEXT&gt;...&lt;/TEXT&gt; tags.</p></li><li class="listitem"><p>Language of the document </p></li><li class="listitem"><p>Character encoding </p></li></ol></div>
      
      <p>Use the Browse button next to the third item to set the <span class="quote">&#8220;<span class="quote">Location of AE XML
        Descriptor</span>&#8221;</span> field to the descriptor we've just been discussing
        &#8212;
        <code class="literal">&lt;where-you-installed-uima-e.g.UIMA_HOME&gt; 
          /examples/descriptors/tutorial/ex1/RoomNumberAnnotator.xml</code>
        . Set the other fields to the values shown in the screen shot above (which should be the
        default values if this is the first time you've run the Document Analyzer). Then
        click the <span class="quote">&#8220;<span class="quote">Run</span>&#8221;</span> button to start processing.</p>
      
      <p>When processing completes, an <span class="quote">&#8220;<span class="quote">Analysis Results</span>&#8221;</span> window should
        appear.</p>
      
      
      <div class="screenshot">
   <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="347"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image016.jpg" width="347" alt="Screenshot of UIMA Document Analyzer Results GUI"></td></tr></table></div>       
      </div>
      
      <p>Make sure <span class="quote">&#8220;<span class="quote">Java Viewer</span>&#8221;</span> is selected as the Results Display
        Format, and <span class="bold"><strong>double-click</strong></span> on the document
        UIMASummerSchool2003.txt to view the annotations that were discovered. The view
        should look something like this:</p>
      
      
      <div class="screenshot">
   <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image018.jpg" width="564" alt="Screenshot of UIMA CAS Annotation Viewer GUI"></td></tr></table></div>       
      </div>
      
      <p>You can click the mouse on one of the highlighted annotations to see a list of all
        its features in the frame on the right.</p> <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The legend will only show
      those types which have at least one instance in the CAS, and are declared as outputs in the
      capabilities section of the descriptor (see <a class="xref" href="#ugr.tug.aae.creating_xml_descriptor" title="1.1.4.&nbsp;Creating the XML Descriptor">Section&nbsp;1.1.4, &#8220;Creating the XML Descriptor&#8221;</a>. </p></div>
      
      <p>You can use the DocumentAnalyzer to test any UIMA annotator
        &#8212; just make sure that the annotator's classes are in the class
        path.</p>
    </div>
  </div>
  
  <div class="section" title="1.2.&nbsp;Configuration and Logging"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.aae.configuration_logging">1.2.&nbsp;Configuration and Logging</h2></div></div></div>
    
    
    <div class="section" title="1.2.1.&nbsp;Configuration Parameters"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.configuration_parameters">1.2.1.&nbsp;Configuration Parameters</h3></div></div></div>
      
      
      <p>The example RoomNumberAnnotator from the previous section used hardcoded
        regular expressions and location names, which is obviously not very flexible. For
        example, you might want to have the patterns of room numbers be supplied by a
        configuration parameter, rather than having to redo the annotator's Java code
        to add additional patterns. Rather than add a new hardcoded regular expression for a
        new pattern, a better solution is to use configuration parameters.</p>
      
      <p>UIMA allows annotators to declare configuration parameters in their
        descriptors. The descriptor also specifies default values for the parameters,
        though these can be overridden at runtime.</p>
      
      <div class="section" title="1.2.1.1.&nbsp;Declaring Parameters in the Descriptor"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.declaring_parameters_in_the_descriptor">1.2.1.1.&nbsp;Declaring Parameters in the Descriptor</h4></div></div></div>
        
        
        <p>The example descriptor
          <code class="literal">descriptors/tutorial/ex2/RoomNumberAnnotator.xml</code> is
          the same as the descriptor from the previous section except that information has
          been filled in for the Parameters and Parameter Settings pages of the Component
          Descriptor Editor.</p>
        
        <p>First, in Eclipse, open example two's RoomNumberAnnotator in the
          Component Descriptor Editor, and then go to the Parameters page (click on the
          parameters tab at the bottom of the window), which is shown below:</p>
        
        
        <div class="screenshot">
   <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image020.jpg" width="564" alt="Screenshot of UIMA Component Descriptor Editor (CDE) Parameters page"></td></tr></table></div>       
      </div>
        
        <p>Two parameters &#8211; Patterns and Locations -- have been declared. In this
          screen shot, the mouse (not shown) is hovering over Patterns to show its
          description in the small popup window. Every parameter has the following
          information associated with it:</p>
        
        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>name &#8211; the name by which the annotator code
          refers to the parameter</p></li><li class="listitem"><p>description &#8211; a natural language description of the
            intent of the parameter</p></li><li class="listitem"><p>type &#8211; the data type of the parameter's value
            &#8211; must be one of String, Integer, Float, or Boolean.</p></li><li class="listitem"><p>multiValued &#8211; true if the parameter can take
            multiple-values (an array), false if the parameter takes only a single value.
            Shown above as <code class="literal">Multi</code>.</p></li><li class="listitem"><p>mandatory &#8211; true if a value must be provided for the
            parameter. Shown above as <code class="literal">Req</code> (for required). </p>
          </li></ul></div>
        
        <p>Both of our parameters are mandatory and accept an array of Strings as their
          value.</p>
        
        <p>Next, default values are assigned to the parameters on the Parameter Settings
          page:</p>
        
        
        <div class="screenshot">
   <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image022.jpg" width="564" alt="Screenshot of UIMA Component Descriptor Editor (CDE) Parameter Settings page"></td></tr></table></div>       
      </div>
        
        <p>Here the <span class="quote">&#8220;<span class="quote">Patterns</span>&#8221;</span> parameter is selected, and the right pane
          shows the list of values for this parameter, in this case the regular expressions
          that match particular room numbering conventions. Notice the third pattern is
          new, for matching the style of room numbers in the third building, which has room
          numbers such as <code class="literal">J2-A11</code>.</p>
      </div>
      <div class="section" title="1.2.1.2.&nbsp;Accessing Parameter Values from the Annotator Code"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.accessing_parameter_values_from_annotator">1.2.1.2.&nbsp;Accessing Parameter Values from the Annotator Code</h4></div></div></div>
        
        
        <p>The class
          <code class="literal">org.apache.uima.tutorial.ex2.RoomNumberAnnotator</code> has
          overridden the initialize method. The initialize method is called by the UIMA
          framework when the annotator is instantiated, so it is a good place to read
          configuration parameter values. The default initialize method does nothing with
          configuration parameters, so you have to override it. To see the code in Eclipse,
          switch to the src folder, and open
          <code class="literal">org.apache.uima.tutorial.ex2</code>. Here is the method
          body:</p>
        
        
        <pre class="programlisting">/**
* @see AnalysisComponent#initialize(UimaContext)
*/
public void initialize(UimaContext aContext) 
        throws ResourceInitializationException {
  super.initialize(aContext);
  
  // Get config. parameter values  
  String[] patternStrings = 
        (String[]) aContext.getConfigParameterValue("Patterns");
  mLocations = 
        (String[]) aContext.getConfigParameterValue("Locations");

  // compile regular expressions
  mPatterns = new Pattern[patternStrings.length];
  for (int i = 0; i &lt; patternStrings.length; i++) {
    mPatterns[i] = Pattern.compile(patternStrings[i]);
  }
}</pre>
        
        <p>Configuration parameter values are accessed through the UimaContext. As you
          will see in subsequent sections of this chapter, the UimaContext is the
          annotator's access point for all of the facilities provided by the UIMA
          framework &#8211; for example logging and external resource access.</p>
        
        <p>The UimaContext's <code class="literal">getConfigParameterValue</code>
          method takes the name of the parameter as an argument; this must match one of the
          parameters declared in the descriptor. The return value of this method is a Java
          Object, whose type corresponds to the declared type of the parameter. It is up to the
          annotator to cast it to the appropriate type, String[] in this case.</p>
        
        <p>If there is a problem retrieving the parameter values, the framework throws an
          exception. Generally annotators don't handle these, and just let them
          propagate up.</p>
        
        <p>To see the configuration parameters working, run the Document Analyzer
          application and select the descriptor
          <code class="literal">examples/descriptors/tutorial/ex2/RoomNumberAnnotator.xml</code>
          . In the example document <code class="literal">WatsonConferenceRooms.txt</code>, you
          should see some examples of Hawthorne II room numbers that would not have been
          detected by the ex1 version of RoomNumberAnnotator.</p>
      </div>
      
      <div class="section" title="1.2.1.3.&nbsp;Supporting Reconfiguration"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.supporting_reconfiguration">1.2.1.3.&nbsp;Supporting Reconfiguration</h4></div></div></div>
        
        
        <p>If you take a look at the Javadocs (located in the <a class="ulink" href="api/index.html" target="_top">docs/api</a> directory) for
          <code class="literal">org.apache.uima.analysis_component.AnaysisComponent</code>
          (which our annotator implements indirectly through JCasAnnotator_ImplBase),
          you will see that there is a reconfigure() method, which is called by the containing
          application through the UIMA framework, if the configuration parameter values
          are changed.</p>
        
        <p>The AnalysisComponent_ImplBase class provides a default implementation
          that just calls the annotator's destroy method followed by its initialize
          method. This works fine for our annotator. The only situation in which you might
          want to override the default reconfigure() is if your annotator has very expensive
          initialization logic, and you don't want to reinitialize everything if just
          one configuration parameter has changed. In that case, you can provide a more
          intelligent implementation of reconfigure() for your annotator.</p>
        
      </div>
      
      <div class="section" title="1.2.1.4.&nbsp;Configuration Parameter Groups"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.configuration_parameter_groups">1.2.1.4.&nbsp;Configuration Parameter Groups</h4></div></div></div>
        
        
        <p>For annotators with many sets of configuration parameters, UIMA supports
          organizing them into groups. It is possible to define a parameter with the same name
          in multiple groups; one common use for this is for annotators that can process
          documents in several languages and which want to have different parameter
          settings for the different languages.</p>
        
        <p>The syntax for defining parameter groups in your descriptor is fairly
          straightforward &#8211; see <a href="references.html#ugr.ref.xml.component_descriptor" class="olink">Chapter&nbsp;2, <i>Component Descriptor Reference</i></a> for details. Values of
          parameters defined within groups are accessed through the two-argument version
          of <code class="literal">UimaContext.getConfigParameterValue</code>, which takes
          both the group name and the parameter name as its arguments.</p>
      </div>
    </div>
    
    <div class="section" title="1.2.2.&nbsp;Logging"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.logging">1.2.2.&nbsp;Logging</h3></div></div></div>
      
      
      <p>The UIMA SDK provides a logging facility, which is very similar to the
        java.util.logging.Logger class that was introduced in Java 1.4.</p>
      
      <p>In the Java architecture, each logger instance is associated with a name. By
        convention, this name is often the fully qualified class name of the component
        issuing the logging call. The name can be referenced in a configuration file when
        specifying which kinds of log messages to actually log, and where they should
        go.</p>
      
      <p>The UIMA framework supports this convention using the
        <code class="literal">UimaContext</code> object. If you access a logger instance using
        <code class="literal">getContext().getLogger()</code> within an Annotator, the logger
        name will be the fully qualified name of the Annotator implementation class.</p>
      
      <p>Here is an example from the process method of
        <code class="literal">org.apache.uima.tutorial.ex2.RoomNumberAnnotator</code>:
        
        
        </p><pre class="programlisting">getContext().getLogger().log(Level.FINEST,"Found: " + annotation);</pre><p>
        </p>
      
      <p>The first argument to the log method is the level of the log output. Here, a value of
        FINEST indicates that this is a highly-detailed tracing message. While useful for
        debugging, it is likely that real applications will not output log messages at this
        level, in order to improve their performance. Other defined levels, from lowest to
        highest importance, are FINER, FINE, CONFIG, INFO, WARNING, and SEVERE.</p>
      
      <p>If no logging configuration file is provided (see next section), the Java
        Virtual Machine defaults would be used, which typically set the level to INFO and
        higher messages, and direct output to the console.</p>
      
      <p>If you specify the standard UIMA SDK <code class="literal">Logger.properties,</code>
        the output will be directed to a file named uima.log, in the current working directory
        (often the <span class="quote">&#8220;<span class="quote">project</span>&#8221;</span> directory when running from Eclipse, for
        instance).</p> <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>When using Eclipse, the uima.log file, if written
      into the Eclipse workspace in the project uimaj-examples, for example, may not appear
      in the Eclipse package explorer view until you right-click the uimaj-examples project
      with the mouse, and select <span class="quote">&#8220;<span class="quote">Refresh</span>&#8221;</span>. This operation refreshes the
      Eclipse display to conform to what may have changed on the file system. Also, you can set
      the Eclipse preferences for the workspace to automatically refresh (Window <span class="symbol">&#8594;</span>
      Preferences <span class="symbol">&#8594;</span> General <span class="symbol">&#8594;</span> Workspace, then click the <span class="quote">&#8220;<span class="quote">refresh
      automatically</span>&#8221;</span> checkbox.</p></div>
      
      <div class="section" title="1.2.2.1.&nbsp;Specifying the Logging Configuration"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.logging.configuring">1.2.2.1.&nbsp;Specifying the Logging Configuration</h4></div></div></div>
        
        
        <p>The standard UIMA logger uses the underlying Java 1.4 logging mechanism. You
          can use the APIs that come with that to configure the logging. In addition, the
          standard Java 1.4 logging initialization mechanisms will look for a Java System
          Property named <code class="literal">java.util.logging.config.file</code> and if
          found, will use the value of this property as the name of a standard
          <span class="quote">&#8220;<span class="quote">properties</span>&#8221;</span> file, for setting the logging level. Please refer to
          the Java 1.4. documentation for more information on the format and use of this
          file.</p>
        
        <p>Two sample logging specification property files can be found in the UIMA_HOME
          directory where the UIMA SDK is installed:
          <code class="literal">config/Logger.properties</code>, and
          <code class="literal">config/FileConsoleLogger.properties</code>. These specify the same
          logging, except the first logs just to a file, while the second logs both to a file and
          to the console. You can edit these files, or create additional ones, as described
          below, to change the logging behavior.</p>
        
        <p>When running your own Java application, you can specify the location of the
          logging configuration file on your Java command line by setting the Java system
          property <code class="literal">java.util.logging.config.file</code> to be the logging
          configuration filename. This file specification can be either absolute or
          relative to the working directory. For example:
          
          
          </p><pre class="programlisting">java "-Djava.util.logging.config.file=C:/Program Files/apache-uima/config/Logger.properties"</pre><p>
          </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In a shell script, you can use environment variables such as
          UIMA_HOME if convenient.</p></div><p> </p>
               
        <p>If you are using Eclipse to launch your application, you can set this property
          in the VM arguments section of the Arguments tab of the run configuration screen. If
          you've set an environment variable UIMA_HOME, you could for example, use the
          string:
          <code class="literal">"-Djava.util.logging.config.file=${env_var:UIMA_HOME}/config/Logger.properties".</code>
          </p>
        
        <p>If you running the .bat or .sh files in the UIMA SDK's <code class="literal">bin</code> directory, you can specify the location of your
           logger configuration file by setting the <code class="literal">UIMA_LOGGER_CONFIG_FILE</code> environment variable prior to running the script,
           for example (on Windows): 

           </p><pre class="programlisting">set UIMA_LOGGER_CONFIG_FILE=C:/myapp/MyLogger.properties</pre><p>        
        </p>        
      </div>
      
      <div class="section" title="1.2.2.2.&nbsp;Setting Logging Levels"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.logging.setting_logging_levels">1.2.2.2.&nbsp;Setting Logging Levels</h4></div></div></div>
        
        
        <p>Within the logging control file, the default global logging level specifies
          which kinds of events are logged across all loggers. For any given facility this
          global level can be overridden by a facility specific level. Multiple handlers are
          supported. This allows messages to be directed to a log file, as well as to a
          <span class="quote">&#8220;<span class="quote">console</span>&#8221;</span>. Note that the ConsoleHandler also has a separate level
          setting to limit messages printed to the console. For example: <code class="literal">.level=
          INFO</code> </p>
        
        <p>The properties file can change where the log is written, as well.</p>
        
        <p>Facility specific properties allow different logging for each class, as
          well. For example, to set the com.xyz.foo logger to only log SEVERE messages:
          <code class="literal">com.xyz.foo.level = SEVERE</code></p>
        
        <p>If you have a sample annotator in the package
          <code class="literal">org.apache.uima.SampleAnnotator</code> you can set the log level
          by specifying: <code class="literal">org.apache.uima.SampleAnnotator.level =
          ALL</code></p>
        
        <p>There are other logging controls; for a full discussion, please read the
          contents of the <code class="literal">Logger.properties</code> file and the Java
          specification for logging in Java 1.4.</p>
      </div>
      
      <div class="section" title="1.2.2.3.&nbsp;Format of logging output"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.logging.output_format">1.2.2.3.&nbsp;Format of logging output</h4></div></div></div>
        
        
        <p>The logging output is formatted by handlers specified in the properties file
          for configuring logging, described above. The default formatter that comes with
          the UIMA SDK formats logging output as follows:</p>
        
        <p><code class="literal">Timestamp - threadID: sourceInfo: Message level:
          message</code></p>
        
        <p> Here's an example:</p>
        
        <p><code class="literal">7/12/04 2:15:35 PM - 10:
          org.apache.uima.util.TestClass.main(62): INFO: You are not logged
          in!</code></p>
      </div>
      
      <div class="section" title="1.2.2.4.&nbsp;Meaning of the logging severity levels"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.logging.meaning_of_severity_levels">1.2.2.4.&nbsp;Meaning of the logging severity levels</h4></div></div></div>
        
        
        <p>These levels are defined by the Java logging framework, which was
          incorporated into Java as of the 1.4 release level. The levels are defined in the
          Javadocs for java.util.logging.Level, and include both logging and tracing
          levels:
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>OFF is a special level that can be used to turn off
              logging.</p></li><li class="listitem"><p>ALL indicates that all messages should be logged. </p>
            </li><li class="listitem"><p>CONFIG is a message level for configuration messages. These
              would typically occur once (during configuration) in methods like
              <code class="literal">initialize()</code>. </p></li><li class="listitem"><p>INFO is a message level for informational messages, for
              example, connected to server IP: 192.168.120.12 </p></li><li class="listitem"><p>WARNING is a message level indicating a potential
              problem.</p></li><li class="listitem"><p>SEVERE is a message level indicating a serious
              failure.</p></li></ul></div>
        
        <p> Tracing levels, typically used for debugging:
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>FINE is a message level providing tracing information,
              typically at a collection level (messages occurring once per collection).
              </p></li><li class="listitem"><p>FINER indicates a fairly detailed tracing message,
              typically at a document level (once per document).</p></li><li class="listitem"><p>FINEST indicates a highly detailed tracing message. </p>
            </li></ul></div>
      </div>
      
      <div class="section" title="1.2.2.5.&nbsp;Using the logger outside of an annotator"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.logging.using_outside_of_an_annotator">1.2.2.5.&nbsp;Using the logger outside of an annotator</h4></div></div></div>
        
        
        <p>An application using UIMA may want to log its messages using the same logging
          framework. This can be done by getting a reference to the UIMA logger, as follows:
          
          
          </p><pre class="programlisting">Logger logger = UIMAFramework.getLogger(TestClass.class);</pre><p>
          </p>
        
        <p>The optional class argument allows filtering by class (if the log handler
          supports this). If not specified, the name of the returned logger instance is
          <span class="quote">&#8220;<span class="quote">org.apache.uima</span>&#8221;</span>.</p>
      </div>
      
      <div class="section" title="1.2.2.6.&nbsp;Changing the underlying UIMA logging implementation"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.logging.change_logger_implementation">1.2.2.6.&nbsp;Changing the underlying UIMA logging implementation</h4></div></div></div>
        
        
        <p>By default the UIMA framework use, under the hood of the UIMA Logger interface, the Java logging framework 
        to do logging. But it is possible to change the logging implementation that UIMA use from Java logging to 
        an arbitrary logging system when specifying the system property  
          </p><pre class="programlisting">-Dorg.apache.uima.logger.class=&lt;loggerClass&gt;</pre><p>
        when the UIMA framework is started.
        </p>
        <p>
          The specified logger class must be available in the classpath and have to implement the 
          <code class="code">org.apache.uima.util.Logger</code> interface. 
        </p>
        
        <p>
          UIMA also provides a logging implementation that use Apache Log4j instead of Java logging. To
          use Log4j you have to provide the Log4j jars in the classpath and your application 
          must specify the logging configuration as shown below. 
          </p><pre class="programlisting">-Dorg.apache.uima.logger.class=&lt;org.apache.uima.util.impl.Log4jLogger_impl&gt;</pre><p>
        </p>
      </div>
      
      
    </div>
  </div>  
  <div class="section" title="1.3.&nbsp;Building Aggregate Analysis Engines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.aae.building_aggregates">1.3.&nbsp;Building Aggregate Analysis Engines</h2></div></div></div>
    
    
    <div class="section" title="1.3.1.&nbsp;Combining Annotators"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.combining_annotators">1.3.1.&nbsp;Combining Annotators</h3></div></div></div>
      
      
      <p>The UIMA SDK makes it very easy to combine any sequence of Analysis Engines to
        form an <span class="emphasis"><em>Aggregate Analysis Engine</em></span>. This is done through an
        XML descriptor; no Java code is required!</p>
      
      <p>If you go to the <code class="literal">examples/descriptors/tutorial/ex3</code>
        folder (in Eclipse, it's in your uimaj-examples project, under the
        <code class="literal">descriptors/tutorial/ex3</code> folder), you will find a
        descriptor for a TutorialDateTime annotator. This annotator detects dates and
        times. To see what this annotator can do, try it out
        using the Document Analyzer. If you are curious as to how this annotator works, the
        source code is included, but it is not necessary to understand the code at this
        time.</p>
      
      <p>We are going to combine the TutorialDateTime annotator with the
        RoomNumberAnnotator to create an aggregate Analysis Engine. This is illustrated
        in the following figure:
        
        </p><div class="figure"><a name="ugr.tug.aae.fig.combining_annotators"></a><div class="figure-contents">
          
          <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image024.png" width="564" alt="Combining Annotators to form an Aggregate Analysis Engine"></td></tr></table></div>
        </div><p class="title"><b>Figure&nbsp;1.1.&nbsp;Combining Annotators to form an Aggregate Analysis Engine</b></p></div><p><br class="figure-break"> </p>
      
      <p>The descriptor that does this is named
        <code class="literal">RoomNumberAndDateTime.xml</code>, which you can open in the
        Component Descriptor Editor plug-in. This is in the uimaj-examples project in the
        folder <code class="literal">descriptors/tutorial/ex3</code>. </p>
      
      <p>The <span class="quote">&#8220;<span class="quote">Aggregate</span>&#8221;</span> page of the Component Descriptor Editor is
        used to define which components make up the aggregate. A screen shot is shown below.
        (If you are not using Eclipse, see <a class="xref" href="#ugr.tug.aae.xml_intro_ae_descriptor" title="1.8.&nbsp;Introduction to Analysis Engine Descriptor XML Syntax">Section&nbsp;1.8, &#8220;Analysis Engine XML Descriptor&#8221;</a> for the actual XML syntax
        for Aggregate Analysis Engine Descriptors.)</p>
      
      
        <div class="screenshot">
  <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image026.jpg" width="564" alt="Aggregate page of the Component Descriptor Editor (CDE)"></td></tr></table></div>
</div>
        
      <p>On the left side of the screen is the list of component engines that make up the
        aggregate &#8211; in this case, the TutorialDateTime annotator and the
        RoomNumberAnnotator. To add a component, you can click the <span class="quote">&#8220;<span class="quote">Add</span>&#8221;</span>
        button and browse to its descriptor. You can also click the <span class="quote">&#8220;<span class="quote">Find AE</span>&#8221;</span>
        button and search for an Analysis Engine in your Eclipse workspace.
        </p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <span class="quote">&#8220;<span class="quote">AddRemote</span>&#8221;</span> button is used for adding components
        which run remotely (for example, on another machine using a remote networking
        connection). This capability is described in section <a href="tutorials_and_users_guides.html#ugr.tug.application.how_to_call_a_uima_service" class="olink">Section&nbsp;3.6.3, &#8220;Calling a UIMA Service&#8221;</a>,</p>
        </div><p> </p>
      
      <p>The order of the components in the left pane does not imply an order of
        execution. The order of execution, or <span class="quote">&#8220;<span class="quote">flow</span>&#8221;</span> is determined in the
        <span class="quote">&#8220;<span class="quote">Component Engine Flow</span>&#8221;</span> section on the right. UIMA supports
        different types of algorithms (including user-definable) for determining the
        flow. Here we pick the simplest: <code class="literal">FixedFlow</code>. We have chosen to
        have the RoomNumberAnnotator execute first, although in this case it
        doesn't really matter, since the RoomNumber and DateTime annotators do not
        have any dependencies on one another.</p>
      
      <p>If you look at the <span class="quote">&#8220;<span class="quote">Type System</span>&#8221;</span> page of the Component
        Descriptor Editor, you will see that it displays the type system but is not
        editable. The Type System of an Aggregate Analysis Engine is automatically
        computed by merging the Type Systems of all of its components.</p>
      
      <div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>If the components have different definitions for the same type name,
        The Component Descriptor Editor will show a warning.  It is possible to continue past
        this warning, in which case your aggregate's type system will have the correct
        <span class="quote">&#8220;<span class="quote">merged</span>&#8221;</span>
        type definition that contains all of the features defined on that type by all of your
        components.  However, it is not recommended to use this feature in conjunction with JCAS,
        since the JCAS Java Class definitions cannot be so easily merged.  See
        <a href="references.html#ugr.ref.jcas.merging_types_from_other_specs" class="olink">Section&nbsp;5.5, &#8220;Merging Types&#8221;</a> for more information.
      </p></div>
      
      <p>The Capabilities page is where you explicitly declare the aggregate Analysis
        Engine's inputs and outputs. Sofas and Languages are described later.
        
          
          </p><div class="screenshot">
     <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image028.jpg" width="564" alt="Screen shot of the Capabilities page of the Component Descriptor Editor"></td></tr></table></div>
   </div><p>
          </p>
        <p>Note that it is not automatically assumed that all outputs of each component
          Analysis Engine (AE) are passed through as outputs of the aggregate AE. If, for example,
          the TutorialDateTime annotator also produced Word and Sentence annotations, 
          but those were not of interest as output in this case, we can exclude them from the 
          list of outputs.</p>
        
        <p>You can run this AE using the Document Analyzer in the same way that you run any
          other AE. Just select the <code class="literal">examples/descriptors/tutorial/ex3/
          RoomNumberAndDateTime.xml</code> descriptor and click the Run button. You
          should see that RoomNumbers, Dates, and Times are all shown:</p>
        
        <div class="screenshot">
     <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image030.jpg" width="564" alt="Screen shot results of running the Document Analyzer"></td></tr></table></div>
   </div>
        
    </div>
    
    <div class="section" title="1.3.2.&nbsp;AAEs can also contain CAS Consumers"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.aaes_can_contain_cas_consumers">1.3.2.&nbsp;AAEs can also contain CAS Consumers</h3></div></div></div>
      
      
      <p>In addition to aggregating Analysis Engines, Aggregates can also contain CAS
        Consumers (see <a href="tutorials_and_users_guides.html#ugr.tug.cpe" class="olink">Chapter&nbsp;2, <i>Collection Processing Engine Developer's Guide</i></a>, or even a mixture of these components with regular
        Analysis Engines. The UIMA Examples has an example of an Aggregate which contains
        both an analysis engine and a CAS consumer, in
        <code class="literal">examples/descriptors/MixedAggregate.xml.</code></p>
      
      <p>Analysis Engines support the <code class="literal">collectionProcessComplete</code>
        method, which is particularly important for many CAS Consumers.  If
        an application (or a Collection Processing Engine) calls 
        <code class="literal">collectionProcessComplete</code> no an aggregate, the framework
        will deliver that call to all of the components of the aggregate.  If you use
        one of the built-in flow types (fixedFlow or capabilityLanguageFlow), then the
        order specified in that flow will be the same order in which the
        <code class="literal">collectionProcessComplete</code> calls are made to the components.
        If a custom flow is used, then the calls will be made in arbitrary order.
      </p>
    </div>
    
    <div class="section" title="1.3.3.&nbsp;Reading the Results of Previous Annotators"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.reading_results_previous_annotators">1.3.3.&nbsp;Reading the Results of Previous Annotators</h3></div></div></div>
      
      
      <p>So far, we have been looking at annotators that look directly at the document text. However, annotators
        can also use the results of other annotators. One useful thing we can do at this point is look for the
        co-occurrence of a Date, a RoomNumber, and two Times &#8211; and annotate that as a Meeting.</p>
      
      <p>The CAS maintains <span class="emphasis"><em>indexes</em></span> of annotations, and from an index you can obtain an
        iterator that allows you to step through all annotations of a particular type. Here's some example code
        that would iterate over all of the TimeAnnot annotations in the JCas:
        
        
        </p><pre class="programlisting">FSIndex timeIndex = aJCas.getAnnotationIndex(TimeAnnot.type);
Iterator timeIter = timeIndex.iterator();   
while (timeIter.hasNext()) {
  TimeAnnot time = (TimeAnnot)timeIter.next();

  //do something
}</pre>
      
      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
      <p>You can also use the method
        <code class="literal">JCAS.getJFSIndexRepository().getAllIndexedFS(YourClass.type)</code>, which returns an iterator
        over all instances of <code class="literal">YourClass</code> in no particular order. This can be useful for types
        that are not subtypes of the built-in Annotation type and which therefore have no default sort order.</p>
        
      <p>Also, if you've defined your own custom index as described in <a href="references.html#ugr.ref.xml.component_descriptor.aes.index" class="olink">Section&nbsp;2.4.1.7, &#8220;Index Definition&#8221;</a>, you can get an iterator over that
        specific index by calling <code class="literal">aJCas.getJFSIndexRepository().getIndex(label)</code>.
        The <code class="literal">getIndex(...)</code> method has also a 2 argument form; the second argument, 
      if used, specialized the index to subtype of the type the index was declared to index.  For instance,
      if you defined an index called "allEvents" over the type <code class="literal">Event</code>, and wanted 
      to get an index over just a particular subtype of event, say, <code class="literal">TimeEvent</code>,
      you can ask for that index using 
        <code class="literal">aJCas.getJFSIndexRepository().getIndex("allEvents", TimeEvent.type)</code>.</p></div>
      
      <p>Now that we've explained the basics, let's take a look at the process method for
        <code class="literal">org.apache.uima.tutorial.ex4.MeetingAnnotator</code>. Since we're looking for a
        combination of a RoomNumber, a Date, and two Times, there are four nested iterators. (There's surely a
        better algorithm for doing this, but to keep things simple we're just going to look at every combination
        of the four items.)</p>
      
      <p>For each combination of the four annotations, we compute the span of text that includes all of them, and
        then we check to see if that span is smaller than a <span class="quote">&#8220;<span class="quote">window</span>&#8221;</span> size, a configuration parameter.
        There are also some checks to make sure that we don't annotate the same span of text multiple times. If all
        the checks pass, we create a Meeting annotation over the whole span. There's really nothing to
        it!</p>
      
      <p>The XML descriptor, located in
        <code class="literal">examples/descriptors/tutorial/ex4/MeetingAnnotator.xml</code> , is also very
        straightforward. An important difference from previous descriptors is that this is the first annotator
        we've discussed that has input requirements. This can be seen on the <span class="quote">&#8220;<span class="quote">Capabilities</span>&#8221;</span>
        page of the Component Descriptor Editor:</p>
      
      
      <div class="screenshot">
     <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image032.jpg" width="564" alt="Screen shot of Capabilities page of the Component Descriptor Editor"></td></tr></table></div>
   </div>
      
      <p>If we were to run the MeetingAnnotator on its own, it wouldn't detect anything because it
        wouldn't have any input annotations to work with. The required input annotations can be produced by the
        RoomNumber and DateTime annotators. So, we create an aggregate Analysis Engine containing these two
        annotators, followed by the Meeting annotator. This aggregate is illustrated in <a class="xref" href="#ugr.tug.aae.fig.aggregate_for_meeting_annotator" title="Figure&nbsp;1.2.&nbsp;An Aggregate Analysis Engine where an internal component uses output from previous engines">Figure&nbsp;1.2, &#8220;An Aggregate Analysis Engine where an internal component uses output from previous
            engines&#8221;</a>. The descriptor for this is in
        <code class="literal">examples/descriptors/tutorial/ex4/MeetingDetectorAE.xml</code> . Give it a try in the
        Document Analyzer.
        
        </p><div class="figure"><a name="ugr.tug.aae.fig.aggregate_for_meeting_annotator"></a><div class="figure-contents">
          
          <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image034.png" width="564" alt="An Aggregate Analysis Engine where an internal component uses output from previous engines."></td></tr></table></div>
        </div><p class="title"><b>Figure&nbsp;1.2.&nbsp;An Aggregate Analysis Engine where an internal component uses output from previous
            engines</b></p></div><p><br class="figure-break"> </p>
      
    </div>
  </div>
  
  <div class="section" title="1.4.&nbsp;Other examples"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.aae.other_examples">1.4.&nbsp;Other examples</h2></div></div></div>
    
    
    <p>The UIMA SDK include several other examples you may find interesting,
      including</p>
    
    <div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>SimpleTokenAndSentenceAnnotator &#8211; a simple tokenizer and
        sentence annotator.</p></li><li class="listitem"><p>XmlDetagger &#8211; A multi-sofa annotator that does XML
        detagging. Multiple Sofas (Subjects of Analysis) are described in a later &#8211;
        see <a href="tutorials_and_users_guides.html#ugr.tug.mvs" class="olink">Chapter&nbsp;6, <i>Multiple CAS Views of an Artifact</i></a>.  Reads XML data from the input Sofa
        (named "xmlDocument"); this data can be stored in the CAS as a string or array, or it can
        be a URI to a remote file. The XML is parsed using the JVM's default parser, and the
        plain-text content is written to a new sofa called "plainTextDocument".</p>
      </li><li class="listitem"><p>PersonTitleDBWriterCasConsumer &#8211; a sample CAS Consumer
        which populates a relational database with some annotations. It uses JDBC and in this
        example, hooks up with the Open Source Apache Derby database. </p></li></ul></div>
  </div>
  
  <div class="section" title="1.5.&nbsp;Additional Topics"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.aae.additional_topics">1.5.&nbsp;Additional Topics</h2></div></div></div>
    
    
    <div class="section" title="1.5.1.&nbsp;Contract: Annotator Methods Called by the Framework"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.contract_for_annotator_methods">1.5.1.&nbsp;Contract: Annotator Methods Called by the Framework</h3></div></div></div>
      
      
      
      <p>The UIMA framework ensures that an Annotator instance is called by only one
        thread at a time.  An instance never has to worry about running some method on one 
        thread, and then asynchronously being called using another thread. This approach 
        simplifies the design of annotators &#8211; they do not have to be designed to support
        multi-threading. When multiple threading is wanted, for performance, multiple
        instances of the Annotator are created, each one running on just one thread.</p>
      
      <p>The following table defines the methods called by the framework, when they are
        called, and the requirements annotator implementations must follow.</p>
      
      <div class="informaltable">
        <table style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Method</th><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">When Called by Framework</th><th style="border-bottom: 0.5pt solid black; " align="center">Requirements</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">initialize</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Typically only called once, when instance is created. Can be called
                again if application does a reinitialize call and the default behavior
                isn't overridden (the default behavior for reinitialize is to call
                <code class="literal">destroy</code> followed by
                <code class="literal">initialize</code></td><td style="border-bottom: 0.5pt solid black; ">Normally does one-time initialization, including reading of
                configuration parameters. If the application changes the parameters, it
                can call initialize to have the annotator re-do its
                initialization.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">typeSystemInit</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Called before <code class="literal">process</code> whenever the type system
                in the CAS being passed in differs from what was previously passed in a
                <code class="literal">process</code> call (and called for the first CAS passed in,
                too). The Type System being passed to an annotator only changes in the case of
                remote annotators that are active as servers, receiving possibly
                different type systems to operate on.</td><td style="border-bottom: 0.5pt solid black; ">Typically, users of JCas do not implement any method for this. An
                annotator can use this call to read the CAS type system and setup any instance
                variables that make accessing the types and features convenient.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">process</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">Called once for each CAS. Called by the application if not using
                Collection Processing Manager (CPM); the application calls the process
                method on the analysis engine, which is then delegated by the framework to
                all the annotators in the engine. For Collection Processing application,
                the CPM calls the process method. If the application creates and manages
                your own Collection Processing Engine via API calls (see Javadocs), the
                application calls this on the Collection Processing Engine, and it is
                delegated by the framework to the components.</td><td style="border-bottom: 0.5pt solid black; ">Process the CAS, adding and/or modifying elements in it</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">destroy</td><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">This method can be called by applications, and is also called by the
                Collection Processing Manager framework when the collection processing
                completes. It is also called on Aggregate delegate components, if those 
                components successfully complete their <code class="literal">initialize</code> call, if 
                a subsequent delegate (or flow controller) in the aggregate fails to initialize.
                This allows components which need to clean up things done during initialization 
                to do so.  It is up to the component writer to use a try/finally construct during initialization
                to cleanup from errors that occur during initialization within one component.
                The <code class="literal">destroy</code> call on an aggregate is
                propagated to all contained analysis engines.</td><td style="border-bottom: 0.5pt solid black; ">An annotator should release all resources, close files, close
                database connections, etc., and return to a state where another initialize
                call could be received to restart. Typically, after a destroy call, no
                further calls will be made to an annotator instance.</td></tr><tr><td style="border-right: 0.5pt solid black; ">reconfigure</td><td style="border-right: 0.5pt solid black; "><p>This method is never called by the framework, unless an
                application calls it on the Engine object &#8211; in which case it the
                framework propagates it to all annotators contained in the Engine.</p>
                <p>Its purpose is to signal that the configuration parameters have
                  changed.</p></td><td style="">A default implementation of this calls destroy, followed by
                initialize. This is the only case where initialize would be called more than
                once. Users should implement whatever logic is needed to return the
                annotator to an initialized state, including re-reading the
                configuration parameter data.</td></tr></tbody></table>
      </div>
      
    </div>
    
    <div class="section" title="1.5.2.&nbsp;Reporting errors from Annotators"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.reporting_errors_from_annotators">1.5.2.&nbsp;Reporting errors from Annotators</h3></div></div></div>
      
      
      <p>There are two broad classes of errors that can occur: recoverable and
        unrecoverable. Because Annotators are often expected to process very large numbers
        of artifacts (for example, text documents), they should be written to recover where
        possible.</p>
      
      <p>For example, if an upstream annotator created some input for an annotator which
        is invalid, the annotator may want to log this event, ignore the bad input and
        continue. It may include a notification of this event in the CAS, for further
        downstream annotators to consider. Or, it may throw an exception (see next section)
        &#8211; but in this case, it cannot do any further processing on that
        document.</p> <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The choice of what to do can be made configurable,
      using the configuration parameters. </p></div>
      
    </div>
    
    <div class="section" title="1.5.3.&nbsp;Throwing Exceptions from Annotators"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.throwing_exceptions_from_annotators">1.5.3.&nbsp;Throwing Exceptions from Annotators</h3></div></div></div>
      
      
      <p>Let's say an invalid regular expression was passed as a parameter to the
        RoomNumberAnnotator. Because this is an error related to the overall
        configuration, and not something we could expect to ignore, we should throw an
        appropriate exception, and most Java programmers would expect to do so like
        this:</p>
      
      
      <pre class="programlisting">throw new ResourceInitializationException(
    "The regular expression " + x + " is not valid.");</pre>
      
      <p>UIMA, however, does not do it this way. All UIMA exceptions are
        <span class="emphasis"><em>internationalized</em></span>, meaning that they support translation
        into other languages. This is accomplished by eliminating hardcoded message
        strings and instead using external message digests. Message digests are files
        containing (key, value) pairs. The key is used in the Java code instead of the actual
        message string. This allows the message string to be easily translated later by
        modifying the message digest file, not the Java code. Also, message strings in the
        digest can contain parameters that are filled in when the exception is thrown. The
        format of the message digest file is described in the Javadocs for the Java class
        <code class="literal">java.util.PropertyResourceBundle</code> and in the load method of
        <code class="literal">java.util.Properties</code>.</p>
      
      <p>The first thing an annotator developer must choose is what Exception class to
        use. There are three to choose from:
        
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>ResourceConfigurationException should be
          thrown from the annotator's reconfigure() method if invalid configuration
          parameter values have been specified. 
          </p></li><li class="listitem"><p>ResourceInitializationException should be thrown from the
            annotator's initialize() method if initialization fails for any 
            reason (including invalid configuration parameters).</p></li><li class="listitem"><p>AnalysisEngineProcessException should be thrown from the
            annotator's process() method if the processing of a particular document
            fails for any reason. </p></li></ol></div>
      
      <p>Generally you will not need to define your own custom exception classes, but if
        you do they must extend one of these three classes, which are the only types of
        Exceptions that the annotator interface permits annotators to throw.</p>
      
      <p>All of the UIMA Exception classes share common constructor varieties. There are
        four possible arguments:</p>
      
      <p>The name of the message digest to use (optional &#8211; if not specified the
        default UIMA message digest is used).</p>
      
      <p>The key string used to select the message in the message digest.</p>
      
      <p>An object array containing the parameters to include in the message. Messages
        can have substitutable parts. When the message is given, the string representation
        of the objects passed are substituted into the message. The object array is often
        created using the syntax new Object[]{x, y}.</p>
      
      <p>Another exception which is the <span class="quote">&#8220;<span class="quote">cause</span>&#8221;</span> of the exception you are
        throwing. This feature is commonly used when you catch another exception and rethrow
        it. (optional)</p>
      
      <p>If you look at source file (folder: src in Eclipse)
        <code class="literal">org.apache.uima.tutorial.ex5.RoomNumberAnnotator</code>, you
        will see the following code:
        
        
        </p><pre class="programlisting">try {
  mPatterns[i] = Pattern.compile(patternStrings[i]);
} 
catch (PatternSyntaxException e) {
  throw new ResourceInitializationException(
     MESSAGE_DIGEST, "regex_syntax_error",
     new Object[]{patternStrings[i]}, e);
}</pre><p>
        where the MESSAGE_DIGEST constant has the value <code class="literal">
        "org.apache.uima.tutorial.ex5.RoomNumberAnnotator_Messages". </code>
        </p>
      
      <p>Message digests are specified using a dotted name, just like Java classes. This
        file, with the .properties extension, must be present in the class path. In Eclipse,
        you find this file under the src folder, in the package
        org.apache.uima.tutorial.ex5, with the name
        RoomNumberAnnotator_Messages.properties. Outside of Eclipse, you can find this
        in the <code class="literal">uimaj-examples.jar</code> with the name
        <code class="literal">org/apache/uima/tutorial/ex5/RoomNumberAnnotator_Messages.properties.</code>
        If you look in this file you will see the line:
        
        
        </p><pre class="programlisting">regex_syntax_error = {0} is not a valid regular expression.</pre><p>
        which is the error message for the example exception we showed above. The placeholder
        {0} will be filled by the toString() value of the argument passed to the exception
        constructor &#8211; in this case, the regular expression pattern that didn't
        compile. If there were additional arguments, their locations in the message would be
        indicated as {1}, {2}, and so on.</p>
      
      <p>If a message digest is not specified in the call to the exception constructor, the
        default is <code class="literal">UIMAException.STANDARD_MESSAGE_CATALOG</code> (whose
        value is <span class="quote">&#8220;<span class="quote"><code class="literal">org.apache.uima.UIMAException_Messages</code>
        </span>&#8221;</span> in the current release but may change). This message digest is located in the
        <code class="literal">uima-core.jar</code> file at
        <code class="literal">org/apache/uima/UIMAException_messages.properties</code>
        &#8211; you can take a look to see if any of these exception messages are useful to
        use.</p>
      
      <p>To try out the regex_syntax_error exception, just use the Document Analyzer to
        run
        <code class="literal">examples/descriptors/tutorial/ex5/RoomNumberAnnotator.xml</code>
        , which happens to have an invalid regular expression in its configuration parameter
        settings.</p>
      
      <p>To summarize, here are the steps to take if you want to define your own exception
        message:</p>
      
      <p>Create a file with the .properties extension, where you declare message keys and
        their associated messages, using the same syntax as shown above for the
        regex_syntax_error exception. The properties file syntax is more completely
        described in the Javadocs for the <a class="ulink" href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Properties.html#load(java.io.InputStream)" target="_top">
        load</a> method of the java.util.Properties class.</p>
      
      <p>Put your properties file somewhere in your class path (it can be in your
        annotator's .jar file).</p>
      
      <p>Define a String constant (called MESSAGE_DIGEST for example) in your annotator
        code whose value is the dotted name of this properties file. For example, if your
        properties file is inside your jar file at the location
        <code class="literal">org/myorg/myannotator/Messages.properties</code>, then this
        String constant should have the value
        <code class="literal">org.myorg.myannotator.Messages</code>. Do not include the
        .properties extension. In Java Internationalization terminology, this is called
        the Resource Bundle name. For more information see the Javadocs for the <a class="ulink" href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/PropertyResourceBundle.html" target="_top">
        PropertyResourceBundle</a> class.</p>
      
      <p>In your annotator code, throw an exception like this:
        
        </p><pre class="programlisting">throw new ResourceInitializationException(
    MESSAGE_DIGEST, "your_message_name",
    new Object[]{param1,param2,...});</pre>
      
      <p>You may also wish to look at the Javadocs for the UIMAException class.</p>
      
      <p>For more information on Java's internationalization features, see the 
       <a class="ulink" href="http://java.sun.com/j2se/1.5.0/docs/guide/intl/index.html" target="_top">
        Java Internationalization Guide</a>.</p>
    </div>
    
    <div class="section" title="1.5.4.&nbsp;Accessing External Resource Files"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.accessing_external_resource_files">1.5.4.&nbsp;Accessing External Resource Files</h3></div></div></div>
      
      
      <p>Sometimes you may want an annotator to read from an external file &#8211; for
        example, a long list of keys and values that you are going to build into a HashMap. You
        could, of course, just introduce a configuration parameter that holds the absolute
        path to this resource file, and build the HashMap in your annotator's
        initialize method. However, this is not the best solution for three reasons:</p>
      
      <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Including an absolute path in your descriptor makes
        your annotator difficult for others to use. Each user will need to edit this
        descriptor and set the absolute path to a value appropriate for his or her
        installation.</p></li><li class="listitem"><p>You cannot share the HashMap between multiple annotators. Also,
          in some deployment scenarios there may be more than one instance of your annotator,
          and you would like to have the option for them to use the same HashMap
          instance.</p></li><li class="listitem"><p>Your annotator would become dependent on a particular data
          representation &#8211; the word list would have to come from a file on the local disk
          and it would have to be in a particular format. It would be better if this were
          decoupled. </p></li></ol></div>
      
      <p>A better way to access external resources is through the ResourceManager
        component. In this section we are going to show an example of how to use the Resource
        Manager.</p>
      
      <p>This example annotator will annotate UIMA acronyms (e.g. UIMA, AE, CAS, JCas)
        and store the acronym's expanded form as a feature of the annotation. The
        acronyms and their expanded forms are stored in an external file.</p>
      
      <p>First, look at the
        <code class="literal">examples/descriptors/tutorial/ex6/UimaAcronymAnnotator.xml</code>
        descriptor.
        
        
        </p><div class="screenshot">
       <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image036.jpg" width="564" alt="Screen shot of Component Descriptor Editor page for configuring External Resources"></td></tr></table></div>

</div>
      
      <p>The values of the rows in the two tables are longer than can be easily shown. You can
        click the small button at the top right to shift the layout from two side-by-side
        tables, to a vertically stacked layout. You can also click the small twisty on the
        <span class="quote">&#8220;<span class="quote">Imports for External Resources and Bindings</span>&#8221;</span> to collapse this
        section, because it's not used here. Then the same screen will appear like this:
        
        
        </p><div class="screenshot">
       <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image038.jpg" width="564" alt="Screen shot of Component Descriptor Editor page for configuring External Resources after adjusting the layout"></td></tr></table></div>
</div><p>
        </p>
      
      <p>The top window has a scroll bar allowing you to see the rest of the line.</p>
      
      <div class="section" title="1.5.4.1.&nbsp;Declaring Resource Dependencies"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.resources.declaring_dependencies">1.5.4.1.&nbsp;Declaring Resource Dependencies</h4></div></div></div>
        
        
        <p>The bottom window is where an annotator declares an external resource
          dependency. The XML for this is as follows:</p>
        
        
        <pre class="programlisting">&lt;externalResourceDependency&gt;
  &lt;key&gt;AcronymTable&lt;/key&gt; 
  &lt;description&gt;Table of acronyms and their expanded forms.&lt;/description&gt; 
  &lt;interfaceName&gt;
    org.apache.uima.tutorial.ex6.StringMapResource
  &lt;/interfaceName&gt; 
&lt;/externalResourceDependency&gt;
</pre>
        
        <p>The &lt;key&gt; value (AcronymTable) is the name by which the annotator
          identifies this resource. The key must be unique for all resources that this
          annotator accesses, but the same key could be used by different annotators to mean
          different things. The interface name
          (<code class="literal">org.apache.uima.tutorial.ex6.StringMapResource</code>) is
          the Java interface through which the annotator accesses the data. Specifying an
          interface name is optional. If you do not specify an interface name, annotators
          will get direct access to the data file.</p>
      </div>
      
      <div class="section" title="1.5.4.2.&nbsp;Accessing the Resource from the UimaContext"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.resources.accessing_from_uimacontext">1.5.4.2.&nbsp;Accessing the Resource from the UimaContext</h4></div></div></div>
        
        
        <p> If you look at the
          <code class="literal">org.apache.uima.tutorial.ex6.UimaAcronymAnnotator</code>
          source, you will see that the annotator accesses this resource from the
          UimaContext by calling:
          
          
          </p><pre class="programlisting">StringMapResource mMap = 
  (StringMapResource)getContext().getResourceObject("AcronymTable");</pre><p>
          </p>
        
        <p>The object returned from the <code class="literal">getResourceObject</code> method
          will implement the interface declared in the
          <code class="literal">&lt;interfaceName&gt;</code> section of the descriptor,
          <code class="literal">StringMapResource</code> in this case. The annotator code does not
          need to know the location of the data nor the Java class that is being used to read the
          data and implement the <code class="literal">StringMapResource</code>
          interface.</p>
        
        <p>Note that if we did not specify a Java interface in our descriptor, our
          annotator could directly access the resource data as follows:
          
          
          </p><pre class="programlisting">InputStream stream = getContext().getResourceAsStream("AcronymTable");</pre>
        
        <p>If necessary, the annotator could also determine the location of the resource
          file, by calling:
          
          
          </p><pre class="programlisting">URI uri = getContext().getResourceURI("AcronymTable");</pre>
        
        <p>These last two options are only available in the case where the descriptor does
          not declare a Java interface.</p>
        
        <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The methods for getting access to resources include <code class="literal">getResourceURL</code>.  That 
        method returns a URL, which may contain spaces encoded as %20.  url.getPath() would
        return the path without decoding these %20 into spaces.  <code class="literal">getResourceURI</code>
        on the other hand, returns a URI, and the uri.getPath() <span class="emphasis"><em>does</em></span>
        do the conversion of %20 into spaces.  See also <code class="literal">getResourceFilePath</code>,
          which does a getResourceURI followed by uri.getPath().</p></div>
        
      </div>
      
      <div class="section" title="1.5.4.3.&nbsp;Declaring Resources and Bindings"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.resources.declaring_and_bindings">1.5.4.3.&nbsp;Declaring Resources and Bindings</h4></div></div></div>
        
        
        <p>Refer back to the top window in the Resources page of the Component Descriptor
          Editor. This is where we specify the location of the resource data, and the Java
          class used to read the data. For the example, this corresponds to the following
          section of the descriptor:
          
          
          </p><pre class="programlisting">&lt;resourceManagerConfiguration&gt;
  &lt;externalResources&gt;
    &lt;externalResource&gt;
      &lt;name&gt;UimaAcronymTableFile&lt;/name&gt; 
      &lt;description&gt;
         A table containing UIMA acronyms and their expanded forms.
      &lt;/description&gt; 
      &lt;fileResourceSpecifier&gt;
        &lt;fileUrl&gt;file:org/apache/uima/tutorial/ex6/uimaAcronyms.txt
        &lt;/fileUrl&gt; 
      &lt;/fileResourceSpecifier&gt;
      &lt;implementationName&gt;
         org.apache.uima.tutorial.ex6.StringMapResource_impl
      &lt;/implementationName&gt; 
    &lt;/externalResource&gt;
  &lt;/externalResources&gt;

  &lt;externalResourceBindings&gt;
    &lt;externalResourceBinding&gt;
      &lt;key&gt;AcronymTable&lt;/key&gt;    
      &lt;resourceName&gt;UimaAcronymTableFile&lt;/resourceName&gt; 
    &lt;/externalResourceBinding&gt;
  &lt;/externalResourceBindings&gt;
&lt;/resourceManagerConfiguration&gt;
</pre>
        
        <p>The first section of this XML declares an externalResource, the
          <code class="literal">UimaAcronymTableFile</code>. With this, the fileUrl element
          specifies the path to the data file. This can be an absolute URL (e.g. one that starts
          with file:/ or file:///, or file://my.host.org/), but that is not recommended
          because it makes installation of your component more difficult, as noted earlier.
          Better is a relative URL, which will be looked up within the classpath (and/or
          datapath), as used in this example. In this case, the file
          <code class="literal">org/apache/uima/tutorial/ex6/uimaAcronyms.txt</code> is
          located in <code class="literal">uimaj-examples.jar</code>, which is in the classpath.
          If you look in this file you will see the definitions of several UIMA
          acronyms.</p>
        
        <p>The second section of the XML declares an externalResourceBinding, which
          connects the key <code class="literal">AcronymTable</code>, declared in the
          annotator's external resource dependency, to the actual resource name
          <code class="literal">UimaAcronymTableFile</code>. This is rather trivial in this case;
          for more on bindings see the example
          <code class="literal">UimaMeetingDetectorAE.xml</code> below. There is no global
          repository for external resources; it is up to the user to define each resource
          needed by a particular set of annotators.</p>
        
        <p>In the Component Descriptor Editor, bindings are indicated below the
          external resource. To create a new binding, you select an external resource (which
          must have previously been defined), and an external resource dependency, and then
          click the <code class="literal">Bind</code> button, which only enables if you have
          selected two things to bind together.</p>
        
        <p>When the Analysis Engine is initialized, it creates a single instance of
          <code class="literal">StringMapResource_impl</code> and loads it with the contents of
          the data file.  This means that the framework calls the instance's <code class="literal">load</code>
          method, passing it an instance of DataResource, from which you can obtain 
          a stream or URI/URL of the external resource that was declared in the external resource; 
          for resources where
          loading does not make sense, you can implement a <code class="literal">load</code> method
          which ignores its argument and just returns.  See the Javadocs for SharedResourceObject for
          details on this. 
          The UimaAcronymAnnotator then accesses the data through the
          <code class="literal">StringMapResource</code> interface. This single instance could
          be shared among multiple annotators, as will be explained later.
          Because of this, you should insure your implementation is thread-safe, as it 
          could be called multiple times on multiple threads.</p>
        
        <p>Note that all resource implementation classes (e.g.
          StringMapResource_impl in the provided example) must be declared public
          must not be declared abstract, and must have public, 0-argument constructors, so 
          that they can be instantiated by the framework. (Although Java classes in which 
          you do not define any constructor will, by default, have a 0-argument constructor
          that doesn't do anything, a class in which you have defined at least one
          constructor does not get a default 0-argument constructor.)</p>
          
        <p>All resource implementation classes that provide access to resource data
          must also implement the interface org.apache.uima.resource.SharedResourceObject. 
          The UIMA Framework
          will invoke this interface's only method, <code class="code">load</code>,  
          after this object has been instantiated. The implementation of this method 
          can then read data from the specified <code class="code">DataResource</code> 
          and use that data to initialize this object.</p>
        
        <p>This annotator is illustrated in <a class="xref" href="#ugr.tug.aae.fig.external_resource_binding" title="Figure&nbsp;1.3.&nbsp;External Resource Binding">Figure&nbsp;1.3, &#8220;External Resource Binding&#8221;</a>. To see it in
          action, just run it using the Document Analyzer. When it finishes, open up the
          UIMA_Seminars document in the processed results window, (double-click it), and
          then left-click on one of the highlighted terms, to see the expandedForm
          feature's value.
          </p><div class="figure"><a name="ugr.tug.aae.fig.external_resource_binding"></a><div class="figure-contents">
            
            <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="366"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image040.png" width="366" alt="External Resource Binding"></td></tr></table></div>
          </div><p class="title"><b>Figure&nbsp;1.3.&nbsp;External Resource Binding</b></p></div><p><br class="figure-break"> </p>
        
        <p>By designing our annotator in this way, we have gained some flexibility. We can
          freely replace the StringMapResource_impl class with any other implementation
          that implements the simple StringMapResource interface. (For example, for very
          large resources we might not be able to have the entire map in memory.) We have also
          made our external resource dependencies explicit in the descriptor, which will
          help others to deploy our annotator.</p>
      </div>
      <div class="section" title="1.5.4.4.&nbsp;Sharing Resources among Annotators"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.resources.sharing_among_annotators">1.5.4.4.&nbsp;Sharing Resources among Annotators</h4></div></div></div>
        
        
        <p>Another advantage of the Resource Manager is that it allows our data to be
          shared between annotators. To demonstrate this we have developed another
          annotator that will use the same acronym table. The UimaMeetingAnnotator will
          iterate over Meeting annotations discovered by the Meeting Detector we
          previously developed and attempt to determine whether the topic of the meeting is
          related to UIMA. It will do this by looking for occurrences of UIMA acronyms in close
          proximity to the meeting annotation. We could implement this by using the
          UimaAcronymAnnotator, of course, but for the sake of this example we will have the
          UimaMeetingAnnotator access the acronym map directly.</p>
        
        <p>The Java code for the UimaMeetingAnnotator in example 6 creates a new type,
          UimaMeeting, if it finds a meeting within 50 characters of the UIMA
          acronym.</p>
        
        <p>We combine three analysis engines, the UimaAcronymAnnotator to annotate
          UIMA acronyms, the MeetingDectector from example 4 to find meetings and finally
          the UimaMeetingAnnotator to annotate just meetings about UIMA. Together these
          are assembled to form the new aggregate analysis engine, UimaMeetingDectector.
          This aggregate and the sharing of a common resource are illustrated in <a class="xref" href="#ugr.tug.aae.fig.sharing_common_resource" title="Figure&nbsp;1.4.&nbsp;Component engines of an aggregate share a common resource">Figure&nbsp;1.4, &#8220;Component engines of an aggregate share a common resource&#8221;</a>.
          </p><div class="figure"><a name="ugr.tug.aae.fig.sharing_common_resource"></a><div class="figure-contents">
            
            <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image042.png" width="564" alt="Picture of Component engines of an aggregate sharing a common resource"></td></tr></table></div>
          </div><p class="title"><b>Figure&nbsp;1.4.&nbsp;Component engines of an aggregate share a common resource</b></p></div><p><br class="figure-break"> The important thing to notice is in the
          <code class="literal">UimaMeetingDetectorAE.xml</code> aggregate descriptor. It
          includes both the UimaMeetingAnnotator and the UimaAcronymAnnotator, and
          contains a single declaration of the UimaAcronymTableFile resource. (The actual
          example has the order of the first two annotators reversed versus the above
          picture, which is OK since they do not depend on one another).</p>
        
        <p>It also binds the resources as follows:
          
          
          </p><div class="screenshot">
     <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image044.jpg" width="564" alt="UimaMeetingDetectorAE.xml binding a common resource"></td></tr></table></div>
  </div><p>
          
          
          </p><pre class="programlisting">&lt;externalResourceBindings&gt;
  &lt;externalResourceBinding&gt;
    &lt;key&gt;UimaAcronymAnnotator/AcronymTable&lt;/key&gt; 
    &lt;resourceName&gt;UimaAcronymTableFile&lt;/resourceName&gt; 
  &lt;/externalResourceBinding&gt;

  &lt;externalResourceBinding&gt;
    &lt;key&gt;UimaMeetingAnnotator/UimaTermTable&lt;/key&gt; 
    &lt;resourceName&gt;UimaAcronymTableFile&lt;/resourceName&gt; 
  &lt;/externalResourceBinding&gt;
&lt;/externalResourceBindings&gt;
</pre><p>
          </p>
        
        <p>This binds the resource dependencies of both the UimaAcronymAnnotator
          (which uses the name AcronymTable) and UimaMeetingAnnotator (which uses
          UimaTermTable) to the single declared resource named UimaAcronymFile.
          Therefore they will share the same instance. Resource bindings in the aggregate
          descriptor <span class="bold-italic">override</span> any resource
          declarations in individual annotator descriptors.</p>
        
        <p>If we wanted to have the annotators use different acronym tables, we could
          easily do that. We would simply have to change the resourceName elements in the
          bindings so that they referred to two different resources. The Resource Manager
          gives us the flexibility to make this decision at deployment time, without
          changing any Java code.</p>
        
      </div>
      
      <div class="section" title="1.5.4.5.&nbsp;Threading and Shared Resources"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.resources.threading">1.5.4.5.&nbsp;Threading and Shared Resources</h4></div></div></div>
        
        <p>Sharing can also occur when multiple instances of an annotator are 
        created by the framework in response to run-time deployment specifications.
        If an implementation class is specified in the external resource, 
        only one instance of that implementation class  
          is created for a given binding, and is shared among all
        annotators.  Because of this, the implementation of that shared instance must be written to be
        thread-safe - that is, to operate correctly when called at arbitrary times
        by multiple threads.  Writing thread-safe code in Java is addressed in several
        books, such as Brian Goetz's <span class="emphasis"><em>Java Concurrency in Practice</em></span>.</p>
        
        <p>
          If no implementation class is specified, then the getResource method returns a
          DataResource object, from which each annotator instance can obtain their
          own (non-shared) input stream; so threading is not an issue in this case.
        </p>
        
      </div>
    </div>
    <div class="section" title="1.5.5.&nbsp;Result Specifications"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.result_specification_setting">1.5.5.&nbsp;Result Specifications</h3></div></div></div>
      
      
      <p>The Result Specification is passed to the annotator instance by calling its
        setResultSpecificaiton method. When called, the default implementation saves the
        result specification in an instance variable of the Annotator instance, which can be
        accessed by the annotator using the protected
        <code class="literal">getResultSpecification()</code> method.</p>
      
      <p>A Result Specification is a list of output types and / or type:feature
        names, catagorized by language(s), which are expected to be output from (produced by) the
        annotator. Annotators may use this to optimize their operations, when possible, for
        those cases where only particular outputs are wanted. The interface to the Result
        Specification object (see the Javadocs) allows querying both types and particular
        features of types.</p>
      
      <p>The languages specifications used by Result Specifications are the same that are
      specifiable in Capability Specifications; examples include "en" for English, "en-uk" for
      British English, etc.  There is also a language type, "x-unspecified", which is presumed
      if no language specification(s) are given.</p>
      
      <p>Result Specifications can be queryed by the Annotator code, and the query may 
      include the language.  If it doesn't include the language, it is treated as if the 
      language "x-unspecified" was specified.  Language matching is hierarchically defaulted,
      in one direction: if a query asks about a type T for language "en-uk", it will match
        for languages "en-uk", "en", or "x-unspecified".  However the reverse is not true:
        If the query asks about a type T for language "x-unspecified", then it only 
        matches Result Specifications with no language (or "x-unspecified", which is equivalent).
        </p>
      
      <p>
      The effect of this is that if the Result Specification indicates it wants output
      produced for "en-uk", but the annotator is given a language which is unknown, 
        or one that is known, but isn't "en-uk", then the query (using the language 
        of the document) will 
      return false.   This is true even if the language is "en".  
        However, if the Result Specification indicates it wants output for "en", 
      and the query is for "en-uk" (presumably because that's the language of the document
      and the annotator can handle that especially well), then the query will return true.
    </p> 
      
      
      <p>Sometimes you can specify the Result Specification; othertimes, you cannot
        (for instance, inside a Collection Processing Engine, you cannot). When you cannot
        specify it, or choose not to specify it (for example, using the form of the
        process(...) call on an Analysis Engine that doesn't include the Result
        Specification), a <span class="quote">&#8220;<span class="quote">Default</span>&#8221;</span> Result Specification is used.</p>
          
      <div class="section" title="1.5.5.1.&nbsp;Default ResultSpecification"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.result_spec.default">1.5.5.1.&nbsp;Default ResultSpecification</h4></div></div></div>
        
        
        <p>The default Result Specification is taken from the Engine's output
          Capability Specification. Remember that a Capability Specification has both
          inputs and outputs, can specify types and / or features, and there can be more than one
          Capability Set. If there is more than one set, the logical union by language of these sets is used.
          Each set can have a different "language(s)" specified; the default Result Specification 
          will have the outputs by language(s), so that the annotator can query which outputs 
          should be provided for particular languages.  The methods to query the Result Specification
          take a type and (optionally) a feature, and optionally, a language.  If the queried type is
          a subtype of some otherwise matching type in the Result Specification, it will match the query.  
          See the Javadocs for more details on this.
          </p>
        
      </div>
      
      <div class="section" title="1.5.5.2.&nbsp;Passing Result Specifications to Annotators"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.result_spec.passing_to_annotators">1.5.5.2.&nbsp;Passing Result Specifications to Annotators</h4></div></div></div>
        
        
        <p>If you are not using a Collection Processing Engine, you can specify a Result
          Specification for your AnalysisEngine(s) by calling the
          <code class="literal">AnalysisEngine.setResultSpecification(ResultSpecification)</code>
          method.</p>
        <p>It is also possible to pass a Result Specification on each call to
          <code class="literal">AnalysisEngine.process(CAS, ResultSpecification)</code>. However,
          this is not recommended if your Result Specification will stay constant across
          multiple calls to
          <code class="literal">process</code>. In that case it will be more efficient to call
          <code class="literal">AnalysisEngine.setResultSpecification(ResultSpecification)</code>
          only when the Result Specification changes.</p>
        <p> For primitive Analysis Engines, whatever Result Specification you pass in is
          passed along to the annotator's
          <code class="literal">setResultSpecification(ResultSpecification)</code> method. For
          aggregate Analysis Engines, see below.</p>
      </div>
      
      <div class="section" title="1.5.5.3.&nbsp;Aggregates"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.result_spec.aggregates">1.5.5.3.&nbsp;Aggregates</h4></div></div></div>
        
        
        <p>For aggregate engines, the Result Specification passed to the
          <code class="code">AnalysisEngine.setResultSpecification(ResultSpecification)</code>
          method is intended to specify the set of output types/features that the aggregate
          should produce. This is not necessarily equivalent to the set of output
          types/features that each annotator should produce. For example, an annotator may
          need to produce an intermediate type that is then consumed by a downstream annotator,
          even though that intermediate type is not part of the Result Specification.</p>
        <p>To handle this situation, when
          <code class="code">AnalysisEngine.setResultSpecification(ResultSpecification)</code>
          is called on an aggregate, the framework computes the union of the passed Result
          Specification with the set of
          <span class="emphasis"><em>all</em></span> input types and features of
          <span class="emphasis"><em>all</em></span> component AnalysisEngines within that aggregate. This forms the
          complete set of types and features that any component of the aggregate might need to
          produce. This derived Result Specification is then passed to the
          <code class="code">AnalysisEngine.setResultSpecification(ResultSpecification)</code>
          of each component AnalysisEngine. In the case of nested aggregates, this procedure
          is applied recursively.</p>
      </div>  
      <div class="section" title="1.5.5.4.&nbsp;Collection Proessing Engines"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.result_spec.aggregates.cpes">1.5.5.4.&nbsp;Collection Proessing Engines</h4></div></div></div>
        
          
        <p>The Default Result Specification is always used for all components of a
          Collection Processing Engine.</p>        
      </div>
    </div>
    
    <div class="section" title="1.5.6.&nbsp;Class path setup when using JCas"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.classpath_when_using_jcas">1.5.6.&nbsp;Class path setup when using JCas</h3></div></div></div>
      
      
      <p>JCas provides Java classes that correspond to each CAS type in an application.
        These classes are generated by the JCasGen utility (which can be automatically
        invoked from the Component Descriptor Editor).</p>
      
      <p>The Java source classes generated by the JCasGen utility are typically compiled
        and packaged into a JAR file. This JAR file must be present in the classpath of the UIMA
        application.</p>
      
      <p>For more details on issues around setting up this class path, including
        deployment issues where class loaders are being used to isolate multiple UIMA
        applications inside a single running Java Virtual Machine, please see <a href="references.html#ugr.ref.jcas.class_loaders" class="olink">Section&nbsp;5.6.6, &#8220;Class Loaders in UIMA&#8221;</a>
        .</p>
      
    </div>
    <div class="section" title="1.5.7.&nbsp;Using the Shell Scripts"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.using_shell_scripts">1.5.7.&nbsp;Using the Shell Scripts</h3></div></div></div>
      
      
      <p>The SDK includes a <code class="literal">/bin</code> subdirectory containing shell
        scripts, for Windows (.bat files) and Unix (.sh files). Many of these scripts invoke
        sample Java programs which require a class path; they call a common shell script,
        <code class="literal">setUimaClassPath</code> to set up the UIMA required files and
        directories on the class path.</p>
      
      <p>If you need to include files on the class path, the scripts will add anything you
        specify in the environment variables CLASSPATH or UIMA_CLASSPATH to the classpath. So, for
        example, if you are running the document analyzer, and wanted it to find a Java class
        file named (on Windows) c:\a\b\c\myProject\myJarFile.jar, you could first issue a
        <code class="literal">set</code> command to set the UIMA_CLASSPATH to this file, followed by
        the documentAnalyzer script:
        
        
        </p><pre class="programlisting">set UIMA_CLASSPATH=c:\a\b\c\myProject\myJarFile.jar
documentAnalyzer</pre><p>
      </p>
      
      <p>Other environment variables are used by the shell scripts, as follows:
        
        </p><div class="table"><a name="ugr.aae.tbl.env_vars_used_by_shell_scripts"></a><p class="title"><b>Table&nbsp;1.1.&nbsp;Environment variables used by the shell scripts</b></p><div class="table-contents">
          
          <table summary="Environment variables used by the shell scripts" style="border-collapse: collapse;border-top: 0.5pt solid black; border-bottom: 0.5pt solid black; border-left: 0.5pt solid black; border-right: 0.5pt solid black; "><colgroup><col><col></colgroup><thead><tr><th style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; " align="center">Environment Variable</th><th style="border-bottom: 0.5pt solid black; " align="center">Description</th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">UIMA_HOME</td><td style="border-bottom: 0.5pt solid black; ">Path where the UIMA SDK was installed.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">JAVA_HOME</td><td style="border-bottom: 0.5pt solid black; ">(Optional) Path to a Java Runtime Environment. If not set, the Java
                  JRE that is in your system PATH is used.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">UIMA_CLASSPATH</td><td style="border-bottom: 0.5pt solid black; ">(Optional) if specified, a path specification to use as the default
                  ClassPath.  You can also set the CLASSPATH variable.  If you set both, they
                  will be concatenated.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">UIMA_DATAPATH</td><td style="border-bottom: 0.5pt solid black; ">(Optional) if specified, a path specification to use as the default
                  DataPath (see <a href="references.html#ugr.ref.xml.component_descriptor.datapath" class="olink">Section&nbsp;2.2, &#8220;Imports&#8221;</a>)</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">UIMA_LOGGER_CONFIG_FILE</td><td style="border-bottom: 0.5pt solid black; ">(Optional) if specified, a path to a Java Logger properties file
                  (see <a class="xref" href="#ugr.tug.aae.configuration_logging" title="1.2.&nbsp;Configuration and Logging">Section&nbsp;1.2, &#8220;Configuration and Logging&#8221;</a>)</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">UIMA_JVM_OPTS</td><td style="border-bottom: 0.5pt solid black; ">(Optional) if specified, the JVM arguments to be used when the Java
                  process is started.  This can be used for example to set the maximum Java
                  heap size or to define system properties.</td></tr><tr><td style="border-right: 0.5pt solid black; border-bottom: 0.5pt solid black; ">VNS_PORT</td><td style="border-bottom: 0.5pt solid black; ">(Optional) if specified, the network IP port number of the Vinci
                  Name Server (VNS) (see <a href="tutorials_and_users_guides.html#ugr.tug.application.vns" class="olink">Section&nbsp;3.6.5, &#8220;The Vinci Naming Services (VNS)&#8221;</a>)</td></tr><tr><td style="border-right: 0.5pt solid black; ">ECLIPSE_HOME</td><td style="">(Optional) Needs to be set to the root of your Eclipse installation
                  when using shell scripts that invoke Eclipse (e.g.
                  jcasgen_merge)</td></tr></tbody></table>
          
        </div></div><p><br class="table-break"> </p>
      
    </div>
  </div>
  
  <div class="section" title="1.6.&nbsp;Common Pitfalls"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.aae.common_pitfalls">1.6.&nbsp;Common Pitfalls</h2></div></div></div>
    
    
    <p>Here are some things to avoid doing in your annotator code:</p>
    
    <p><span class="bold"><strong>Retaining references to JCas objects between calls to
      process()</strong></span></p>
    
    <p>The JCas will be cleared between calls to your annotator's process() method.
      All of the analysis results related to the previous document will be deleted to make way
      for analysis of a new document. Therefore, you should never save a reference to a JCas
      Feature Structure object (i.e. an instance of a class created using JCasGen) and
      attempt to reuse it in a future invocation of the process() method. If you do so, the
      results will be undefined.</p>
    
    <p><span class="bold"><strong>Careless use of static data</strong></span></p>
    
    <p>Always keep in mind that an application that uses your annotator may create
      multiple instances of your annotator class. A multithreaded application may attempt
      to use two instances of your annotator to process two different documents
      simultaneously. This will generally not cause any problems as long as your annotator
      instances do not share static data.</p>
    
    <p>In general, you should not use static variables other than static final constants
      of primitive data types (String, int, float, etc). Other types of static variables may
      allow one annotator instance to set a value that affects another annotator instance,
      which can lead to unexpected effects. Also, static references to classes that
      aren't thread-safe are likely to cause errors in multithreaded
      applications.</p>
    
  </div>
  <div class="section" title="1.7.&nbsp;Viewing UIMA objects in the Eclipse debugger"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.aae.viewing_UIMA_objects_in_eclipse_debugger">1.7.&nbsp;Viewing UIMA objects in the Eclipse debugger</h2></div></div></div>
    
    
    
    <p>Eclipse (as of version 3.1 or later) has a new feature for viewing Java Logical
      Structures. When enabled, it will permit you to see a view of UIMA objects (such as
      feature structure instances, CAS or JCas instances, etc.) which displays the logical
      subparts. For example, here is a view of a feature structure for the RoomNumber
      annotation, from the tutorial example 1:
      
      
      </p><div class="screenshot">
     <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image046.jpg" width="564" alt="Screenshot of Eclipse debugger showing non-logical-structure display of a feature structure"></td></tr></table></div>
  </div>
    
    <p>The <span class="quote">&#8220;<span class="quote">annotation</span>&#8221;</span> object in Java shows as a 2 element object, not very
      convenient for seeing the features or the part of the input that is being annotatoed. But
      if you turn on the Java Logical Structure mode by pushing this button:
      
      
      </p><div class="screenshot">
     <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="554"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image048.jpg" width="554" alt="Screenshot of Eclipse debugger showing button to push to enable viewing logical structures"></td></tr></table></div>
  </div><p>
      the features of the FeatureStructure instance will be shown:
      
      
      </p><div class="screenshot">
     <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.aae/image050.jpg" width="564" alt="Screenshot of Eclipse debugger showing logical structure display of an annotation"></td></tr></table></div>
  </div>
    
  </div>
  
  <div class="section" title="1.8.&nbsp;Introduction to Analysis Engine Descriptor XML Syntax"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.aae.xml_intro_ae_descriptor">1.8.&nbsp;Introduction to Analysis Engine Descriptor XML Syntax</h2></div></div></div>
    
    
    
    <p>This section is an introduction to the syntax used for Analysis Engine
      Descriptors. Most users do not need to understand these details; they can use the
      Component Descriptor Editor Eclipse plugin to edit Analysis Engine Descriptors
      rather than editing the XML directly.</p>
    
    <p>This section walks through the actual XML descriptor for the RoomNumberAnnotator
      example introduced in section <a class="xref" href="#ugr.tug.aae.getting_started" title="1.1.&nbsp;Getting Started">Section&nbsp;1.1, &#8220;Getting Started&#8221;</a>. The
      discussion is divided into several logical sections of the descriptor.</p>
    
    <p>The full specification for Analysis Engine Descriptors is defined in <a href="references.html#ugr.ref.xml.component_descriptor" class="olink">Chapter&nbsp;2, <i>Component Descriptor Reference</i></a>
      .</p>
    
    <div class="section" title="1.8.1.&nbsp;Header and Annotator Class Identification"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.header_annotator_class_identification">1.8.1.&nbsp;Header and Annotator Class Identification</h3></div></div></div>
      
      
      
      <pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" ?&gt; 
&lt;!--  Descriptor for the example RoomNumberAnnotator. --&gt; 
&lt;analysisEngineDescription xmlns="http://uima.apache.org/resourceSpecifier"&gt;
  &lt;frameworkImplementation&gt;org.apache.uima.java&lt;/frameworkImplementation&gt; 
  &lt;primitive&gt;true&lt;/primitive&gt; 
  &lt;annotatorImplementationName&gt;
    org.apache.uima.tutorial.ex1.RoomNumberAnnotator
  &lt;/annotatorImplementationName&gt;
</pre>
      
      <p>The document begins with a standard XML header and a comment. The root element of
        the document is named <code class="literal">&lt;analysisEngineDescription&gt;,</code>
        and must specify the XML namespace
        <code class="literal">http://uima.apache.org/resourceSpecifier</code>.</p>
      
      <p>The first subelement,
        <code class="literal">&lt;frameworkImplementation&gt;</code>, must contain the value
        <code class="literal">org.apache.uima.java</code>. The second subelement,
        <code class="literal">&lt;primitive&gt;</code>, contains the Boolean value true,
        indicating that this XML document describes a <span class="emphasis"><em>Primitive</em></span>
        Analysis Engine. A Primitive Analysis Engine is comprised of a single annotator. It
        is also possible to construct XML descriptors for non-primitive or
        <span class="emphasis"><em>Aggregate</em></span> Analysis Engines; this is covered later.</p>
      
      <p>The next element,
        <code class="literal">&lt;annotatorImplementationName&gt;</code>, contains the
        fully-qualified class name of our annotator class. This is how the UIMA framework
        determines which annotator class to instantiate.</p>
    </div>
    
    <div class="section" title="1.8.2.&nbsp;Simple Metadata Attributes"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.xml_intro_simple_metadata_attributes">1.8.2.&nbsp;Simple Metadata Attributes</h3></div></div></div>
      
      
      
      <pre class="programlisting">&lt;analysisEngineMetaData&gt;
  &lt;name&gt;Room Number Annotator&lt;/name&gt; 
  &lt;description&gt;An example annotator that searches for room numbers in
     the IBM Watson research buildings.&lt;/description&gt; 
  &lt;version&gt;1.0&lt;/version&gt; 
  &lt;vendor&gt;The Apache Software Foundation&lt;/vendor&gt;&lt;/para&gt;
</pre>
      
      <p>Here are shown four simple metadata fields &#8211; name, description, version,
        and vendor. Providing values for these fields is optional, but recommended.</p>
      
    </div>
    
    <div class="section" title="1.8.3.&nbsp;Type System Definition"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.xml_intro_type_system_definition">1.8.3.&nbsp;Type System Definition</h3></div></div></div>
      
      
      
      <pre class="programlisting">&lt;typeSystemDescription&gt;
  &lt;imports&gt;
    &lt;import location="TutorialTypeSystem.xml"/&gt;
  &lt;/imports&gt;
&lt;/typeSystemDescription&gt;
</pre>
      
      <p>This section of the XML descriptor defines which types the annotator works with.
        The recommended way to do this is to <span class="emphasis"><em>import</em></span> the type system
        definition from a separate file, as shown here. The location specified here should be
        a relative path, and it will be resolved relative to the location of the aggregate
        descriptor. It is also possible to define types directly in the Analysis Engine
        descriptor, but these types will not be easily shareable by others.</p>
      
    </div>
    
    <div class="section" title="1.8.4.&nbsp;Capabilities"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.xml_intro_capabilities">1.8.4.&nbsp;Capabilities</h3></div></div></div>
      
      
      
      <pre class="programlisting">&lt;capabilities&gt;
  &lt;capability&gt;
    &lt;inputs /&gt; 
    &lt;outputs&gt;
      &lt;type&gt;org.apache.uima.tutorial.RoomNumber&lt;/type&gt; 
      &lt;feature&gt;org.apache.uima.tutorial.RoomNumber:building&lt;/feature&gt; 
    &lt;/outputs&gt;
  &lt;/capability&gt;
&lt;/capabilities&gt;
</pre>
      
      <p>The last section of the descriptor describes the
        <span class="emphasis"><em>Capabilities</em></span> of the annotator &#8211; the Types/Features
        it consumes (input) and the Types/Features that it produces (output). These must be
        the names of types and features that exist in the ANALYSIS ENGINE descriptor's
        type system definition.</p>
      
      <p>Our annotator outputs only one Type, RoomNumber and one feature,
        RoomNumber:building. The fully-qualified names (including namespace) are
        needed.</p>
      
      <p>The building feature is listed separately here, but clearly specifying every
        feature for a complex type would be cumbersome. Therefore, a shortcut syntax exists.
        The &lt;outputs&gt; section above could be replaced with the equivalent section:
        
        
        </p><pre class="programlisting">&lt;outputs&gt;
  &lt;type allAnnotatorFeatures ="true"&gt;
     org.apache.uima.tutorial.RoomNumber
  &lt;/type&gt; 
&lt;/outputs&gt;</pre>
      
    </div>
    
    <div class="section" title="1.8.5.&nbsp;Configuration Parameters (Optional)"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aae.xml_intro.configuration_parameters">1.8.5.&nbsp;Configuration Parameters (Optional)</h3></div></div></div>
      
      
      <div class="section" title="1.8.5.1.&nbsp;Configuration Parameter Declarations"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.xml_intro.configuration_parameters_declarations">1.8.5.1.&nbsp;Configuration Parameter Declarations</h4></div></div></div>
        
        
        
        <pre class="programlisting">&lt;configurationParameters&gt;
  &lt;configurationParameter&gt;
    &lt;name&gt;Patterns&lt;/name&gt; 
    &lt;description&gt;List of room number regular expression patterns.
    &lt;/description&gt; 
    &lt;type&gt;String&lt;/type&gt; 
    &lt;multiValued&gt;true&lt;/multiValued&gt; 
    &lt;mandatory&gt;true&lt;/mandatory&gt; 
  &lt;/configurationParameter&gt;
  &lt;configurationParameter&gt;
    &lt;name&gt;Locations&lt;/name&gt; 
    &lt;description&gt;List of locations corresponding to the room number
       expressions specified by the Patterns parameter.
    &lt;/description&gt; 
    &lt;type&gt;String&lt;/type&gt; 
    &lt;multiValued&gt;true&lt;/multiValued&gt; 
    &lt;mandatory&gt;true&lt;/mandatory&gt; 
  &lt;/configurationParameter&gt;
&lt;/configurationParameters&gt;</pre>
        
        <p>The <code class="literal">&lt;configurationParameters&gt;</code> element
          contains the definitions of the configuration parameters that our annotator
          accepts. We have declared two parameters. For each configuration parameter, the
          following are specified:
          
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="bold"><strong>name</strong></span>
            &#8211; the name that the annotator code uses to refer to the parameter</p>
            </li><li class="listitem"><p><span class="bold"><strong>description</strong></span>
              &#8211; a natural language description of the intent of the parameter</p>
            </li><li class="listitem"><p><span class="bold"><strong>type</strong></span> &#8211; the data
              type of the parameter's value &#8211; must be one of String, Integer,
              Float, or Boolean.</p></li><li class="listitem"><p><span class="bold"><strong>multiValued</strong></span>
              &#8211; true if the parameter can take multiple-values (an array), false if
              the parameter takes only a single value. </p></li><li class="listitem"><p><span class="bold"><strong>mandatory</strong></span> &#8211; true
              if a value must be provided for the parameter </p></li></ul></div>
        
        <p>Both of our parameters are mandatory and accept an array of Strings as their
          value.</p>
      </div>
      
      <div class="section" title="1.8.5.2.&nbsp;Configuration Parameter Settings"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.xml_intro_configuration_parameter_settings">1.8.5.2.&nbsp;Configuration Parameter Settings</h4></div></div></div>
        
        
        
        <pre class="programlisting">&lt;configurationParameterSettings&gt;
  &lt;nameValuePair&gt;
    &lt;name&gt;Patterns&lt;/name&gt; 
    &lt;value&gt;
      &lt;array&gt;
        &lt;string&gt;b[0-4]d-[0-2]ddb&lt;/string&gt; 
        &lt;string&gt;b[G1-4][NS]-[A-Z]ddb&lt;/string&gt; 
        &lt;string&gt;bJ[12]-[A-Z]ddb&lt;/string&gt; 
      &lt;/array&gt;
    &lt;/value&gt;
  &lt;/nameValuePair&gt;
  &lt;nameValuePair&gt;
    &lt;name&gt;Locations&lt;/name&gt; 
    &lt;value&gt;
      &lt;array&gt;
        &lt;string&gt;Watson - Yorktown&lt;/string&gt; 
        &lt;string&gt;Watson - Hawthorne I&lt;/string&gt; 
        &lt;string&gt;Watson - Hawthorne II&lt;/string&gt; 
      &lt;/array&gt;
    &lt;/value&gt;
  &lt;/nameValuePair&gt;
&lt;/configurationParameterSettings&gt;</pre>
        
      </div>
      
      <div class="section" title="1.8.5.3.&nbsp;Aggregate Analysis Engine Descriptor"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.aae.xml_intro.aggregate">1.8.5.3.&nbsp;Aggregate Analysis Engine Descriptor</h4></div></div></div>
        
        
        
        <pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" ?&gt; 
&lt;analysisEngineDescription xmlns="http://uima.apache.org/resourceSpecifier"&gt;
  &lt;frameworkImplementation&gt;org.apache.uima.java&lt;/frameworkImplementation&gt; 
  &lt;primitive&gt;false&lt;/primitive&gt; 

  &lt;delegateAnalysisEngineSpecifiers&gt;
    &lt;delegateAnalysisEngine key="RoomNumber"&gt;
      &lt;import location="../ex2/RoomNumberAnnotator.xml"/&gt; 
    &lt;/delegateAnalysisEngine&gt;
    &lt;delegateAnalysisEngine key="DateTime"&gt;
      &lt;import location="TutorialDateTime.xml" /&gt; 
    &lt;/delegateAnalysisEngine&gt;
  &lt;/delegateAnalysisEngineSpecifiers&gt;</pre>
        
        <p>The first difference between this descriptor and an individual
          annotator's descriptor is that the
          <code class="literal">&lt;primitive&gt;</code> element contains the value
          <code class="literal">false</code>. This indicates that this Analysis Engine (AE) is an
          aggregate AE rather than a primitive AE.</p>
        
        <p>Then, instead of a single annotator class name, we have a list of
          <code class="literal">delegateAnalysisEngineSpecifiers</code>. Each specifies one of
          the components that constitute our Aggregate . We refer to each component by the
          relative path from this XML descriptor to the component AE's XML
          descriptor.</p>
        
        <p>This list of component AEs does not imply an ordering of them in the execution
          pipeline. Ordering is done by another section of the descriptor:
          
          
          </p><pre class="programlisting">&lt;analysisEngineMetaData&gt;
  &lt;name&gt;Aggregate AE - Room Number and DateTime Annotators&lt;/name&gt; 
  &lt;description&gt;Detects Room Numbers, Dates, and Times&lt;/description&gt; 
  &lt;flowConstraints&gt;
    &lt;fixedFlow&gt;
      &lt;node&gt;RoomNumber&lt;/node&gt; 
      &lt;node&gt;DateTime&lt;/node&gt; 
    &lt;/fixedFlow&gt;
  &lt;/flowConstraints&gt;</pre>
        
        <p>Here, a fixedFlow is adequate, and we specify the exact ordering in which the
          AEs will be executed. In this case, it doesn't really matter, since the
          RoomNumber and DateTime annotators do not have any dependencies on one
          another.</p>
        
        <p>Finally, the descriptor has a capabilities section, which has exactly the
          same syntax as a primitive AE's capabilities section:
          
          
          </p><pre class="programlisting">&lt;capabilities&gt;
  &lt;capability&gt;
    &lt;inputs /&gt; 
    &lt;outputs&gt;
      &lt;type allAnnotatorFeatures="true"&gt;
        org.apache.uima.tutorial.RoomNumber
      &lt;/type&gt; 
      &lt;type allAnnotatorFeatures="true"&gt;
        org.apache.uima.tutorial.DateAnnot
      &lt;/type&gt; 
      &lt;type allAnnotatorFeatures="true"&gt;
        org.apache.uima.tutorial.TimeAnnot
      &lt;/type&gt; 
    &lt;/outputs&gt;
    &lt;languagesSupported&gt;
      &lt;language&gt;en&lt;/language&gt; 
    &lt;/languagesSupported&gt;
  &lt;/capability&gt;
&lt;/capabilities&gt;</pre><p>
          </p>
        
      </div>
      
    </div>
  </div>
<div class="footnotes"><br><hr width="100" align="left"><div class="footnote">
        <p><sup>[<a name="ftn.d4e215" href="#d4e215" class="para">1</a>] </sup>Note that AnalysisComponent is not specific to JCAS. There is a method getRequiredCasInterface()
          which the user would have to implement to return <code class="literal">JCas.class</code>. Then in the
          <code class="literal">process(AbstractCas cas)</code> method, they would need to typecast
          <code class="literal">cas</code> to type <code class="literal">JCas</code>.</p></div><div class="footnote">
        <p><sup>[<a name="ftn.d4e222" href="#d4e222" class="para">2</a>] </sup> Although Java classes in which you do not define any constructor will, by default, have a 0-argument
          constructor that doesn't do anything, a class in which you have defined at least one constructor does
          not get a default 0-argument constructor.</p> </div><div class="footnote">
        <p><sup>[<a name="ftn.d4e236" href="#d4e236" class="para">3</a>] </sup>Version 1 of UIMA specified an additional parameter, the ResultSpecification. This provides a
          specification of which types and features are desired to be computed and "output" from this annotator. Its
          use is optional; many annotators ignore it.</p>
        <p> This parameter has been replaced by specific set/getResultSpecification() methods, which allow
          the annotator to receive a signal (a method call) when the result specification changes.</p>
        </div></div></div>
  <div class="chapter" title="Chapter&nbsp;2.&nbsp;Collection Processing Engine Developer's Guide" id="ugr.tug.cpe"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;2.&nbsp;Collection Processing Engine Developer's Guide</h2></div></div></div>
  
  
  
  <p>The UIMA Analysis Engine interface provides support for developing and integrating
    algorithms that analyze unstructured data. Analysis Engines are designed to operate on a
    per-document basis. Their interface handles one CAS at a time. UIMA provides additional
    support for applying analysis engines to collections of unstructured data with its
    <span class="emphasis"><em>Collection Processing Architecture</em></span>. The Collection
    Processing Architecture defines additional components for reading raw data formats
    from data collections, preparing the data for processing by Analysis Engines, executing
    the analysis, extracting analysis results, and deploying the overall flow in a variety of
    local and distributed configurations.</p>
  
  <p>The functionality defined in the Collection Processing Architecture is
    implemented by a <span class="emphasis"><em>Collection Processing Engine</em></span> (CPE). A CPE
    includes an Analysis Engine and adds a <span class="emphasis"><em>Collection Reader</em></span>, a
    <span class="emphasis"><em>CAS Initializer</em></span> (deprecated as of version 2), and <span class="emphasis"><em>CAS
    Consumers</em></span>. The part of the UIMA Framework that supports the execution of
    CPEs is called the Collection Processing Manager, or CPM.</p>
  
  <p>A Collection Reader provides the interface to the raw input data and knows how to
    iterate over the data collection. Collection Readers are discussed in <a class="xref" href="#ugr.tug.cpe.collection_reader.developing" title="2.4.1.&nbsp;Developing Collection Readers">Section&nbsp;2.4.1, &#8220;Developing Collection Readers&#8221;</a>. The CAS Initializer
    <sup>[<a name="d4e1088" href="#ftn.d4e1088" class="footnote">4</a>]</sup> prepares an individual data item for
    analysis and loads it into the CAS. CAS Initializers are discussed in <a class="xref" href="#ugr.tug.cpe.cas_initializer.developing" title="2.4.2.&nbsp;Developing CAS Initializers">Section&nbsp;2.4.2, &#8220;Developing CAS
      Initializers&#8221;</a> A CAS Consumer extracts
    analysis results from the CAS and may also perform <span class="emphasis"><em>collection level
    processing</em></span>, or analysis over a collection of CASes. CAS Consumers are
    discussed in <a class="xref" href="#ugr.tug.cpe.cas_consumer.developing" title="2.4.3.&nbsp;Developing CAS Consumers">Section&nbsp;2.4.3, &#8220;Developing CAS
      Consumers&#8221;</a>.</p>
  
  <p>Analysis Engines and CAS Consumers are both instances of <span class="emphasis"><em>CAS
    Processors</em></span>. A Collection Processing Engine (CPE) may contain multiple CAS
    Processors. An Analysis Engine contained in a CPE may itself be a Primitive or an Aggregate
    (composed of other Analysis Engines). Aggregates may contain Cas Consumers. While
    Collection Readers and CAS Initializers always run in the same JVM as the CPM, a CAS
    Processor may be deployed in a variety of local and distributed modes, providing a number
    of options for scalability and robustness. The different deployment options are covered
    in detail in <a class="xref" href="#ugr.tug.cpe.deployment_alternatives">Section&nbsp;2.5, &#8220;Deploying a CPE&#8221;</a>.</p>
  
  <p>Each of the components in a CPE has an interface specified by the UIMA Collection
    Processing Architecture and is described by a declarative XML descriptor file.
    Similarly, the CPE itself has a well defined component interface and is described by a
    declarative XML descriptor file.</p>
  
  <p>A user creates a CPE by assembling the components mentioned above. The UIMA SDK
    provides a graphical tool, called the CPE Configurator, for assisting in the assembly of
    CPEs. Use of this tool is summarized in <a class="xref" href="#ugr.tug.cpe.cpe_configurator" title="2.2.1.&nbsp;Using the CPE Configurator">Section&nbsp;2.2.1, &#8220;Using the CPE Configurator&#8221;</a>, and more details can be found in <a href="tools.html#ugr.tools.cpe" class="olink">Chapter&nbsp;2, <i>Collection Processing Engine Configurator User's Guide</i></a>.
    Alternatively, a CPE can be assembled by writing an XML CPE descriptor. Details on the CPE
    descriptor, including its syntax and content, can be found in the <a href="references.html#ugr.ref.xml.cpe_descriptor" class="olink">Chapter&nbsp;3, <i>Collection Processing Engine Descriptor Reference</i></a>. The individual
    components have associated XML descriptors, each of which can be created and / or edited
    using the <a href="tools.html#ugr.tools.cde" class="olink">
    Component Description Editor</a>.</p>
  
  <p>A CPE is executed by a UIMA infrastructure component called the
    <span class="emphasis"><em>Collection Processing Manager</em></span> (CPM). The CPM provides a number
    of services and deployment options that cover instantiation and execution of CPEs, error
    recovery, and local and distributed deployment of the CPE components.</p>
  
  <div class="section" title="2.1.&nbsp;CPE Concepts"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.cpe.concepts">2.1.&nbsp;CPE Concepts</h2></div></div></div>
    
    
    <p> <a class="xref" href="#ugr.tug.cpe.fig.cpe_components" title="Figure&nbsp;2.1.&nbsp;CPE Components">Figure&nbsp;2.1, &#8220;CPE Components&#8221;</a> illustrates the data flow
      that occurs between the different types of components that make up a CPE.</p>
    
    <div class="figure"><a name="ugr.tug.cpe.fig.cpe_components"></a><div class="figure-contents">
      
      <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.cpe/image002.png" width="564" alt="CPE Components and flow between them"></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;2.1.&nbsp;CPE Components</b></p></div><br class="figure-break">
    
    <p>The components of a CPE are:</p>
    
    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="emphasis"><em>Collection Reader &#8211;</em></span>
      interfaces to a collection of data items (e.g., documents) to be analyzed. Collection
      Readers return CASes that contain the documents to analyze, possibly along with
      additional metadata.</p></li><li class="listitem"><p><span class="emphasis"><em>Analysis Engine &#8211;</em></span> takes a CAS,
        analyzes its contents, and produces an enriched CAS. Analysis Engines can be
        recursively composed of other Analysis Engines (called an
        <span class="emphasis"><em>Aggregate</em></span> Analysis Engine). Aggregates may also contain
        CAS Consumers.</p></li><li class="listitem"><p><span class="emphasis"><em>CAS Consumer &#8211;</em></span> consume the enriched
        CAS that was produced by the sequence of Analysis Engines before it, and produce an
        application-specific data structure, such as a search engine index or database.
        </p></li></ul></div>
    
    <p>A fourth type of component, the <span class="emphasis"><em>CAS Initializer,</em></span> may be
      used by a Collection Reader to populate a CAS from a document. However, as of UIMA
      version 2 CAS Initializers are now deprecated in favor of a more general mechsanism,
      multiple Subjects of Analysis.</p>
    
    <p>The Collection Processing Manager orchestrates the data flow
      within a CPE, monitors status, optionally manages the life-cycle of internal
      components and collects statistics.</p>
    
    <p>CASes are not saved in a persistent way by the framework. If you want to save CASes,
      then you have to save each CAS as it comes through (for example) using a CAS Consumer you
      write to do this, in whatever format you like. The UIMA SDK supplies an example CAS
      Consumer to save CASes to XML files, either in the standard XMI format or in an older
      format called XCAS.  It also supplies an example CAS Consumer to extract information from CASes and
      store the results into a relational Database, using Java's JDBC APIs.</p>
    
  </div>
  
  <div class="section" title="2.2.&nbsp;CPE Configurator and CAS viewer"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.cpe.configurator_and_viewer">2.2.&nbsp;CPE Configurator and CAS viewer</h2></div></div></div>
    
    
    <div class="section" title="2.2.1.&nbsp;Using the CPE Configurator"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cpe.cpe_configurator">2.2.1.&nbsp;Using the CPE Configurator</h3></div></div></div>
      
      
      <p>A CPE can be assembled by writing an XML CPE descriptor. Details on the CPE
        descriptor, including its syntax and content, can be found in <a href="references.html#ugr.ref.xml.cpe_descriptor" class="olink">Chapter&nbsp;3, <i>Collection Processing Engine Descriptor Reference</i></a>. Rather than
        edit raw XML, you may develop a CPE Descriptor using the CPE Configurator tool. The CPE
        Configurator tool is described briefly in this section, and in more detail in <a href="tools.html#ugr.tools.cpe" class="olink">Chapter&nbsp;2, <i>Collection Processing Engine Configurator User's Guide</i></a>.</p>
      
      <p>The CPE Configurator tool can be run from Eclipse (see <a class="xref" href="#ugr.tug.cpe.running_cpe_configurator_from_eclipse" title="2.2.2.&nbsp;Running the CPE Configurator from Eclipse">Section&nbsp;2.2.2, &#8220;Running the CPE Configurator from Eclipse&#8221;</a>, or using
        the <code class="literal">cpeGui</code> shell script (<code class="literal">cpeGui.bat</code> on
        Windows, <code class="literal">cpeGui.sh</code> on Unix), which is located in the
        <code class="literal">bin</code> directory of the UIMA SDK installation. Executing this
        batch file will display the window shown here:
        
        
        </p><div class="screenshot">
          <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.cpe/image004.jpg" width="564" alt="Screenshot of CPE GUI"></td></tr></table></div>
        </div><p>
        </p>
      
      <p>The window is divided into three sections, one each for the Collection Reader, 
        Analysis Engines, and CAS Consumers.<sup>[<a name="d4e1151" href="#ftn.d4e1151" class="footnote">5</a>]</sup> 
        In each section, you select the component(s) you want to include in the CPE by 
        browsing to their XML descriptors. The configuration parameters present in the XML 
        descriptors will then be displayed in the GUI; these can be modified to override
        the values present in the descriptor. For example, the screen shot below shows the 
        CPE Configurator after the following components have been chosen:
        
        
        </p><pre class="programlisting">Collection Reader: 
   %UIMA_HOME%/examples/descriptors/collection_reader/
          FileSystemCollectionReader.xml

Analysis Engine: 
   %UIMA_HOME%/examples/descriptors/analysis_engine/
          NamesAndPersonTitles_TAE.xml

CAS Consumer: 
    %UIMA_HOME%/examples/descriptors/cas_consumer/
          XmiWriterCasConsumer.xml</pre>
      
      
      <div class="screenshot">
     <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.cpe/image006.jpg" width="564" alt="Screenshot of CPE GUI after fields filled in"></td></tr></table></div>
    </div>
      
      <p>For the File System Collection Reader, ensure that the Input Directory is set to
        <code class="literal">%UIMA_HOME%\examples\data</code><sup>[<a name="d4e1164" href="#ftn.d4e1164" class="footnote">6</a>]</sup>. The other parameters may be left blank. For the External CAS Writer CAS
        Consumer, ensure that the Output Directory is set to
        <code class="literal">%UIMA_HOME%\examples\data\processed</code>.</p>
      
      <p>After selecting each of the components and providing configuration settings,
        click the play (forward arrow) button at the bottom of the screen to begin processing.
        A progress bar should be displayed in the lower left corner. (Note that the progress
        bar will not begin to move until all components have completed their initialization,
        which may take several seconds.) Once processing has begun, the pause and stop
        buttons become enabled.</p>
      
      <p>If an error occurs, you will be informed by an error dialog. If processing
        completes successfully, you will be presented with a performance report.</p>
      
      <p>Using the File menu, you can select <code class="literal">Save CPE Descriptor </code>to
        create an .xml descriptor file that defines the CPE you have constructed. Later, you
        can use <code class="literal">Open CPE Descriptor</code> to restore the CPE Configurator to
        the saved state. Also, CPE descriptors can be used to run a CPE from a Java program
        &#8211; see section <a class="xref" href="#ugr.tug.cpe.running_cpe_from_application" title="2.3.&nbsp;Running a CPE from Your Own Java Application">Section&nbsp;2.3, &#8220;Running a CPE from Your Own Java Application&#8221;</a>. CPE Descriptors
        allow specifying operational parameters, such as error handling options, that are
        not currently available for configuration through the CPE Configurator. For more
        information on manually creating a CPE Descriptor, see the <a href="references.html#ugr.ref.xml.cpe_descriptor" class="olink">Chapter&nbsp;3, <i>Collection Processing Engine Descriptor Reference</i></a>.</p>
            
      <p>The CPE configured above runs a simple name and title annotator on the sample data
        provided with the UIMA SDK and stores the results using the XMI Writer CAS Consumer. To
        view the results, start the External CAS Annotation Viewer by running the
        <code class="literal">annotationViewer</code> batch file
        (<code class="literal">annotationViewer.bat</code> on Windows,
        <code class="literal">annotationViewer.sh</code> on Unix), which is located in the
        <code class="literal">bin</code> directory of the UIMA SDK installation. Executing this
        batch file will display the window shown here:
        
        
        </p><div class="screenshot">
    <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="545"><tr><td><img src="images/tutorials_and_users_guides/tug.cpe/image008.jpg" width="545" alt="Screenshot of Annotation Viewer results"></td></tr></table></div>
  </div><p>
        </p>
      
      <p>Ensure that the Input Directory is the same as the Output Directory specified for
        the XMI Writer CAS Consumer in the CPE configured above (e.g.,
        <code class="literal">%UIMA_HOME%\examples\data\processed</code>) and that the TAE
        Descriptor File is set to the Analysis Engine used in the CPE configured above (e.g.,
        <code class="literal">examples\descriptors\analysis_engine\NamesAndPersonTitles_TAE.xml</code>
        ).</p>
      
      <p>Click the View button to display the Analyzed Documents window:
        
        
        </p><div class="screenshot">
    <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="347"><tr><td><img src="images/tutorials_and_users_guides/tug.cpe/image010.jpg" width="347" alt="Screenshot of CPE Configurator Analyzed Documents"></td></tr></table></div>
  </div><p>
        </p>
      
      <p>Double click on any document in the list to view the analyzed document. Double
        clicking the first document, IBM_LifeSciences.txt, will bring up the following
        window:
        
        
        </p><div class="screenshot">
    <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.cpe/image012.jpg" width="564" alt="Screenshot of Document and Annotation Viewer"></td></tr></table></div>
  </div><p>
        </p>
      
      <p>This window shows the analysis results for the document. Clicking on any
        highlighted annotation causes the details for that annotation to be displayed in the
        right-hand pane. Here the annotation spanning <span class="quote">&#8220;<span class="quote">John M. Thompson</span>&#8221;</span> has
        been clicked.</p>
      
      <p>Congratulations! You have successfully configured a CPE, saved its
        descriptor, run the CPE, and viewed the analysis results.</p>
    </div>
    
    <div class="section" title="2.2.2.&nbsp;Running the CPE Configurator from Eclipse"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cpe.running_cpe_configurator_from_eclipse">2.2.2.&nbsp;Running the CPE Configurator from Eclipse</h3></div></div></div>
      
      
      <p>If you have followed the instructions in <a href="overview_and_setup.html#ugr.ovv.eclipse_setup" class="olink">Chapter&nbsp;3, <i>Setting up the Eclipse IDE to work with UIMA</i></a> and imported the example Eclipse
        project, then you should already have a Run configuration for the CPE Configurator
        tool (called <code class="literal">UIMA CPE GUI</code>) configured to run in the example
        project. Simply run that configuration to start the CPE Configurator.</p>
      
      <p>If you haven't followed the Eclipse setup instructions and wish to run the
        CPE Configurator tool from Eclipse, you will need to do the following. As installed,
        this Eclipse launch configuration is associated with the
        <span class="quote">&#8220;<span class="quote">uimaj-examples</span>&#8221;</span> project. If you've not already done so, you
        may wish to import that project into your Eclipse workspace. It's located in
        %UIMA_HOME%/docs/examples. Doing this will supply the Eclipse launcher with all
        the class files it needs to run the CPE configurator. If you don't do this, please
        manually add the JAR files for UIMA to the launch configuration.</p>
      <p>Also, you need to add any projects or JAR files for any UIMA components you will be
        running to the launch class path.</p> <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>A simpler alternative may be
      to change the CPE launch configuration to be based on your project. If you do that, it will
      pick up all the files in your project's class path, which you should set up to
      include all the UIMA framework files. An easy way to do this is to specify in your
      project's properties' build-path that the uimaj-examples project is on
      the build path, because the uimaj-examples project is set up to include all the UIMA
      framework classes in its classpath already. </p></div>
      
      <p>Next, in the Eclipse menu select <code class="literal">Run <span class="symbol">&#8594;</span>
        Run</code>..., which brings up the Run configuration screen.</p>
      
      <p>In the Main tab, set the main class to
        <code class="literal">org.apache.uima.tools.cpm.CpmFrame</code></p>
      
      <p>In the arguments tab, add the following to the VM arguments:
        
        
        </p><pre class="programlisting">-Xms128M -Xmx256M 
-Duima.home="C:\Program Files\Apache\uima"</pre><p>
        (or wherever you installed the UIMA SDK)</p>
      
      <p>Click the Run button to launch the CPE Configurator, and use it as previously
        described in this section.</p>
      
    </div>
  </div>
  
  <div class="section" title="2.3.&nbsp;Running a CPE from Your Own Java Application"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.cpe.running_cpe_from_application">2.3.&nbsp;Running a CPE from Your Own Java Application</h2></div></div></div>
    
    
    <p>The simplest way to run a CPE from a Java application is to first create a CPE
      descriptor as described in the previous section. Then the CPE can be instantiated and
      run using the following code:
      
      
      </p><pre class="programlisting">      //parse CPE descriptor in file specified on command line
CpeDescription cpeDesc = UIMAFramework.getXMLParser().
        parseCpeDescription(new XMLInputSource(args[0]));
      
      //instantiate CPE
mCPE = UIMAFramework.produceCollectionProcessingEngine(cpeDesc);

      //Create and register a Status Callback Listener
mCPE.addStatusCallbackListener(new StatusCallbackListenerImpl());

      //Start Processing
mCPE.process();</pre>
    
    <p>This will start the CPE running in a separate thread.</p>
    
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <code class="literal">process()</code> method for a CPE can only be called once.  If you 
    need to call it again, you have to instantiate a new CPE, and call that new CPE's process
    method.</p></div>
    
    <div class="section" title="2.3.1.&nbsp;Using Listeners"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cpe.using_listeners">2.3.1.&nbsp;Using Listeners</h3></div></div></div>
      
      
      <p>Updates of the CPM's progress, including any errors that occur, are sent to
        the callback handler that is registered by the call to
        <code class="literal">addStatusCallbackListener</code>, above. The callback handler is a
        class that implements the CPM's
        <code class="literal">StatusCallbackListener</code> interface. It responds to events by
        printing messages to the console. The source code is fairly straightforward and is
        not included in this chapter &#8211; see the
        <code class="literal">org.apache.uima.examples.cpe.SimpleRunCPE.java</code> in the
        <code class="literal">%UIMA_HOME%\examples\src</code> directory for the complete
        code.</p>
      
      <p>If you need more control over the information in the CPE descriptor, you can
        manually configure it via its API. See the Javadocs for package
        <code class="literal">org.apache.uima.collection</code> for more details.</p>
      
    </div>
  </div>
  
  <div class="section" title="2.4.&nbsp;Developing Collection Processing Components"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.cpe.developing_collection_processing_components">2.4.&nbsp;Developing Collection Processing Components</h2></div></div></div>
    
    
    <p>This section is an introduction to the process of developing Collection Readers,
      CAS Initializers, and CAS Consumers. The code snippets refer to the classes that can be
      found in <code class="literal">%UIMA_HOME%\examples\src </code>example project.</p>
    
    <p>In the following sections, classes you write to represent components need to be
      public and have public, 0-argument constructors, so that they can be instantiated by
      the framework. (Although Java classes in which you do not define any constructor will,
      by default, have a 0-argument constructor that doesn't do anything, a class in
      which you have defined at least one constructor does not get a default 0-argument
      constructor.)</p>
    
    <div class="section" title="2.4.1.&nbsp;Developing Collection Readers"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cpe.collection_reader.developing">2.4.1.&nbsp;Developing Collection Readers</h3></div></div></div>
      
      
      <p>A Collection Reader is responsible for obtaining documents from the collection
        and returning each document as a CAS. Like all UIMA components, a Collection Reader
        consists of two parts &#8212; the code and an XML descriptor.</p>
      
      <p>A simple example of a Collection Reader is the <span class="quote">&#8220;<span class="quote">File System Collection
        Reader,</span>&#8221;</span> which simply reads documents from files in a specified directory.
        The Java code is in the class
        <code class="literal">org.apache.uima.examples.cpe.FileSystemCollectionReader</code>
        and the XML descriptor is
        <code class="literal">%UIMA_HOME%/examples/src/main/descriptors/collection_reader/
          FileSystemCollectionReader.xml</code>.</p>
      
      <div class="section" title="2.4.1.1.&nbsp;Java Class for the Collection Reader"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.cpe.collection_reader.java_class">2.4.1.1.&nbsp;Java Class for the Collection Reader</h4></div></div></div>
        
        
        <p>The Java class for a Collection Reader must implement the
          <code class="literal">org.apache.uima.collection.CollectionReader</code>
          interface. You may build your Collection Reader from scratch and implement this
          interface, or you may extend the convenience base class
          <code class="literal">org.apache.uima.collection.CollectionReader_ImplBase</code>
          .</p>
        
        <p>The convenience base class provides default implementations for many of the
          methods defined in the <code class="literal">CollectionReader</code> interface, and
          provides abstract definitions for those methods that you are required to
          implement in your new Collection Reader. Note that if you extend this base class,
          you do not need to declare that your new Collection Reader implements the
          <code class="literal">CollectionReader</code> interface.</p> <div class="tip" title="Tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>Eclipse
        tip &#8211; if you are using Eclipse, you can quickly create the boiler plate code and
        stubs for all of the required methods by clicking <code class="literal">File</code>
        <span class="symbol">&#8594;</span> <code class="literal">New</code> <span class="symbol">&#8594;</span> <code class="literal">Class</code> to bring up the <span class="quote">&#8220;<span class="quote">New Java Class</span>&#8221;</span>
        dialogue, specifying
        <code class="literal">org.apache.uima.collection.CollectionReader_ImplBase</code>
        as the Superclass, and checking <span class="quote">&#8220;<span class="quote">Inherited abstract methods</span>&#8221;</span> in the
        section <span class="quote">&#8220;<span class="quote">Which method stubs would you like to create?</span>&#8221;</span>, as in the 
        screenshot below:</p></div>     
        
        <div class="screenshot">
    <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="436"><tr><td><img src="images/tutorials_and_users_guides/tug.cpe/image014.jpg" width="436" alt="Screenshot showing Eclipse new class wizard"></td></tr></table></div>
  </div>
        
        <p>For the rest of this section we will assume that your new Collection Reader
          extends the <code class="literal">CollectionReader_ImplBase</code> class, and we will
          show examples from the
          <code class="literal">org.apache.uima.examples.cpe.FileSystemCollectionReader</code>
          . If you must inherit from a different superclass, you must ensure that your
          Collection Reader implements the <code class="literal">CollectionReader</code>
          interface &#8211; see the Javadocs for <code class="literal">CollectionReader</code>
          for more details.</p>
      </div>
      
      <div class="section" title="2.4.1.2.&nbsp;Required Methods in the Collection Reader class"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.cpe.collection_reader.required_methods">2.4.1.2.&nbsp;Required Methods in the Collection Reader class</h4></div></div></div>
        
        
        
        <p>The following abstract methods must be implemented:</p>
        
        <div class="section" title="initialize()"><div class="titlepage"><div><div><h5 class="title" id="ugr.tug.cpe.collection_reader.required_methods.initialize">initialize()</h5></div></div></div>
          
          
          <p>The <code class="literal">initialize()</code> method is called by the framework
            when the Collection Reader is first created.
            <code class="literal">CollectionReader_ImplBase</code> actually provides a default
            implementation of this method (i.e., it is not abstract), so you are not strictly
            required to implement this method. However, a typical Collection Reader will
            implement this method to obtain parameter values and perform various
            initialization steps.</p>
          
          <p>In this method, the Collection Reader class can access the values of its
            configuration parameters and perform other initialization logic. The example
            File System Collection Reader reads its configuration parameters and then
            builds a list of files in the specified input directory, as follows:</p>
          
          
          <pre class="programlisting">public void initialize() throws ResourceInitializationException {
  File directory = new File(
            (String)getConfigParameterValue(PARAM_INPUTDIR));
  mEncoding = (String)getConfigParameterValue(PARAM_ENCODING);
  mDocumentTextXmlTagName = (String)getConfigParameterValue(PARAM_XMLTAG);
  mLanguage = (String)getConfigParameterValue(PARAM_LANGUAGE);
  mCurrentIndex = 0; 
  
  //get list of files (not subdirectories) in the specified directory
  mFiles = new ArrayList();
  File[] files = directory.listFiles();
  for (int i = 0; i &lt; files.length; i++) {
    if (!files[i].isDirectory()) {
      mFiles.add(files[i]);  
    }
  }
}</pre>
          <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This is the zero-argument version of the initialize method. There is
          also a method on the Collection Reader interface called
          <code class="literal">initialize(ResourceSpecifier, Map)</code> but it is not
          recommended that you override this method in your code. That method performs
          internal initialization steps and then calls the zero-argument
          <code class="literal">initialize()</code>. </p></div>
          
        </div>
        
        <div class="section" title="hasNext()"><div class="titlepage"><div><div><h5 class="title" id="ugr.tug.cpe.collection_reader.hasnext">hasNext()</h5></div></div></div>
          
          
          <p>The <code class="literal">hasNext()</code> method returns whether or not there are
            any documents remaining to be read from the collection. The File System
            Collection Reader's <code class="literal">hasNext()</code> method is very
            simple. It just checks if there are any more files left to be read:
            
            
            </p><pre class="programlisting">public boolean hasNext() {
  return mCurrentIndex &lt; mFiles.size();
}</pre><p>
            </p>
          
        </div>
        
        <div class="section" title="getNext(CAS)"><div class="titlepage"><div><div><h5 class="title" id="ugr.tug.cpe.collection_reader.required_methods.getnext">getNext(CAS)</h5></div></div></div>
          
          
          <p>The <code class="literal">getNext()</code> method reads the next document from the
            collection and populates a CAS. In the simple case, this amounts to reading the
            file and calling the CAS's <code class="literal">setDocumentText</code> method.
            The example File System Collection Reader is slightly more complex. It first
            checks for a CAS Initializer. If the CPE includes a CAS Initializer, the CAS
            Initializer is used to read the document, and
            <code class="literal">initialize()</code> the CAS. If the CPE does not include a CAS
            Initializer, the File System Collection Reader reads the document and sets the
            document text in the CAS.</p>
          
          <p>The File System Collection Reader also stores additional metadata about
            the document in the CAS. In particular, it sets the document's language in
            the special built-in feature structure
            <code class="literal">uima.tcas.DocumentAnnotation </code>(see <a href="references.html#ugr.ref.cas.document_annotation" class="olink">Section&nbsp;4.3, &#8220;Built-in CAS Types&#8221;</a> for details about this
            built-in type) and creates an instance of
            <code class="literal">org.apache.uima.examples.SourceDocumentInformation</code>
            , which stores information about the document's source location. This
            information may be useful to downstream components such as CAS Consumers. Note
            that the type system descriptor for this type can be found in
            <code class="literal">org.apache.uima.examples.SourceDocumentInformation.xml</code>
            , which is located in the <code class="literal">examples/src</code> directory.</p>
          
          <p>The getNext() method for the File System Collection Reader looks like
            this:</p>
          
          
          <pre class="programlisting">  public void getNext(CAS aCAS) throws IOException, CollectionException {
    JCas jcas;
    try {
      jcas = aCAS.getJCas();
    } catch (CASException e) {
      throw new CollectionException(e);
    }

    // open input stream to file
    File file = (File) mFiles.get(mCurrentIndex++);
    BufferedInputStream fis = 
            new BufferedInputStream(new FileInputStream(file));
    try {
      byte[] contents = new byte[(int) file.length()];
      fis.read(contents);
      String text;
      if (mEncoding != null) {
        text = new String(contents, mEncoding);
      } else {
        text = new String(contents);
      }
      // put document in CAS
      jcas.setDocumentText(text);
    } finally {
      if (fis != null)
        fis.close();
    }

    // set language if it was explicitly specified 
    //as a configuration parameter
    if (mLanguage != null) {
      ((DocumentAnnotation) jcas.getDocumentAnnotationFs()).
            setLanguage(mLanguage);
    }

    // Also store location of source document in CAS. 
    // This information is critical if CAS Consumers will 
    // need to know where the original document contents 
    // are located.
    // For example, the Semantic Search CAS Indexer 
    // writes this information into the search index that 
    // it creates, which allows applications that use the 
    // search index to locate the documents that satisfy 
    //their semantic queries.
    SourceDocumentInformation srcDocInfo = 
            new SourceDocumentInformation(jcas);
    srcDocInfo.setUri(
            file.getAbsoluteFile().toURL().toString());
    srcDocInfo.setOffsetInSource(0);
    srcDocInfo.setDocumentSize((int) file.length());
    srcDocInfo.setLastSegment(
            mCurrentIndex == mFiles.size());
    srcDocInfo.addToIndexes();
  }</pre>
          
          <p>The Collection Reader can create additional annotations in the CAS at this
            point, in the same way that annotators create annotations.</p>
        </div>
        
        <div class="section" title="getProgress()"><div class="titlepage"><div><div><h5 class="title" id="ugr.tug.cpe.collection_reader.required_methods.getprogress">getProgress()</h5></div></div></div>
          
          <p>The Collection Reader is responsible for returning progress information;
            that is, how much of the collection has been read thus far and how much remains to be
            read. The framework defines progress very generally; the Collection Reader
            simply returns an array of <code class="literal">Progress</code> objects, where each
            object contains three fields &#8212; the amount already completed, the total
            amount (if known), and a unit (e.g. entities (documents), bytes, or files). The
            method returns an array so that the Collection Reader can report progress in
            multiple different units, if that information is available. The File System
            Collection Reader's <code class="literal">getProgress()</code> method looks
            like this:
            
            
            </p><pre class="programlisting">public Progress[] getProgress() {
  return new Progress[]{
     new ProgressImpl(mCurrentIndex,mFiles.size(),Progress.ENTITIES)};
}</pre>
          
          <p>In this particular example, the total number of files in the collection is
            known, but the total size of the collection is not known. As such, a
            <code class="literal">ProgressImpl</code> object for
            <code class="literal">Progress.ENTITIES</code> is returned, but a
            <code class="literal">ProgressImpl</code> object for
            <code class="literal">Progress.BYTES</code> is not.</p>
          
        </div>
        
        <div class="section" title="close()"><div class="titlepage"><div><div><h5 class="title" id="ugr.tug.cpe.collection_reader.required_methods.close">close()</h5></div></div></div>
          
          
          <p>The close method is called when the Collection Reader is no longer needed.
            The Collection Reader should then release any resources it may be holding. The
            FileSystemCollectionReader does not hold resources and so has an empty
            implementation of this method:</p>
          
          
          <pre class="programlisting">public void close() throws IOException { }</pre>
          
        </div>
        
        <div class="section" title="Optional Methods"><div class="titlepage"><div><div><h5 class="title" id="ugr.tug.cpe.collection_reader.optional_methods">Optional Methods</h5></div></div></div>
          
          
          <p>The following methods may be implemented:</p>
          
          <div class="section" title="reconfigure()"><div class="titlepage"><div><div><h6 class="title" id="ugr.tug.cpe.collection_reader.optional_methods.reconfigure">reconfigure()</h6></div></div></div>
            
            <p>This method is called if the Collection Reader's configuration
              parameters change.</p>
          </div>
          
          <div class="section" title="typeSystemInit()"><div class="titlepage"><div><div><h6 class="title" id="ugr.tug.cpe.collection_reader.optional_methods.typesysteminit">typeSystemInit()</h6></div></div></div>
            
            
            <p>If you are only setting the document text in the CAS, or if you are using the
              JCas (recommended, as in the current example, you do not have to implement this
              method. If you are directly using the CAS API, this method is used in the same way
              as it is used for an annotator &#8211; see <a href="tutorials_and_users_guides.html#ugr.tug.aae.contract_for_annotator_methods" class="olink">Section&nbsp;1.5.1, &#8220;Annotator Methods&#8221;</a>
              for more information.</p>
          </div>
        </div>
        
        <div class="section" title="Threading considerations"><div class="titlepage"><div><div><h5 class="title" id="ugr.tug.cpe.collection_reader.threading">Threading considerations</h5></div></div></div>
          
          
          <p>Collection readers do not have to be thread safe; they are run with a single
            thread per instance, and only one instance per instance of the Collection
            Processing Manager (CPM) is made.</p>
          
        </div>
        
        <div class="section" title="XML Descriptor for a Collection Reader"><div class="titlepage"><div><div><h5 class="title" id="ugr.tug.cpe.collection_reader.descriptor">XML Descriptor for a Collection Reader</h5></div></div></div>
          
          
          <p>You can use the Component Description Editor to create and / or edit the File
            System Collection Reader's descriptor. Here is its descriptor
            (abbreviated somewhat), which is very similar to an Analysis
            Engine descriptor:</p>
          
          
          <pre class="programlisting">&lt;collectionReaderDescription 
          xmlns="http://uima.apache.org/resourceSpecifier"&gt;
  &lt;frameworkImplementation&gt;org.apache.uima.java&lt;/frameworkImplementation&gt;
  &lt;implementationName&gt;
    org.apache.uima.examples.cpe.FileSystemCollectionReader
  &lt;/implementationName&gt;
  &lt;processingResourceMetaData&gt;
    &lt;name&gt;File System Collection Reader&lt;/name&gt;
    &lt;description&gt;Reads files from the filesystem.&lt;/description&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;vendor&gt;The Apache Software Foundation&lt;/vendor&gt;
    &lt;configurationParameters&gt;
      &lt;configurationParameter&gt;
        &lt;name&gt;InputDirectory&lt;/name&gt;
        &lt;description&gt;Directory containing input files&lt;/description&gt;
        &lt;type&gt;String&lt;/type&gt;
        &lt;multiValued&gt;false&lt;/multiValued&gt;
        &lt;mandatory&gt;true&lt;/mandatory&gt;
      &lt;/configurationParameter&gt;
      &lt;configurationParameter&gt;
        &lt;name&gt;Encoding&lt;/name&gt;
        &lt;description&gt;Character encoding for the documents.&lt;/description&gt;
        &lt;type&gt;String&lt;/type&gt;
        &lt;multiValued&gt;false&lt;/multiValued&gt;
        &lt;mandatory&gt;false&lt;/mandatory&gt;
      &lt;/configurationParameter&gt;
      &lt;configurationParameter&gt;
        &lt;name&gt;Language&lt;/name&gt;
        &lt;description&gt;ISO language code for the documents&lt;/description&gt;
        &lt;type&gt;String&lt;/type&gt;
        &lt;multiValued&gt;false&lt;/multiValued&gt;
        &lt;mandatory&gt;false&lt;/mandatory&gt;
      &lt;/configurationParameter&gt;
    &lt;/configurationParameters&gt;
    &lt;configurationParameterSettings&gt;
      &lt;nameValuePair&gt;
        &lt;name&gt;InputDirectory&lt;/name&gt;
        &lt;value&gt;
          &lt;string&gt;C:/Program Files/apache/uima/examples/data&lt;/string&gt;
        &lt;/value&gt;
      &lt;/nameValuePair&gt;
    &lt;/configurationParameterSettings&gt;
    
    &lt;!-- Type System of CASes returned by this Collection Reader --&gt;
    
    &lt;typeSystemDescription&gt;
      &lt;imports&gt;
        &lt;import name="org.apache.uima.examples.SourceDocumentInformation"/&gt;
      &lt;/imports&gt;
    &lt;/typeSystemDescription&gt;
    
    &lt;capabilities&gt;
      &lt;capability&gt;
        &lt;inputs/&gt;
        &lt;outputs&gt;
          &lt;type allAnnotatorFeatures="true"&gt;
            org.apache.uima.examples.SourceDocumentInformation
          &lt;/type&gt;
        &lt;/outputs&gt;
      &lt;/capability&gt;
    &lt;/capabilities&gt;
    &lt;operationalProperties&gt;
      &lt;modifiesCas&gt;true&lt;/modifiesCas&gt;
      &lt;multipleDeploymentAllowed&gt;false&lt;/multipleDeploymentAllowed&gt;
      &lt;outputsNewCASes&gt;true&lt;/outputsNewCASes&gt;
    &lt;/operationalProperties&gt;
  &lt;/processingResourceMetaData&gt;
&lt;/collectionReaderDescription&gt;</pre>
          
        </div>
      </div>
    </div>
    
    <div class="section" title="2.4.2.&nbsp;Developing CAS Initializers"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cpe.cas_initializer.developing">2.4.2.&nbsp;Developing CAS
      Initializers</h3></div></div></div> <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>CAS Initializers are now deprecated (as of
      version 2.1). For complex initialization, please use instead the capabilities of
      creating additional Subjects of Analysis (see <a href="tutorials_and_users_guides.html#ugr.tug.mvs" class="olink">Chapter&nbsp;6, <i>Multiple CAS Views of an Artifact</i></a>
      ). </p></div>
      
      <p>In UIMA 1.x, the CAS Initializer component was intended to be used as a plug-in
        to the Collection Reader for when the task of populating the CAS from a raw document is
        complex and might be reusable with other data collections.</p>
          
      <p>A CAS Initializer Java class must implement the interface
        <code class="literal">org.apache.uima.collection.CasInitializer</code>, and will also
        generally extend from the convenience base class
        <code class="literal">org.apache.uima.collection.CasInitializer_ImplBase</code>. A
        CAS Initializer also must have an XML descriptor, which has the exact same form as a
        Collection Reader Descriptor except that the outer tag is
        <code class="literal">&lt;casInitializerDescription&gt;</code>.</p>
      
      <p>CAS Initializers have optional <code class="literal">initialize()</code>,
        <code class="literal">reconfigure()</code>, and <code class="literal">typeSystemInit()</code>
        methods, which perform the same functions as they do for Collection Readers. The only
        required method for a CAS Initializer is <code class="literal">initializeCas(Object,
        CAS)</code>. This method takes the raw document (for example, an
        <code class="literal">InputStream</code> object from which the document can be read) and a
        CAS, and populates the CAS from the document.</p>      
    </div>
    
    <div class="section" title="2.4.3.&nbsp;Developing CAS Consumers"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cpe.cas_consumer.developing">2.4.3.&nbsp;Developing CAS
      Consumers</h3></div></div></div> 
      
      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>In version 2, there is no difference in capability
      between CAS Consumers and ordinary Analysis Engines, except for the default setting of
      the XML parameters for <code class="literal">multipleDeploymentAllowed</code> and
      <code class="literal">modifiesCas</code>. We recommend for future work that users implement
      and use Analysis Engine components instead of CAS Consumers.</p>
      <p>The rest of this section is written using the version 1 style of CAS Consumer;
      the methods described are also available for Analysis Engines.  Note that the 
      CAS Consumer <code class="literal">processCAS</code> method is equivalent to the Analysis Engine
      <code class="literal">process</code> method.</p></div>
      
      <p>A CAS Consumer receives each CAS after it has been analyzed by the Analysis
        Engine. CAS Consumers typically do not update the CAS; they typically extract data
        from the CAS and persist selected information to aggregate data structures such as
        search engine indexes or databases.</p>
      
      <p>A CAS Consumer Java class must implement the interface
        <code class="literal">org.apache.uima.collection.CasConsumer</code>, and will also
        generally extend from the convenience base class
        <code class="literal">org.apache.uima.collection.CasConsumer_ImplBase</code>. A CAS
        Consumer also must have an XML descriptor, which has the exact same form as a
        Collection Reader Descriptor except that the outer tag is
        <code class="literal">&lt;casConsumerDescription&gt;</code>.</p>
      
      <p>CAS Consumers have optional <code class="literal">initialize()</code>,
        <code class="literal">reconfigure()</code>, and <code class="literal">typeSystemInit()</code>
        methods, which perform the same functions as they do for Collection Readers and CAS
        Initializers. The only required method for a CAS Consumer is
        <code class="literal">processCas(CAS)</code>, which is where the CAS Consumer does the bulk
        of its work (i.e., consume the CAS).</p>
      
      <p>The <code class="literal">CasConsumer</code> interface (as well as the version 2
        Analysis Engine interfac) additionally defines batch
        and collection level processing methods. The CAS Consumer or Analysis Engine
        can implement the
        <code class="literal">batchProcessComplete()</code> method to perform processing that
        should occur at the end of each batch of CASes. Similarly, the CAS Consumer 
        or Analysis Engine can
        implement the <code class="literal">collectionProcessComplete()</code> method to
        perform any collection level processing at the end of the collection.</p>
      
      <p>A very simple example of a CAS Consumer, which writes an XML representation of the
        CAS to a file, is the XMI Writer CAS Consumer. The Java code is in the class
        <code class="literal">org.apache.uima.examples.cpe.XmiWriterCasConsumer</code> and
        the descriptor is in
        <code class="literal">%UIMA_HOME%/examples/descriptors/cas_consumer/XmiWriterCasConsumer.xml</code>
        .</p>
      
      <div class="section" title="2.4.3.1.&nbsp;Required Methods for a CAS Consumer"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.cpe.cas_consumer.required_methods">2.4.3.1.&nbsp;Required Methods for a CAS Consumer</h4></div></div></div>
        
        
        <p>When extending the convenience class
          <code class="literal">org.apache.uima.collection.CasConsumer_ImplBase</code>, the
          following abstract methods must be implemented:</p>
        
        <div class="section" title="initialize()"><div class="titlepage"><div><div><h5 class="title" id="ugr.tug.cpe.cas_consumer.required_methods.initialize">initialize()</h5></div></div></div>
          
          <p>The <code class="literal">initialize()</code> method is called by the framework
            when the CAS Consumer is first created.
            <code class="literal">CasConsumer_ImplBase</code> actually provides a default
            implementation of this method (i.e., it is not abstract), so you are not strictly
            required to implement this method. However, a typical CAS Consumer will
            implement this method to obtain parameter values and perform various
            initialization steps.</p>
          
          <p>In this method, the CAS Consumer can access the values of its configuration
            parameters and perform other initialization logic. The example XMI Writer CAS
            Consumer reads its configuration parameters and sets up the output directory:
            
            
            </p><pre class="programlisting">public void initialize() throws ResourceInitializationException {
  mDocNum = 0;
  mOutputDir = new File((String) getConfigParameterValue(PARAM_OUTPUTDIR));
  if (!mOutputDir.exists()) {
    mOutputDir.mkdirs();
  }
}</pre>
        </div>
        
        <div class="section" title="processCas()"><div class="titlepage"><div><div><h5 class="title" id="ugr.tug.cpe.cas_consumer.required_methods.processcas">processCas()</h5></div></div></div>
          
          
          <p>The <code class="literal">processCas()</code> method is where the CAS Consumer
            does most of its work. In our example, the XMI Writer CAS Consumer obtains an
            iterator over the document metadata in the CAS (in the
            SourceDocumentInformation feature structure, which is created by the File
            System Collection Reader) and extracts the URI for the current document. From
            this the output filename is constructed in the output directory and a subroutine
            (<code class="literal">writeXmi</code>) is called to generate the output file. The
            <code class="literal">writeXmi</code> subroutine uses the
            <code class="literal">XmiCasSerializer</code> class provided with the UIMA SDK to
            serialize the CAS to the output file (see the example source code for
            details).</p>
          
          
          <pre class="programlisting">public void processCas(CAS aCAS) throws ResourceProcessException {
  String modelFileName = null;

  JCas jcas;
  try {
    jcas = aCAS.getJCas();
  } catch (CASException e) {
    throw new ResourceProcessException(e);
  }
 
    // retreive the filename of the input file from the CAS
  FSIterator it = jcas
            .getAnnotationIndex(SourceDocumentInformation.type)
                  .iterator();
  File outFile = null;
  if (it.hasNext()) {
    SourceDocumentInformation fileLoc = 
            (SourceDocumentInformation) it.next();
    File inFile;
    try {
      inFile = new File(new URL(fileLoc.getUri()).getPath());
      String outFileName = inFile.getName();
      if (fileLoc.getOffsetInSource() &gt; 0) {
        outFileName += ("_" + fileLoc.getOffsetInSource());
      }
      outFileName += ".xmi";
      outFile = new File(mOutputDir, outFileName);
      modelFileName = mOutputDir.getAbsolutePath() + 
            "/" + inFile.getName() + ".ecore";
    } catch (MalformedURLException e1) {
      // invalid URL, use default processing below
    }
  }
  if (outFile == null) {
    outFile = new File(mOutputDir, "doc" + mDocNum++);
  }
  // serialize XCAS and write to output file
  try {
    writeXmi(jcas.getCas(), outFile, modelFileName);
  } catch (IOException e) {
    throw new ResourceProcessException(e);
  } catch (SAXException e) {
    throw new ResourceProcessException(e);
  }
}</pre>
          
        </div>
        
        <div class="section" title="Optional Methods"><div class="titlepage"><div><div><h5 class="title" id="ugr.tug.cpe.cas_consumer.optional_methods">Optional Methods</h5></div></div></div>
          
          <p>The following methods are optional in a CAS Consumer, though they are often
            used.</p>
          <div class="section" title="batchProcessComplete()"><div class="titlepage"><div><div><h6 class="title" id="ugr.tug.cpe.cas_consumer.optional_methods.batchprocesscomplete">batchProcessComplete()</h6></div></div></div>
            
            
            <p>The framework calls the batchProcessComplete() method at the end of each
              batch of CASes. This gives the CAS Consumer or Analysis Engine 
              an opportunity to perform any batch
              level processing. Our simple XMI Writer CAS Consumer does not perform any
              batch level processing, so this method is empty. Batch size is set in the
              Collection Processing Engine descriptor.</p>
          </div>
          
          <div class="section" title="collectionProcessComplete()"><div class="titlepage"><div><div><h6 class="title" id="ugr.tug.cpe.cas_consumer.optional_methods.collectionprocesscomplete">collectionProcessComplete()</h6></div></div></div>
            
            
            <p>The framework calls the collectionProcessComplete() method at the end
              of the collection (i.e., when all objects in the collection have been
              processed). At this point in time, no CAS is passed in as a parameter. This gives
              the CAS Consumer or Analysis Engine an opportunity to perform collection processing over the
              entire set of objects in the collection. Our simple XMI Writer CAS Consumer
              does not perform any collection level processing, so this method is
              empty.</p>
          </div>
          
        </div>
        
      </div>
    </div>
  </div>
  
  <div class="section" title="2.5.&nbsp;Deploying a CPE"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.cpe.deploying_a_cpe">2.5.&nbsp;Deploying a CPE</h2></div></div></div>
    
    
    <p>The CPM provides a number of service and deployment options that cover
      instantiation and execution of CPEs, error recovery, and local and distributed
      deployment of the CPE components. The behavior of the CPM (and correspondingly, the
      CPE) is controlled by various options and parameters set in the CPE descriptor. The
      current version of the CPE Configurator tool, however, supports only default error
      handling and deployment options. To change these options, you must manually edit the
      CPE descriptor.</p>
    
    <p>Eventually the CPE Configurator tool will support configuring these options and a
      detailed tutorial for these settings will be provided. In the meantime, we provide only
      a high-level, conceptual overview of these advanced features in the rest of this
      chapter, and refer the advanced user to <a href="references.html#ugr.ref.xml.cpe_descriptor" class="olink">Chapter&nbsp;3, <i>Collection Processing Engine Descriptor Reference</i></a> for details on setting these options in the CPE
      Descriptor.</p>
    
    <p> <a class="xref" href="#ugr.tug.cpe.fig.cpe_instantiation" title="Figure&nbsp;2.2.&nbsp;CPE Instantiation">Figure&nbsp;2.2, &#8220;CPE Instantiation&#8221;</a> shows a logical view of
      how an application uses the UIMA framework to instantiate a CPE from a CPE descriptor.
      The CPE descriptor identifies the CPE components (referencing their corresponding
      descriptors) and specifies the various options for configuring the CPM and deploying
      the CPE components.</p>
    
    <div class="figure"><a name="ugr.tug.cpe.fig.cpe_instantiation"></a><div class="figure-contents">
      
      <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.cpe/image018.png" width="564" alt="Picture of deployment of a CPE"></td></tr></table></div>
    </div><p class="title"><b>Figure&nbsp;2.2.&nbsp;CPE Instantiation</b></p></div><br class="figure-break">
    
    <p><a name="ugr.tug.cpe.deployment_alternatives"></a>There are three deployment modes
      for CAS Processors (Analysis Engines and CAS Consumers) in a CPE:</p>
    
    <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p><span class="bold"><strong>Integrated</strong></span> (runs
      in the same Java instance as the CPM)</p></li><li class="listitem"><p><span class="bold"><strong>Managed</strong></span> (runs in a separate
        process on the same machine), and</p></li><li class="listitem"><p><span class="bold"><strong>Non-managed</strong></span> (runs in a
        separate process, perhaps on a different machine). </p></li></ol></div>
    
    <p>An integrated CAS Processor runs in the same JVM as the CPE. A managed CAS Processor
      runs in a separate process from the CPE, but still on the same computer. The CPE controls
      startup, shutdown, and recovery of a managed CAS Processor. A non-managed CAS
      Processor runs as a service and may be on the same computer as the CPE or on a remote
      computer. A non-managed CAS Processor <span class="bold-italic">
      service</span> is started and managed independently from the CPE.</p>
    
    <p>For both managed and non-managed CAS Processors, the CAS must be transmitted
      between separate processes and possibly between separate computers. This is
      accomplished using <span class="emphasis"><em>Vinci</em></span>, a communication protocol used by
      the CPM and which is provided as a part of Apache UIMA. Vinci handles service naming and
      location and data transport (see <a href="tutorials_and_users_guides.html#ugr.tug.application.how_to_deploy_a_vinci_service" class="olink">Section&nbsp;3.6.2, &#8220;Deploying as a Vinci Service&#8221;</a>&nbsp; for more
      information). Service naming and location are provided by a <span class="emphasis"><em>Vinci Naming
      Service</em></span>, or <span class="emphasis"><em>VNS</em></span>. For managed CAS Processors, the
      CPE uses its own internal VNS. For non-managed CAS Processors, a separate VNS must be
      running.</p> <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The UIMA SDK also supports using unmanaged remote
    services via the web-standard SOAP communications protocol (see <a href="tutorials_and_users_guides.html#ugr.tug.application.how_to_deploy_as_soap" class="olink">Section&nbsp;3.6.1, &#8220;Deploying as SOAP Service&#8221;</a>. This approach is
    based on a proxy implementation, where the proxy is essentially running in an integrated
    mode. To use this approach with the CPM, use the Integrated mode, with the component being
    an Aggregate which, in turn, connects to a remote service. </p></div>
    
    <p>The CPE Configurator tool currently only supports constructing CPEs that deploy
      CAS Processors in integrated mode. To deploy CAS Processors in any other mode, the CPE
      descriptor must be edited by hand (better tooling may be provided later). Details on the
      CPE descriptor and the required settings for various CAS Processor deployment modes
      can be found in <a href="references.html#ugr.ref.xml.cpe_descriptor" class="olink">Chapter&nbsp;3, <i>Collection Processing Engine Descriptor Reference</i></a>
      . In the following sections we merely summarize the various CAS Processor deployment
      options.</p>
    
    <div class="section" title="2.5.1.&nbsp;Deploying Managed CAS Processors"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cpe.managed_deployment">2.5.1.&nbsp;Deploying Managed CAS Processors</h3></div></div></div>
      
      
      <p>Managed CAS Processor deployment is shown in <a class="xref" href="#ugr.tug.cpe.fig.managed_deployment" title="Figure&nbsp;2.3.&nbsp;CPE with Managed CAS Processors">Figure&nbsp;2.3, &#8220;CPE with Managed CAS Processors&#8221;</a>. A managed CAS Processor is
        deployed by the CPE as a Vinci service. The CPE manages the lifecycle of the CAS
        Processor including service launch, restart on failures, and service shutdown. A
        managed CAS Processor runs on the same machine as the CPE, but in a separate process.
        This provides the necessary fault isolation for the CPE to protect it from non-robust
        CAS Processors. A fatal failure of a managed CAS Processor does not threaten the
        stability of the CPE.</p>
      
      <div class="figure"><a name="ugr.tug.cpe.fig.managed_deployment"></a><div class="figure-contents">
        
        <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="356"><tr><td><img src="images/tutorials_and_users_guides/tug.cpe/image020.png" width="356" alt="Managed deployment showing separate JVMs and CASes flowing between them"></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;2.3.&nbsp;CPE with Managed CAS Processors</b></p></div><br class="figure-break">
      
      <p>The CPE communicates with managed CAS Processors using the Vinci communication
        protocol. A CAS Processor is launched as a Vinci service and its
        <code class="literal">process()</code> method is invoked remotely via a Vinci command. The
        CPE uses its own internal VNS to support managed CAS processors. The VNS, by default,
        listens on port 9005. If this port is not available, the VNS will increment its listen
        port until it finds one that is available. All managed CAS Processors are internally
        configured to <span class="quote">&#8220;<span class="quote">talk</span>&#8221;</span> to the CPE managed VNS. This internal VNS is
        transparent to the end user launching the CPE.</p>
      
      <p>To deploy a managed CAS Processor, the CPE deployer must change the CPE
        descriptor. The following is a section from the CPE descriptor that shows an example
        configuration specifying a managed CAS Processor.</p>
      
      
      <pre class="programlisting">&lt;casProcessor <span class="bold-italic">deployment="local"</span> name="Meeting Detector TAE"&gt;
  &lt;descriptor&gt;
    &lt;include href="deploy/vinci/Deploy_MeetingDetectorTAE.xml"/&gt;
  &lt;/descriptor&gt;
  &lt;runInSeparateProcess&gt;
    &lt;exec dir="." executable="java"&gt;
      &lt;env key="CLASSPATH" 
         value="src;
                C:/Program Files/apache/uima/lib/uima-core.jar;
                C:/Program Files/apache/uima/lib/uima-cpe.jar;
                C:/Program Files/apache/uima/lib/uima-examples.jar;
                C:/Program Files/apache/uima/lib/uima-adapter-vinci.jar;
                C:/Program Files/apache/uima/lib/jVinci.jar"/&gt;
      &lt;arg&gt;-DLOG=C:/Temp/service.log&lt;/arg&gt;
      &lt;arg&gt;org.apache.uima.reference_impl.collection.
         service.vinci.VinciAnalysisEnginerService_impl&lt;/arg&gt;
      &lt;arg&gt;${descriptor}&lt;/arg&gt;
    &lt;/exec&gt;
  &lt;/runInSeparateProcess&gt;
  &lt;deploymentParameters/&gt;
  &lt;filter/&gt;
  &lt;errorHandling&gt;
    &lt;errorRateThreshold action="terminate" value="1/100"/&gt;
    &lt;maxConsecutiveRestarts action="terminate" value="3"/&gt;
    &lt;timeout max="100000"/&gt;
  &lt;/errorHandling&gt;
  &lt;checkpoint batch="10000"/&gt;
&lt;/casProcessor&gt;</pre>
      
      <p>See <a href="references.html#ugr.ref.xml.cpe_descriptor" class="olink">Chapter&nbsp;3, <i>Collection Processing Engine Descriptor Reference</i></a> for
        details and required settings.</p>
      
    </div>
    
    <div class="section" title="2.5.2.&nbsp;Deploying Non-managed CAS Processors"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cpe.deploying_nonmanaged_cas_processors">2.5.2.&nbsp;Deploying Non-managed CAS Processors</h3></div></div></div>
      
      
      <p>Non-managed CAS Processor deployment is shown in <a class="xref" href="#ugr.tug.cpe.fig.nonmanaged_cpe" title="Figure&nbsp;2.4.&nbsp;CPE with non-managed CAS Processors">Figure&nbsp;2.4, &#8220;CPE with non-managed CAS Processors&#8221;</a>. In non-managed mode, the CPE
        supports connectivity to CAS Processors running on local or remote computers using
        Vinci. Non-managed processors are different from managed processors in two
        aspects:
        
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Non-managed processors are neither started nor
          stopped by the CPE.</p></li><li class="listitem"><p>Non-managed processors use an independent VNS, also neither
            started nor stopped by the CPE. </p></li></ol></div>
      
      <div class="figure"><a name="ugr.tug.cpe.fig.nonmanaged_cpe"></a><div class="figure-contents">
        
        <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="475"><tr><td><img src="images/tutorials_and_users_guides/tug.cpe/image023.png" width="475" alt="Non-managed CPE deployment"></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;2.4.&nbsp;CPE with non-managed CAS Processors</b></p></div><br class="figure-break">
      
      <p>While non-managed CAS Processors provide the same level of fault isolation and
        robustness as managed CAS Processors, error recovery support for non-managed CAS
        Processors is much more limited. In particular, the CPE cannot restart a non-managed
        CAS Processor after an error.</p>
      
      <p>Non-managed CAS Processors also require a separate Vinci Naming Service
        running on the network. This VNS must be manually started and monitored by the end user
        or application. Instructions for running a VNS can be found in <a href="tutorials_and_users_guides.html#ugr.tug.application.vns.starting" class="olink">Section&nbsp;3.6.5.1, &#8220;Starting VNS&#8221;</a>.</p>
      
      <p>To deploy a non-managed CAS Processor, the CPE deployer must change the CPE
        descriptor. The following is a section from the CPE descriptor that shows an example
        configuration for the non-managed CAS Processor.</p>
      
      
      <pre class="programlisting">&lt;casProcessor <span class="bold-italic">deployment="remote"</span> name="Meeting Detector TAE"&gt;
  &lt;descriptor&gt;
    &lt;include href=
        "descriptors/vinciService/MeetingDetectorVinciService.xml"/&gt;
  &lt;/descriptor&gt;
  &lt;deploymentParameters/&gt;
  &lt;filter/&gt;
  &lt;errorHandling&gt;
    &lt;errorRateThreshold action="terminate" value="1/100"/&gt;
    &lt;maxConsecutiveRestarts action="terminate" value="3"/&gt;
    &lt;timeout max="100000"/&gt;
  &lt;/errorHandling&gt;
  &lt;checkpoint batch="10000"/&gt;
&lt;/casProcessor&gt;</pre>
      
      <p>See <a href="references.html#ugr.ref.xml.cpe_descriptor" class="olink">Chapter&nbsp;3, <i>Collection Processing Engine Descriptor Reference</i></a> for
        details and required settings.</p>
      
    </div>
    
    <div class="section" title="2.5.3.&nbsp;Deploying Integrated CAS Processors"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cpe.integrated_deployment">2.5.3.&nbsp;Deploying Integrated CAS Processors</h3></div></div></div>
      
      
      <p>Integrated CAS Processors are shown in <a class="xref" href="#ugr.tug.cpe.fig.integrated_deployment" title="Figure&nbsp;2.5.&nbsp;CPE with integrated CAS Processor">Figure&nbsp;2.5, &#8220;CPE with integrated CAS Processor&#8221;</a>. Here the CAS Processors
        run in the same JVM as the CPE, just like the Collection Reader and CAS Initializer.
        This deployment method results in minimal CAS communication and transport overhead
        as the CAS is shared in the same process space of the JVM. However, a CPE running with all
        integrated CAS Processors is limited in scalability by the capability of the single
        computer on which the CPE is running. There is also a stability risk associated with
        integrated processors because a poorly written CAS Processor can cause the JVM, and
        hence the entire CPE, to abort.</p>
      
      <div class="figure"><a name="ugr.tug.cpe.fig.integrated_deployment"></a><div class="figure-contents">
        
        <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="317"><tr><td><img src="images/tutorials_and_users_guides/tug.cpe/image026.png" width="317" alt="CPE with integrated CAS Processor"></td></tr></table></div>
      </div><p class="title"><b>Figure&nbsp;2.5.&nbsp;CPE with integrated CAS Processor</b></p></div><br class="figure-break">
      
      <p>The following is a section from a CPE descriptor that shows an example
        configuration for the integrated CAS Processor.</p>
      
      
      <pre class="programlisting">&lt;casProcessor <span class="bold-italic">deployment=<span class="quote">&#8220;<span class="quote">integrated</span>&#8221;</span></span> name=<span class="quote">&#8220;<span class="quote">Meeting Detector TAE</span>&#8221;</span>&gt;
  &lt;descriptor&gt;
    &lt;include href="descriptors/tutorial/ex4/MeetingDetectorTAE.xml"/&gt;
  &lt;/descriptor&gt;
  &lt;deploymentParameters/&gt;
  &lt;filter/&gt;
  &lt;errorHandling&gt;
    &lt;errorRateThreshold action="terminate" value="100/1000"/&gt;
    &lt;maxConsecutiveRestarts action="terminate" value="30"/&gt;
    &lt;timeout max="100000"/&gt;
  &lt;/errorHandling&gt;
  &lt;checkpoint batch="10000"/&gt;
&lt;/casProcessor&gt;</pre>
      
      <p>See <a href="references.html#ugr.ref.xml.cpe_descriptor" class="olink">Chapter&nbsp;3, <i>Collection Processing Engine Descriptor Reference</i></a> for
        details and required settings.</p>
      
    </div>
  </div>
  
  <div class="section" title="2.6.&nbsp;Collection Processing Examples"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.cpe.collection_processing_examples">2.6.&nbsp;Collection Processing Examples</h2></div></div></div>
    
    
    <p>The UIMA SDK includes a set of examples illustrating the three modes of deployment,
      integrated, managed, and non-managed. These are in the
      <code class="literal">/examples/descriptors/collection_processing_engine</code>
      directory. There are three CPE descriptors that run an example annotator (the Meeting
      Finder) in these modes.</p>
    
    <p>To run either the integrated or managed examples, use the
      <code class="literal">runCPE</code> script in the /bin directory of the UIMA installation,
      passing the appropriate CPE descriptor as an argument, or
      if you're using Eclipse and have the <code class="literal">uimaj-examples</code> project in your
    workspace, you can use the Eclipse Menu <span class="symbol">&#8594;</span> Run <span class="symbol">&#8594;</span> Run... <span class="symbol">&#8594;</span> and then pick the 
    launch configuration <span class="quote">&#8220;<span class="quote">UIMA Run CPE</span>&#8221;</span>.</p> 
    
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The <code class="literal">runCPE</code> script <span class="bold-italic"> must</span> 
    be run from the <code class="literal">%UIMA_HOME%\examples</code> directory, because the example
    CPE descriptors use relative path names that are resolved relative to this working directory. 
    For instance,
   
    </p><div class="literallayout"><p>runCPE<br>
descriptors\collection_processing_engine\MeetingFinderCPE_Integrated.xml</p></div>
    </div>
    
    
    
    <p>To run the non-managed example, there are some additional steps.
      
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Start a VNS service by running the
        <code class="literal">startVNS</code> script in the <code class="literal">/bin</code>
        directory, or using the Eclipse launcher <span class="quote">&#8220;<span class="quote">UIMA Start VNS</span>&#8221;</span>.</p></li><li class="listitem"><p>Deploy the Meeting Detector Analysis Engine as a Vinci service, by
          running the <code class="literal">startVinciService</code> script in the
          <code class="literal">/bin</code> directory or using the Eclipse launcher for this, and passing it the location of the
          descriptor to deploy, in this case
          <code class="literal">%UIMA_HOME%/examples/deploy/vinci/Deploy_MeetingDetectorTAE.xml</code>,
          or
      if you're using Eclipse and have the <code class="literal">uimaj-examples</code> project in your
    workspace, you can use the Eclipse Menu <span class="symbol">&#8594;</span> Run <span class="symbol">&#8594;</span> Run... <span class="symbol">&#8594;</span> and then pick the 
    launch configuration <span class="quote">&#8220;<span class="quote">UIMA Start Vinci Service</span>&#8221;</span>.
          </p></li><li class="listitem"><p>Now, run the runCPE script (or if in Eclipse, run the 
          launch configuration <span class="quote">&#8220;<span class="quote">UIMA Run CPE</span>&#8221;</span>), passing it the CPE for the non-managed
          version
          <code class="literal">(%UIMA_HOME%/examples/descriptors/collection_processing_engine/
            MeetingFinderCPE_NonManaged.xml</code>
          ). </p></li></ol></div>
    
    <p>This assumes that the Vinci Naming Service, the runCPE application, and the
      <code class="literal">MeetingDetectorTAE</code> service are all running on the same machine.
      Most of the scripts that need information about VNS will look for values to use in
      environment variables VNS_HOST and VNS_PORT; these default to
      <span class="quote">&#8220;<span class="quote">localhost</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">9000</span>&#8221;</span>. You may set these to appropriate
      values before running the scripts, as needed; you can also pass the name of the VNS host as
      the second argument to the startVinciService script.</p>
    
    <p>Alternatively, you can edit the scripts and/or the XML files to specify
      alternatives for the VNS_HOST and VNS_PORT. For instance, if the
      <code class="literal">runCPE</code> application is running on a different machine from the
      Vinci Naming Service, you can edit the
      <code class="literal">MeetingFinderCPE_NonManaged.xml</code> and change the vnsHost
      parameter:
      <code class="literal">&lt;parameter name="vnsHost"  value="localhost" type="string"/&gt;</code>
      to specify the VNS host instead of <span class="quote">&#8220;<span class="quote">localhost</span>&#8221;</span>.</p>
  </div>
  
<div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d4e1088" href="#d4e1088" class="para">4</a>] </sup>CAS Initializers are deprecated in favor of a more general mechanism,
    multiple subjects of analysis.</p></div><div class="footnote"><p><sup>[<a name="ftn.d4e1151" href="#d4e1151" class="para">5</a>] </sup>There is also a fourth pane,
        for the CAS Initializer, but it is hidden by default.  To enable it click the
        <code class="literal">View <span class="symbol">&#8594;</span> CAS Initializer Panel</code> menu item.</p></div><div class="footnote"><p><sup>[<a name="ftn.d4e1164" href="#d4e1164" class="para">6</a>] </sup>Replace
        <code class="literal">%UIMA_HOME%</code> with the path to where you installed UIMA.</p>
        </div></div></div>
  <div class="chapter" title="Chapter&nbsp;3.&nbsp;Application Developer's Guide" id="ugr.tug.application"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;3.&nbsp;Application Developer's Guide</h2></div></div></div>
  
  
  <p>This chapter describes how to develop an application using the Unstructured Information Management
    Architecture (UIMA). The term <span class="emphasis"><em>application</em></span> describes a program that provides end-user
    functionality. A UIMA application incorporates one or more UIMA components such as Analysis Engines,
    Collection Processing Engines, a Search Engine, and/or a Document Store and adds application-specific logic
    and user interfaces.</p>
  
  <div class="section" title="3.1.&nbsp;The UIMAFramework Class"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.appication.uimaframework_class">3.1.&nbsp;The UIMAFramework Class</h2></div></div></div>
    
    
    <p>An application developer's starting point for accessing UIMA framework functionality is the
      <code class="literal">org.apache.uima.UIMAFramework</code> class. The following is a short introduction to some
      important methods on this class. Several of these methods are used in examples in the rest of this chapter. For
      more details, see the Javadocs (in the docs/api directory of the UIMA SDK).
      
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p>UIMAFramework.getXMLParser(): Returns an instance of the UIMA XML Parser class, which then can be
            used to parse the various types of UIMA component descriptors. Examples of this can be found in the
            remainder of this chapter.</p>
        </li><li class="listitem">
          <p>UIMAFramework.produceXXX(ResourceSpecifier): There are various produce methods that are used
            to create different types of UIMA components from their descriptors. The argument type,
            ResourceSpecifier, is the base interface that subsumes all types of component descriptors in UIMA. You
            can get a ResourceSpecifier from the XMLParser. Examples of produce methods are:
            
            </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
                <p>produceAnalysisEngine</p>
              </li><li class="listitem">
                <p>produceCasConsumer</p>
              </li><li class="listitem">
                <p>produceCasInitializer</p>
              </li><li class="listitem">
                <p>produceCollectionProcessingEngine</p>
              </li><li class="listitem">
                <p>produceCollectionReader</p>
              </li></ul></div><p>
            There are other variations of each of these methods that take additional, optional arguments. See the
            Javadocs for details. </p>
        </li><li class="listitem">
          <p>UIMAFramework.getLogger(&lt;optional-logger-name&gt;): Gets a reference to the UIMA Logger,
            to which you can write log messages. If no logger name is passed, the name of the returned logger instance
            is <span class="quote">&#8220;<span class="quote">org.apache.uima</span>&#8221;</span>.</p>
        </li><li class="listitem">
          <p>UIMAFramework.getVersionString(): Gets the number of the UIMA version you are using.</p>
        </li><li class="listitem">
          <p>UIMAFramework.newDefaultResourceManager(): Gets an instance of the UIMA ResourceManager. The
            key method on ResourceManager is setDataPath, which allows you to specify the location where UIMA
            components will go to look for their external resource files. Once you've obtained and initialized a
            ResourceManager, you can pass it to any of the produceXXX methods. </p>
        </li></ul></div>
    
  </div>
  
  <div class="section" title="3.2.&nbsp;Using Analysis Engines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.application.using_aes">3.2.&nbsp;Using Analysis Engines</h2></div></div></div>
    
    
    <p>This section describes how to add analysis capability to your application by using Analysis Engines
      developed using the UIMA SDK. An <span class="emphasis"><em>Analysis Engine (AE)</em></span> is a component that analyzes
      artifacts (e.g. documents) and infers information about them.</p>
    
    <p>An Analysis Engine consists of two parts - Java classes (typically packaged as one or more JAR files) and
      <span class="emphasis"><em>AE descriptors</em></span> (one or more XML files). You must put the Java classes in your
      application's class path, but thereafter you will not need to directly interact with them. The UIMA
      framework insulates you from this by providing a standard AnalysisEngine interfaces.</p>
    
    <p>The term <span class="emphasis"><em>Text Analysis Engine (TAE)</em></span> is sometimes used to describe an Analysis
      Engine that analyzes a text document. In the UIMA SDK v1.x, there was a TextAnalysisEngine interface that was
      commonly used. However, as of the UIMA SDK v2.0, this interface has been deprecated and all applications should
      switch to using the standard AnalysisEngine interface.</p>
    
    <p>The AE descriptor XML files contain the configuration settings for the Analysis Engine as well as a
      description of the AE's input and output requirements. You may need to edit these files in order to
      configure the AE appropriately for your application - the supplier of the AE may have provided documentation
      (or comments in the XML descriptor itself) about how to do this.</p>
    
    <div class="section" title="3.2.1.&nbsp;Instantiating an Analysis Engine"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.application.instantiating_an_ae">3.2.1.&nbsp;Instantiating an Analysis Engine</h3></div></div></div>
      
      
      <p>The following code shows how to instantiate an AE from its XML descriptor:
        
        
        </p><pre class="programlisting">  //get Resource Specifier from XML file
XMLInputSource in = new XMLInputSource("MyDescriptor.xml");
ResourceSpecifier specifier = 
    UIMAFramework.getXMLParser().parseResourceSpecifier(in);

  //create AE here
AnalysisEngine ae = 
    UIMAFramework.produceAnalysisEngine(specifier);</pre>
      
      <p>The first two lines parse the XML descriptor (for AEs with multiple descriptor files, one of them is the
        <span class="quote">&#8220;<span class="quote">main</span>&#8221;</span> descriptor - the AE documentation should indicate which it is). The result of the parse
        is a <code class="literal">ResourceSpecifier</code> object. The third line of code invokes a static factory method
        <code class="literal">UIMAFramework.produceAnalysisEngine</code>, which takes the specifier and instantiates
        an <code class="literal">AnalysisEngine</code> object.</p>
      
      <p>There is one caveat to using this approach - the Analysis Engine instance that you create will not support
        multiple threads running through it concurrently. If you need to support this, see <a class="xref" href="#ugr.tug.applications.multi_threaded" title="3.2.5.&nbsp;Multi-threaded Applications">Section&nbsp;3.2.5, &#8220;Multi-threaded Applications&#8221;</a>.</p>
      
    </div>
    
    <div class="section" title="3.2.2.&nbsp;Analyzing Text Documents"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.application.analyzing_text_documents">3.2.2.&nbsp;Analyzing Text Documents</h3></div></div></div>
      
      
      <p>There are two ways to use the AE interface to analyze documents. You can either use the
        <span class="emphasis"><em>JCas</em></span> interface, which is described in detail by <a href="references.html#ugr.ref.jcas" class="olink">Chapter&nbsp;5, <i>JCas Reference</i></a> or you can directly use the
        <span class="emphasis"><em>CAS</em></span> interface, which is described in detail in <a href="references.html#ugr.ref.cas" class="olink">Chapter&nbsp;4, <i>CAS Reference</i></a>. Besides text documents, other kinds of
        artifacts can also be analyzed; see <a href="tutorials_and_users_guides.html#ugr.tug.aas" class="olink">Chapter&nbsp;5, <i>Annotations, Artifacts, and Sofas</i></a> for more information.</p>
      
      <p>The basic structure of your application will look similar in both cases:</p>
      
      <p>Using the JCas
        
        
        </p><pre class="programlisting">  //create a JCas, given an Analysis Engine (ae)
JCas jcas = ae.newJCas();
  
  //analyze a document
jcas.setDocumentText(doc1text);
ae.process(jcas);
doSomethingWithResults(jcas);
jcas.reset();
  
  //analyze another document
jcas.setDocumentText(doc2text);
ae.process(jcas);
doSomethingWithResults(jcas);
jcas.reset();
...
  //done
ae.destroy();</pre>
      
      <p>Using the CAS
        
        
        </p><pre class="programlisting">//create a CAS
CAS aCasView = ae.newCAS();

//analyze a document
aCasView.setDocumentText(doc1text);
ae.process(aCasView);
doSomethingWithResults(aCasView);
aCasView.reset();

//analyze another document
aCasView.setDocumentText(doc2text);
ae.process(aCasView);
doSomethingWithResults(aCasView);
aCasView.reset();
...
//done
ae.destroy();</pre>
      
      <p>First, you create the CAS or JCas that you will use. Then, you repeat the following four steps for each
        document:</p>
      
      <div class="orderedlist"><ol class="orderedlist" type="1" compact><li class="listitem">
          <p>Put the document text into the CAS or JCas.</p>
        </li><li class="listitem">
          <p>Call the AE's process method, passing the CAS or JCas as an argument</p>
        </li><li class="listitem">
          <p>Do something with the results that the AE has added to the CAS or JCas</p>
        </li><li class="listitem">
          <p>Call the CAS's or JCas's reset() method to prepare for another analysis </p>
        </li></ol></div>
      
    </div>
    
    <div class="section" title="3.2.3.&nbsp;Analyzing Non-Text Artifacts"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.applications.analyzing_non_text_artifacts">3.2.3.&nbsp;Analyzing Non-Text Artifacts</h3></div></div></div>
      
      
      <p>Analyzing non-text artifacts is similar to analyzing text documents. The main difference is that
        instead of using the <code class="literal">setDocumentText</code> method, you need to use the Sofa APIs to set the
        artifact into the CAS. See <a href="tutorials_and_users_guides.html#ugr.tug.aas" class="olink">Chapter&nbsp;5, <i>Annotations, Artifacts, and Sofas</i></a>
        for details.</p>
      
    </div>
    <div class="section" title="3.2.4.&nbsp;Accessing Analysis Results"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.applications.accessing_analysis_results">3.2.4.&nbsp;Accessing Analysis Results</h3></div></div></div>
      
      <p>Annotators (and applications) access the results of analysis via the CAS, using the CAS or JCas
        interfaces. These results are accessed using the CAS Indexes. There is one built-in index for instances of
        the built-in type <code class="literal">uima.tcas.Annotation</code> that can be used to retrieve instances of
        <code class="literal">Annotation</code> or any subtype of Annotation. You can also define additional indexes over
        other types. </p>
      <p>Indexes provide a method to obtain an iterators over their contents; the iterator returns the matching
        elements one at time from the CAS.</p>
      
      <div class="section" title="3.2.4.1.&nbsp;Accessing Analysis Results using the JCas"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.applications.accessing_results_using_jcas">3.2.4.1.&nbsp;Accessing Analysis Results using the JCas</h4></div></div></div>
        
        
        <p>See:</p>
        
        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p> <a href="tutorials_and_users_guides.html#ugr.tug.aae.reading_results_previous_annotators" class="olink">Section&nbsp;1.3.3, &#8220;Reading the Results of Previous Annotators&#8221;</a> </p>
          </li><li class="listitem">
            <p> <a href="references.html#ugr.ref.jcas" class="olink">Chapter&nbsp;5, <i>JCas Reference</i></a></p>
          </li><li class="listitem">
            <p>The Javadocs for <code class="literal">org.apache.uima.jcas.JCas</code>. </p>
          </li></ul></div>
        
      </div>
      
      <div class="section" title="3.2.4.2.&nbsp;Accessing Analysis Results using the CAS"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.application.accessing_results_using_cas">3.2.4.2.&nbsp;Accessing Analysis Results using the CAS</h4></div></div></div>
        
        
        <p>See:</p>
        
        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p> <a href="references.html#ugr.ref.cas" class="olink">Chapter&nbsp;4, <i>CAS Reference</i></a></p>
          </li><li class="listitem">
            <p> The source code for <code class="literal">org.apache.uima.examples.PrintAnnotations</code>, which
              is in <code class="literal">examples\src.</code></p>
          </li><li class="listitem">
            <p>The Javadocs for the <code class="literal">org.apache.uima.cas</code> and
              <code class="literal">org.apache.uima.cas.text</code> packages. </p>
          </li></ul></div>
      </div>
    </div>
    
    <div class="section" title="3.2.5.&nbsp;Multi-threaded Applications"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.applications.multi_threaded">3.2.5.&nbsp;Multi-threaded Applications</h3></div></div></div>
      
      
      <p>The simplest way to use an AE in a multi-threaded environment is to use the Java synchronized keyword to
        ensure that only one thread is using an AE at any given time. For example:
        
        
        </p><pre class="programlisting">public class MyApplication {
  private AnalysisEngine mAnalysisEngine;
  private CAS mCAS;

  public MyApplication() {
    //get Resource Specifier from XML file
    XMLInputSource in = new XMLInputSource("MyDescriptor.xml");
    ResourceSpecifier specifier = 
        UIMAFramework.getXMLParser().parseResourceSpecifier(in);
 
    //create Analysis Engine here
    mAnalysisEngine = UIMAFramework.produceAnalysisEngine(specifier);
    mCAS = mAnalysisEngine.newCAS();
  }

  // Assume some other part of your multi-threaded application could
  // call <span class="quote">&#8220;<span class="quote">analyzeDocument</span>&#8221;</span> on different threads, asynchronusly

  public synchronized void analyzeDocument(String aDoc) {
    //analyze a document
    mCAS.setDocumentText(aDoc);
    mAnalysisEngine.process();  
    doSomethingWithResults(mCAS);
    mCAS.reset();
  }
  ...
}</pre>
      
      <p>Without the synchronized keyword, this application would not be thread-safe. If multiple threads
        called the analyzeDocument method simultaneously, they would both use the same CAS and clobber each others'
        results. The synchronized keyword ensures that no more than one thread is executing this method at any given
        time. For more information on thread synchronization in Java, see <a class="ulink" href="http://java.sun.com/docs/books/tutorial/essential/threads/multithreaded.html" target="_top">http://java.sun.com/docs/books/tutorial/essential/threads/multithreaded.html</a>
        .</p>
      
      <p>The synchronized keyword ensures thread-safety, but does not allow you to process more than one
        document at a time. If you need to process multiple documents simultaneously (for example, to make use of a
        multiprocessor machine), you'll need to use more than one CAS instance.</p>
      
      <p>Because CAS instances use memory and can take some time to construct, you don't want to create a new CAS
        instance for each request. Instead, you should use a feature of the UIMA SDK called the <span class="emphasis"><em>CAS
        Pool</em></span>, implemented by the type <code class="literal">CasPool</code>.</p>
      
      <p>A CAS Pool contains some number of CAS instances (you specify how many when you create the pool). When a
        thread wants to use a CAS, it <span class="emphasis"><em>checks out</em></span> an instance from the pool. When the thread is
        done using the CAS, it must <span class="emphasis"><em>release</em></span> the CAS instance back into the pool. If all
        instances are checked out, additional threads will block and wait for an instance to become available. Here
        is some example code:
        
        
        </p><pre class="programlisting">public class MyApplication {
  private CasPool mCasPool;
  
  private AnalysisEngine mAnalysisEngine;
  
  public MyApplication()
  {
    //get Resource Specifier from XML file
    XMLInputSource in = new XMLInputSource("MyDescriptor.xml");
    ResourceSpecifier specifier = 
      UIMAFramework.getXMLParser().parseResourceSpecifier(in);
 
    //Create multithreadable AE that will 
    //Accept 3 simultaneous requests
    //The 3rd parameter specifies a timeout.
    //When the number of simultaneous requests exceeds 3,
    // additional requests will wait for other requests to finish. 
    // This parameter determines the maximum number of milliseconds 
    // that a new request should wait before throwing an
    // - a value of 0 will cause them to wait forever.
    mAnalysisEngine = UIMAFramework.produceAnalysisEngine(specifier,3,0);

    //create CAS pool with 3 CAS instances
    mCasPool = new CasPool(3, mAnalysisEngine);
  }

  public void analyzeDocument(String aDoc) {
    //check out a CAS instance (argument 0 means no timeout)
    CAS cas = mCasPool.getCas(0);  
    try {
      //analyze a document 
      cas.setDocumentText(aDoc);   
      mAnalysisEngine.process(cas);  
      doSomethingWithResults(cas);
    } finally {
      //MAKE SURE we release the CAS instance
      mCasPool.releaseCas(cas);  
    }
  }
  ...
}</pre>
      
      <p>There is not much more code required here than in the previous example. First, there is one additional
        parameter to the AnalysisEngine producer, specifying the number of annotator instances to
        create<sup>[<a name="d4e1694" href="#ftn.d4e1694" class="footnote">7</a>]</sup>. Then, instead of creating a
        single CAS in the constructor, we now create a CasPool containing 3 instances. In the analyze method, we check
        out a CAS, use it, and then release it.</p> <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
      <p>Frequently, the two numbers (number of CASes, and the number of AEs) will be the same. It would not make
        sense to have the number of CASes less than the number of AEs
        &#8211; the extra AE instances would always block waiting for a CAS from the pool. It could make sense to have
        additional CASes, though &#8211; if you had other multi-threaded processes that were using the CASes, other
        than the AEs. </p> </div>
      
      <p>The getCAS() method returns a CAS which is not specialized to any particular subject of analysis. To
        process things other than this, please refer to <a href="tutorials_and_users_guides.html#ugr.tug.aas" class="olink">Chapter&nbsp;5, <i>Annotations, Artifacts, and Sofas</i></a> .</p>
      
      <p>Note the use of the try...finally block. This is very important, as it ensures that the CAS we have checked
        out will be released back into the pool, even if the analysis code throws an exception. You should always use
        try...finally when using the CAS pool; if you do not, you risk exhausting the pool and causing
        deadlock.</p>
      
      <p>The parameter 0 passed to the CasPool.getCas() method is a timeout value. If this is set to a positive
        integer, it is the maximum number of milliseconds that the thread will wait for an instance to become
        available in the pool. If this time elapses, the getCas method will return null, and the application can do
        something intelligent, like ask the user to try again later. A value of 0 will cause the thread to wait for an
        available CAS, potentially forever.</p>
    </div>
    
    <div class="section" title="3.2.6.&nbsp;Using Multiple Analysis Engines and Creating Shared CASes"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.application.using_multiple_aes">3.2.6.&nbsp;Using Multiple Analysis Engines and Creating Shared CASes</h3></div></div></div>
      
      
      
      <p>In most cases, the easiest way to use multiple Analysis Engines from within an application is to combine
        them into an aggregate AE. For instructions, see <a href="tutorials_and_users_guides.html#ugr.tug.aae.building_aggregates" class="olink">Section&nbsp;1.3, &#8220;Building Aggregate Analysis Engines&#8221;</a>. Be sure that you understand this method before
        deciding to use the more advanced feature described in this section.</p>
      
      <p>If you decide that your application does need to instantiate multiple AEs and have those AEs share a
        single CAS, then you will no longer be able to use the various methods on the
        <code class="literal">AnalysisEngine</code> class that create CASes (or JCases) to create your CAS. This is because
        these methods create a CAS with a data model specific to a single AE and which therefore cannot be shared by
        other AEs. Instead, you create a CAS as follows:</p>
      
      <p>Suppose you have two analysis engines, and one CAS Consumer, and you want to create one type system from
        the merge of all of their type specifications. Then you can do the following:</p>
      
      
      <pre class="programlisting">AnalysisEngineDescription aeDesc1 =
  UIMAFramework.getXMLParser().parseAnalysisEngineDescription(...);
  
  AnalysisEngineDescription aeDesc2 =
  UIMAFramework.getXMLParser().parseAnalysisEngineDescription(...);

  CasConsumerDescription ccDesc =
  UIMAFramework.getXMLParser().parseCasConsumerDescription(...);

  List list = new ArrayList();

  list.add(aeDesc1);
  list.add(aeDesc2);
  list.add(ccDesc);

  CAS cas = CasCreationUtils.createCas(list);

  // (optional, if using the JCas interface) 
  JCas jcas = cas.getJCas();</pre>
      
      <p>The CasCreationUtils class takes care of the work of merging the AEs' type systems and producing a
        CAS for the combined type system. If the type systems are not compatible, an exception will be thrown.</p>
      
    </div>
    
    <div class="section" title="3.2.7.&nbsp;Saving CASes to file systems"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.application.saving_cases_to_file_systems">3.2.7.&nbsp;Saving CASes to file systems</h3></div></div></div>
      
      
      <p>The UIMA framework provides APIs to save and restore the contents of a CAS to streams. The CASes are stored
        in an XML format. There are two forms of this format. The preferred form is the XMI form (see <a href="tutorials_and_users_guides.html#ugr.tug.xmi_emf.using_xmi_cas_serialization" class="olink">Section&nbsp;8.3, &#8220;Using XMI CAS Serialization&#8221;</a>). An older format is also available,
        called XCAS.</p>
      
      <p>To save an XMI representation of a CAS, use the <code class="literal">serialize</code> method of the class
        <code class="literal">org.apache.uima.util.XmlCasSerializer</code>. To save an XCAS representation of a CAS,
        use the class <code class="literal">org.apache.uima.cas.impl.XCASSerializer</code> instead; see the Javadocs
        for details.</p>
      
      <p>Both of these external forms can be read back in, using the <code class="literal">deserialize</code> method of
        the class <code class="literal">org.apache.uima.util.XmlCasDeserializer</code>. This method deserializes
        into a pre-existing CAS, which you must create ahead of time, pre-set-up with the proper type system. See the
        Javadocs for details.</p>
    </div>
  </div>
  
  <div class="section" title="3.3.&nbsp;Using Collection Processing Engines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.application.using_cpes">3.3.&nbsp;Using Collection Processing Engines</h2></div></div></div>
    
    
    <p>A <span class="emphasis"><em>Collection Processing Engine (CPE)</em></span> processes collections of artifacts
      (documents) through the combination of the following components: a Collection Reader, an optional CAS
      Initializer, Analysis Engines, and CAS Consumers. Collection Processing Engines and their components are
      described in <a href="tutorials_and_users_guides.html#ugr.tug.cpe" class="olink">Chapter&nbsp;2, <i>Collection Processing Engine Developer's Guide</i></a> .</p>
    
    <p>Like Analysis Engines, CPEs consist of a set of Java classes and a set of descriptors. You need to make sure
      the Java classes are in your classpath, but otherwise you only deal with descriptors.</p>
    
    <div class="section" title="3.3.1.&nbsp;Running a Collection Processing Engine from a Descriptor"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.application.running_a_cpe_from_a_descriptor">3.3.1.&nbsp;Running a Collection Processing Engine from a Descriptor</h3></div></div></div>
      
      
      
      <p><a href="tutorials_and_users_guides.html#ugr.tug.cpe.running_cpe_from_application" class="olink">Section&nbsp;2.3, &#8220;Running a CPE from Your Own Java Application&#8221;</a> describes how to use the APIs to read a CPE
        descriptor and run it from an application.</p>
      
    </div>
    
    <div class="section" title="3.3.2.&nbsp;Configuring a Collection Processing Engine Descriptor Programmatically"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.application.configuring_a_cpe_descriptor_programmatically">3.3.2.&nbsp;Configuring a Collection Processing Engine Descriptor Programmatically</h3></div></div></div>
      
      
      
      <p>For the finest level of control over the CPE descriptor settings, the CPE offers programmatic access to
        the descriptor via an API. With this API, a developer can create a complete descriptor and then save the result
        to a file. This also can be used to read in a descriptor (using XMLParser.parseCpeDescription as shown in the
        previous section), modify it, and write it back out again. The CPE Descriptor API allows a developer to
        redefine default behavior related to error handling for each component, turn-on check-pointing, change
        performance characteristics of the CPE, and plug-in a custom timer.</p>
      
      <p>Below is some example code that illustrates how this works. See the Javadocs for package
        org.apache.uima.collection.metadata for more details.</p>
      
      
      <pre class="programlisting">//Creates descriptor with default settings
CpeDescription cpe = CpeDescriptorFactory.produceDescriptor();

//Add CollectionReader 
cpe.addCollectionReader([descriptor]);

//Add CasInitializer (deprecated)
cpe.addCasInitializer(&lt;cas initializer descriptor&gt;);

// Provide the number of CASes the CPE will use
cpe.setCasPoolSize(2);

//  Define and add Analysis Engine 
CpeIntegratedCasProcessor personTitleProcessor = 
   CpeDescriptorFactory.produceCasProcessor (<span class="quote">&#8220;<span class="quote">Person</span>&#8221;</span>);

// Provide descriptor for the Analysis Engine
personTitleProcessor.setDescriptor([descriptor]);

//Continue, despite errors and skip bad Cas
personTitleProcessor.setActionOnMaxError(<span class="quote">&#8220;<span class="quote">continue</span>&#8221;</span>);

  //Increase amount of time in ms the CPE waits for response
//from this Analysis Engine
personTitleProcessor.setTimeout(100000);

//Add Analysis Engine to the descriptor
cpe.addCasProcessor(personTitleProcessor);
                                
//  Define and add CAS Consumer
CpeIntegratedCasProcessor consumerProcessor = 
CpeDescriptorFactory.produceCasProcessor(<span class="quote">&#8220;<span class="quote">Printer</span>&#8221;</span>);
consumerProcessor.setDescriptor([descriptor]);

//Define batch size
consumerProcessor.setBatchSize(100);

//Terminate CPE on max errors
consumerProcessor.setActionOnMaxError(<span class="quote">&#8220;<span class="quote">terminate</span>&#8221;</span>);

//Add CAS Consumer to the descriptor
cpe.addCasProcessor(consumerProcessor);

//  Add Checkpoint file and define checkpoint frequency (ms)
cpe.setCheckpoint(<span class="quote">&#8220;<span class="quote">[path]/checkpoint.dat</span>&#8221;</span>, 3000);

//  Plug in custom timer class used for timing events
cpe.setTimer(<span class="quote">&#8220;<span class="quote">org.apache.uima.internal.util.JavaTimer</span>&#8221;</span>);

//  Define number of documents to process
cpe.setNumToProcess(1000);

//  Dump the descriptor to the System.out
((CpeDescriptionImpl)cpe).toXML(System.out);</pre>
      
      <p>The CPE descriptor for the above configuration looks like this:
        
        
        </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;cpeDescription xmlns="http://uima.apache.org/resourceSpecifier"&gt;
  &lt;collectionReader&gt;
    &lt;collectionIterator&gt;
      &lt;descriptor&gt;
        &lt;include href="[descriptor]"/&gt;
      &lt;/descriptor&gt;
      &lt;configurationParameterSettings&gt;...
      &lt;/configurationParameterSettings&gt;
    &lt;/collectionIterator&gt;

    &lt;casInitializer&gt;
      &lt;descriptor&gt;
        &lt;include href="[descriptor]"/&gt;
      &lt;/descriptor&gt;
      &lt;configurationParameterSettings&gt;...
      &lt;/configurationParameterSettings&gt;
    &lt;/casInitializer&gt;
  &lt;/collectionReader&gt;

  &lt;casProcessors casPoolSize="2" processingUnitThreadCount="1"&gt;
    &lt;casProcessor deployment="integrated" name="Person"&gt;
      &lt;descriptor&gt;
        &lt;include href="[descriptor]"/&gt;
      &lt;/descriptor&gt;
      &lt;deploymentParameters/&gt;
      &lt;errorHandling&gt;
        &lt;errorRateThreshold action="terminate" value="100/1000"/&gt;
        &lt;maxConsecutiveRestarts action="terminate" value="30"/&gt;
        &lt;timeout max="100000"/&gt;
      &lt;/errorHandling&gt;
      &lt;checkpoint batch="100" time="1000ms"/&gt;
    &lt;/casProcessor&gt;

    &lt;casProcessor deployment="integrated" name="Printer"&gt;
      &lt;descriptor&gt;
        &lt;include href="[descriptor]"/&gt;
      &lt;/descriptor&gt;
      &lt;deploymentParameters/&gt;
      &lt;errorHandling&gt;
        &lt;errorRateThreshold action="terminate"
          value="100/1000"/&gt;
        &lt;maxConsecutiveRestarts action="terminate"
          value="30"/&gt;
        &lt;timeout max="100000" default="-1"/&gt;
      &lt;/errorHandling&gt;
      &lt;checkpoint batch="100" time="1000ms"/&gt;
    &lt;/casProcessor&gt;
  &lt;/casProcessors&gt;

  &lt;cpeConfig&gt;
    &lt;numToProcess&gt;1000&lt;/numToProcess&gt;
    &lt;deployAs&gt;immediate&lt;/deployAs&gt;
    &lt;checkpoint file="[path]/checkpoint.dat" time="3000ms"/&gt;
    &lt;timerImpl&gt;
      org.apache.uima.reference_impl.util.JavaTimer
    &lt;/timerImpl&gt;
  &lt;/cpeConfig&gt;
&lt;/cpeDescription&gt;</pre>
      
    </div>
  </div>
  
  <div class="section" title="3.4.&nbsp;Setting Configuration Parameters"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.application.setting_configuration_parameters">3.4.&nbsp;Setting Configuration Parameters</h2></div></div></div>
    
    
    <p>Configuration parameters can be set using APIs as well as configured using the XML descriptor metadata
      specification (see <a href="tutorials_and_users_guides.html#ugr.tug.aae.configuration_parameters" class="olink">Section&nbsp;1.2.1, &#8220;Configuration Parameters&#8221;</a>.</p>
    
    <p>There are two different places you can set the parameters via the APIs.</p>
    
    <div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
        <p>After reading the XML descriptor for a component, but before you produce the component itself,
          and</p>
      </li><li class="listitem">
        <p>After the component has been produced. </p>
      </li></ul></div>
    
    <p>Setting the parameters before you produce the component is done using the
      ConfigurationParameterSettings object. You get an instance of this for a particular component by accessing
      that component description's metadata. For instance, if you produced a component description by using
      <code class="literal">UIMAFramework.getXMLParser().parse...</code> method, you can use that component
      description's getMetaData() method to get the metadata, and then the metadata's
      getConfigurationParameterSettings method to get the ConfigurationParameterSettings object. Using that
      object, you can set individual parameters using the setParameterValue method. Here's an example, for a
      CAS Consumer component:
      
      
      </p><pre class="programlisting">// Create a description object by reading the XML for the descriptor

CasConsumerDescription casConsumerDesc =  
   UIMAFramework.getXMLParser().parseCasConsumerDescription(new
     XMLInputSource("descriptors/cas_consumer/InlineXmlCasConsumer.xml"));

// get the settings from the metadata
ConfigurationParameterSettings consumerParamSettings =
    casConsumerDesc.getMetaData().getConfigurationParameterSettings();

// Set a parameter value
consumerParamSettings.setParameterValue(
  InlineXmlCasConsumer.PARAM_OUTPUTDIR,
  outputDir.getAbsolutePath());</pre>
    
    <p>Then you might produce this component using:
      
      
      </p><pre class="programlisting">CasConsumer component =
  UIMAFramework.produceCasConsumer(casConsumerDesc);</pre>
    
    <p>A side effect of producing a component is calling the component's <span class="quote">&#8220;<span class="quote">initialize</span>&#8221;</span> method,
      allowing it to read its configuration parameters. If you want to change parameters after this, use
      
      
      </p><pre class="programlisting">component.setConfigParameterValue(
    <span class="quote">&#8220;<span class="quote">&lt;parameter-name&gt;</span>&#8221;</span>,
    <span class="quote">&#8220;<span class="quote">&lt;parameter-value&gt;</span>&#8221;</span>);</pre><p>
      and then signal the component to re-read its configuration by calling the component's reconfigure method:
      
      </p><pre class="programlisting">component.reconfigure();</pre>
    
    <p>Although these examples are for a CAS Consumer component, the parameter APIs also work for other kinds of
      components.</p>
  </div>
  
  <div class="section" title="3.5.&nbsp;Integrating Text Analysis and Search"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.application.integrating_text_analysis_and_search">3.5.&nbsp;Integrating Text Analysis and Search</h2></div></div></div>
    
    
    <p>The UIMA SDK on IBM's alphaWorks <a class="ulink" href="http://www.alphaworks.ibm.com/tech/uima" target="_top">http://www.alphaworks.ibm.com/tech/uima</a> includes a
      semantic search engine that you can use to build a search index that includes the results of the analysis done by
      your AE. This combination of AEs with a search engine capable of indexing both words and annotations over spans
      of text enables what UIMA refers to as <span class="emphasis"><em>semantic search</em></span>. Over time we expect to provide
      additional information on integrating other open source search engines.</p>
    
    <p>Semantic search is a search where the semantic intent of the query is specified using one or more entity or
      relation specifiers. For example, one could specify that they are looking for a person (named)
      <span class="quote">&#8220;<span class="quote">Bush.</span>&#8221;</span> Such a query would then not return results about the kind of bushes that grow in your
      garden.</p>
    
    <div class="section" title="3.5.1.&nbsp;Building an Index"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.application.building_an_index">3.5.1.&nbsp;Building an Index</h3></div></div></div>
      
      
      <p>To build a semantic search index using the UIMA SDK, you run a Collection Processing Engine that includes
        your AE along with a CAS Consumer which takes the tokens and annotatitions, together with sentence
        boundaries, and feeds them to a semantic searcher's index term input. The alphaWorks semantic search
        component includes a CAS Consumer called the <span class="emphasis"><em>Semantic Search CAS Indexer</em></span> that does
        this; this component is available from the alphaWorks site. Your AE must include an annotator that produces
        Tokens and Sentence annotations, along with any <span class="quote">&#8220;<span class="quote">semantic</span>&#8221;</span> annotations, because the
        Indexer requires this. The Semantic Search CAS Indexer's descriptor is located here:
        <code class="literal">examples/descriptors/cas_consumer/SemanticSearchCasIndexer.xml</code> .</p>
      
      <div class="section" title="3.5.1.1.&nbsp;Configuring the Semantic Search CAS Indexer"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.application.search.configuring_indexer">3.5.1.1.&nbsp;Configuring the Semantic Search CAS Indexer</h4></div></div></div>
        
        
        <p>Since there are several ways you might want to build a search index from the information in the CAS
          produced by your AE, you need to supply the Semantic Search CAS Consumer &#8211; Indexer with
          configuration information in the form of an <span class="emphasis"><em>Index Build Specification</em></span> file.
          Apache UIMA includes code for parsing Index Build Specification files (see the Javadocs for details). An
          example of an Indexing specification tailored to the AE from the tutorial in the <a href="tutorials_and_users_guides.html#ugr.tug.aae" class="olink">Chapter&nbsp;1, <i>Annotator and Analysis Engine Developer's Guide</i></a> is located in
          <code class="literal">examples/descriptors/tutorial/search/MeetingIndexBuildSpec.xml</code> . It looks
          like this:
          
          
          </p><pre class="programlisting">&lt;indexBuildSpecification&gt;
  &lt;indexBuildItem&gt;
    &lt;name&gt;org.apache.uima.examples.tokenizer.Token&lt;/name&gt;
    &lt;indexRule&gt;
      &lt;style name="Term"/&gt;
    &lt;/indexRule&gt;    
  &lt;/indexBuildItem&gt;
  &lt;indexBuildItem&gt;
    &lt;name&gt;org.apache.uima.examples.tokenizer.Sentence&lt;/name&gt;
    &lt;indexRule&gt;
      &lt;style name="Breaking"/&gt;
    &lt;/indexRule&gt;    
  &lt;/indexBuildItem&gt;
  &lt;indexBuildItem&gt;
    &lt;name&gt;org.apache.uima.tutorial.Meeting&lt;/name&gt;
    &lt;indexRule&gt;
      &lt;style name="Annotation"/&gt;
    &lt;/indexRule&gt;    
  &lt;/indexBuildItem&gt;
  &lt;indexBuildItem&gt;
    &lt;name&gt;org.apache.uima.tutorial.RoomNumber&lt;/name&gt;
    &lt;indexRule&gt;
      &lt;style name="Annotation"&gt;
        &lt;attributeMappings&gt;
          &lt;mapping&gt;
            &lt;feature&gt;building&lt;/feature&gt;
            &lt;indexName&gt;building&lt;/indexName&gt;
          &lt;/mapping&gt;
        &lt;/attributeMappings&gt;
      &lt;/style&gt;
    &lt;/indexRule&gt;    
  &lt;/indexBuildItem&gt;
  &lt;indexBuildItem&gt;
    &lt;name&gt;org.apache.uima.tutorial.DateAnnot&lt;/name&gt;
    &lt;indexRule&gt;
      &lt;style name="Annotation"/&gt;
    &lt;/indexRule&gt;    
  &lt;/indexBuildItem&gt;
  &lt;indexBuildItem&gt;
    &lt;name&gt;org.apache.uima.tutorial.TimeAnnot&lt;/name&gt;
    &lt;indexRule&gt;
      &lt;style name="Annotation"/&gt;
    &lt;/indexRule&gt;    
  &lt;/indexBuildItem&gt;
&lt;/indexBuildSpecification&gt;</pre>
        
        <p>The index build specification is a series of index build items, each of which identifies a CAS
          annotation type (a subtype of <code class="literal">uima.tcas.Annotation</code> &#8211; see <a href="references.html#ugr.ref.cas" class="olink">Chapter&nbsp;4, <i>CAS Reference</i></a>) and a style.</p>
        
        <p>The first item in this example specifies that the annotation type
          <code class="literal">org.apache.uima.examples.tokenizer.Token</code> should be indexed with the
          <span class="quote">&#8220;<span class="quote">Term</span>&#8221;</span> style. This means that each span of text annotated by a Token will be considered a
          single token for standard text search purposes.</p>
        
        <p>The second item in this example specifies that the annotation type
          <code class="literal">org.apache.uima.examples.tokenizer.Sentence</code> should be indexed with the
          <span class="quote">&#8220;<span class="quote">Breaking</span>&#8221;</span> style. This means that each span of text annotated by a Sentence will be
          considered a single sentence, which can affect that search engine's algorithm for matching queries. The
          semantic search engine available from alphaWorks always requires tokens and sentences in order to index a
          document.</p> <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
        <p>Requirements for Term and Breaking rules: The Semantic Search indexer from alphaWorks requires that
          the items to be indexed as words be designated using the Term rule. </p></div>
        
        <p>The remaining items all use the <span class="quote">&#8220;<span class="quote">Annotation</span>&#8221;</span> style. This indicates that each
          annotation of the specified types will be stored in the index as a searchable span, with a name equal to the
          annotation name (without the namespace).</p>
        
        <p>Also, features of annotations can be indexed using the
          <code class="literal">&lt;attributeMappings&gt;</code> subelement. In the example index build
          specification, we declare that the <code class="literal">building</code> feature of the type
          <code class="literal">org.apache.uima.tutorial.RoomNumber</code> should be indexed. The
          <code class="literal">&lt;indexName&gt;</code> element can be used to map the feature name to a different name in
          the index, but in this example we have opted to use the same name, <code class="literal">building</code>. </p>
        
        <p> At the end of the batch or collection, the Semantic Search CAS Indexer builds the index. This index can
          be queried with simple tokens or with XML tags.</p>
        
        <p>Examples:
          
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
              <p>A query on the word <span class="quote">&#8220;<span class="quote">UIMA</span>&#8221;</span> will retrieve all documents that have the occurrence
                of the word. But a query of the type <code class="literal">&lt;Meeting&gt;UIMA&lt;/Meeting&gt;</code>
                will retrieve only those documents that contain a Meeting annotation (produced by our
                MeetingDetector TAE, for example), where that Meeting annotation contains the word
                <span class="quote">&#8220;<span class="quote">UIMA</span>&#8221;</span>.</p>
            </li><li class="listitem">
              <p>A query for <code class="literal">&lt;RoomNumber building="Yorktown"/&gt;</code> will return
                documents that have a RoomNumber annotation whose <code class="literal">building</code> feature
                contains the term <span class="quote">&#8220;<span class="quote">Yorktown</span>&#8221;</span>. </p>
            </li></ul></div>
        
        <p>More information on the syntax of these kinds of queries, called XML Fragments, can be found in
          documentation for the semantic search engine component on <a class="ulink" href="http://www.alphaworks.ibm.com/tech/uima" target="_top">http://www.alphaworks.ibm.com/tech/uima</a>. For more information on the Index Build
          Specification format, see the UIMA Javadocs for class
          <code class="literal">org.apache.uima.search.IndexBuildSpecification</code>. Accessing the Javadocs is
          described <a href="references.html#ugr.ref.javadocs" class="olink">Chapter&nbsp;1, <i>Javadocs</i></a>.</p>
        
      </div>
      
      <div class="section" title="3.5.1.2.&nbsp;Building and Running a CPE including the Semantic Search CAS Indexer"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.application.search.cpe_with_semantic_search_cas_consumer">3.5.1.2.&nbsp;Building and Running a CPE including the Semantic Search CAS Indexer</h4></div></div></div>
        
        
        
        <p>The following steps illustrate how to build and run a CPE that uses the UIMA Meeting Detector TAE and the
          Simple Token and Sentence Annotator, discussed in the <a href="tutorials_and_users_guides.html#ugr.tug.aae" class="olink">Chapter&nbsp;1, <i>Annotator and Analysis Engine Developer's Guide</i></a> along with a CAS Consumer
          called the Semantic Search CAS Indexer, to build an index that allows you to query for documents based not
          only on textual content but also on whether they contain mentions of Meetings detected by the TAE.</p>
        
        <p>Run the CPE Configurator tool by executing the <code class="literal">cpeGui</code> shell script in the
          <code class="literal">bin</code> directory of the UIMA SDK. (For instructions on using this tool, see the <a href="tools.html#ugr.tools.cpe" class="olink">Chapter&nbsp;2, <i>Collection Processing Engine Configurator User's Guide</i></a>.)</p>
        
        <p>In the CPE Configurator tool, select the following components by browsing to their
          descriptors:</p>
        
        <div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
            <p>Collection Reader: <code class="literal">%UIMA_HOME%/examples/descriptors/collectionReader/
              FileSystemCollectionReader.xml</code></p>
          </li><li class="listitem">
            <p>Analysis Engine: include both of these; one produces tokens/sentences, required by the indexer
              in all cases and the other produces the meeting annotations of interest.
              </p><div class="itemizedlist"><ul class="itemizedlist" type="circle" compact><li class="listitem"><p><code class="literal">%UIMA_HOME%/examples/descriptors/analysis_engine/SimpleTokenAndSentenceAnnotator.xml</code></p></li><li class="listitem"><p><code class="literal">%UIMA_HOME%/examples/descriptors/tutorial/ex6/UIMAMeetingDetectorTAE.xml</code></p></li></ul></div><p>
            </p>
          </li><li class="listitem">
            <p>Two CAS Consumers:
              </p><div class="itemizedlist"><ul class="itemizedlist" type="circle" compact><li class="listitem"><p><code class="literal">%UIMA_HOME%/examples/descriptors/cas_consumer/SemanticSearchCasIndexer.xml</code></p></li><li class="listitem"><p><code class="literal">%UIMA_HOME%/examples/descriptors/cas_consumer/XmiWriterCasConsumer.xml</code></p></li></ul></div><p>  
 
            </p>
          </li></ul></div>
        
        <p>Set up parameters:</p>
        
        <div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
            <p> Set the File System Collection Reader's <span class="quote">&#8220;<span class="quote">Input Directory</span>&#8221;</span> parameter to point to
              the <code class="literal">%UIMA_HOME%/examples/data</code> directory.</p>
          </li><li class="listitem">
            <p>Set the Semantic Search CAS Indexer's <span class="quote">&#8220;<span class="quote">Indexing Specification Descriptor</span>&#8221;</span>
              parameter to point to <code class="literal">%UIMA_HOME%/examples/descriptors/tutorial/search/
              MeetingIndexBuildSpec.xml</code></p>
          </li><li class="listitem">
            <p>Set the Semantic Search CAS Indexer's <span class="quote">&#8220;<span class="quote">Index Dir</span>&#8221;</span> parameter to whatever
              directory into which you want the indexer to write its index files. </p><div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3>
              <p>The Indexer <span class="emphasis"><em>erases</em></span> old versions of the files it creates in this
                directory. </p></div><p> </p>
          </li><li class="listitem">
            <p>Set the XMI Writer CAS Consumer's <span class="quote">&#8220;<span class="quote">Output Directory</span>&#8221;</span> parameter to whatever
              directory into which you want to store the XMI files containing the results of your analysis for each
              document. </p>
          </li></ul></div>
        
        <p>Click on the Run Button. Once the run completes, a statistics dialog should appear, in which you can see
          how much time was spent in each of the components involved in the run.</p>
        
      </div>
    </div>
    <div class="section" title="3.5.2.&nbsp;Semantic Search Query Tool"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.application.search.query_tool">3.5.2.&nbsp;Semantic Search Query Tool</h3></div></div></div>
      
      
      <p>The Semantic Search component from UIMA on alphaWorks contains a simple tool for running queries
        against a semantic search index. After building an index as described in the previous section, you can launch
        this tool by running the shell script: semanticSearch, found in the <code class="literal">/bin</code> subdirectory
        of the Semantic Search UIMA install, at the command prompt. If you are using Eclipse, and have installed the
        UIMA examples, there will be a Run configuration you can use to conveniently launch this, called
        <code class="literal">UIMA Semantic Search</code>. This will display the following screen:
        
        
        </p><div class="screenshot">
    <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.application/image002.jpg" width="564" alt="Screenshot of the Semantic Search tool set up to run semantic queries against a semantic search index"></td></tr></table></div>
  </div>
      
      <p>Configure the fields on this screen as follows:
        
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
            <p>Set the <span class="quote">&#8220;<span class="quote">Index Directory</span>&#8221;</span> to the directory where you built your index. This is the
              same value that you supplied for the <span class="quote">&#8220;<span class="quote">Index Dir</span>&#8221;</span> parameter of the Semantic Search CAS
              Indexer in the CPE Configurator.</p>
          </li><li class="listitem">
            <p>Set the <span class="quote">&#8220;<span class="quote">XMI/XCAS Directory</span>&#8221;</span> to the directory where you stored the results of your
              analysis. This is the same value that you supplied for the <span class="quote">&#8220;<span class="quote">Output Directory</span>&#8221;</span>
              parameter of XMI Writer CAS Consumer in the CPE Configurator.</p>
          </li><li class="listitem">
            <p>Optionally, set the <span class="quote">&#8220;<span class="quote">Original Documents Directory</span>&#8221;</span> to the directory containing
              the original plain text documents that were analyzed and indexed. This is only needed for the "View
              Original Document" button.</p>
          </li><li class="listitem">
            <p> Set the <span class="quote">&#8220;<span class="quote">Type System Descriptor</span>&#8221;</span> to the location of the descriptor that describes
              your type system. For this example, this will be <code class="literal">%UIMA_HOME%/examples/
              descriptors/tutorial/ex4/TutorialTypeSystem.xml</code> </p>
          </li></ul></div>
      
      <p>Now, in the <span class="quote">&#8220;<span class="quote">XML Fragments</span>&#8221;</span> field, you can type in single words or XML queries where the XML
        tags correspond to the labels in the index build specification file (e.g.
        <code class="literal">&lt;Meeting&gt;UIMA&lt;/Meeting&gt;</code>). XML Fragments are described in the
        documentation for the semantic search engine component on <a class="ulink" href="http://www.alphaworks.ibm.com/tech/uima" target="_top">http://www.alphaworks.ibm.com/tech/uima</a>.</p>
      
      <p>After you enter a query and click the <span class="quote">&#8220;<span class="quote">Search</span>&#8221;</span> button, a list of hits will appear. Select
        one of the documents and click <span class="quote">&#8220;<span class="quote">View Analysis</span>&#8221;</span> to view the document in the UIMA Annotation
        Viewer.</p>
      
      <p>The source code for the Semantic Search query program is in
        <code class="literal">examples/src/com/ibm/apache-uima/search/examples/SemanticSearchGUI.java</code> . A simple
        command-line query program is also provided in
        <code class="literal">examples/src/com/ibm/apache-uima/search/examples/SemanticSearch.java</code> . Using these
        as a model, you can build a query interface from your own application. For details on the Semantic Search
        Engine query language and interface, see the documentation for the semantic search engine component on
          <a class="ulink" href="http://www.alphaworks.ibm.com/tech/uima" target="_top">http://www.alphaworks.ibm.com/tech/uima</a>.</p>
    </div>
  </div>
  
  <div class="section" title="3.6.&nbsp;Working with Remote Services"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.application.remote_services">3.6.&nbsp;Working with Remote Services</h2></div></div></div>
    
    
    <p>The UIMA SDK allows you to easily take any Analysis Engine or CAS Consumer and deploy it as a service. That
      Analysis Engine or CAS Consumer can then be called from a remote machine using various network
      protocols.</p>
    
    <p>The UIMA SDK provides support for two communications protocols:
      
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
          <p>SOAP, the standard Web Services protocol</p>
        </li><li class="listitem">
          <p>Vinci, a lightweight version of SOAP, included as a part of Apache UIMA. </p>
        </li></ul></div>
    
    <p>The UIMA framework can make use of these services in two different ways:
      
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
          <p>An Analysis Engine can create a proxy to a remote service; this proxy acts like a local component, but
            connects to the remote. The proxy has limited error handling and retry capabilities. Both Vinci and SOAP
            are supported.</p>
        </li><li class="listitem">
          <p>A Collection Processing Engine can specify non-Integrated mode (see <a href="tutorials_and_users_guides.html#ugr.tug.cpe.deploying_a_cpe" class="olink">Section&nbsp;2.5, &#8220;Deploying a CPE&#8221;</a>. The
            CPE provides more extensive error recovery capabilities. This mode only supports the Vinci
            communications protocol. </p>
        </li></ol></div>
    
    <div class="section" title="3.6.1.&nbsp;Deploying a UIMA Component as a SOAP Service"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.application.how_to_deploy_as_soap">3.6.1.&nbsp;Deploying a UIMA Component as a SOAP Service</h3></div></div></div>
      
      
      
      <p>To deploy a UIMA component as a SOAP Web Service, you need to first install the following software
        components:
        
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
            <p>Apache Tomcat 5.0 or 5.5 ( <a class="ulink" href="http://jakarta.apache.org/tomcat/" target="_top">http://jakarta.apache.org/tomcat/</a>) </p>
          </li><li class="listitem">
            <p>Apache Axis 1.3 or 1.4 (<a class="ulink" href="http://ws.apache.org/axis/" target="_top">http://ws.apache.org/axis/</a>) </p>
          </li></ul></div>
      
      <p>Later versions of these components will likely also work, but have not been tested.</p>
      
      <p>Next, you need to do the following setup steps:
        
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p>Set the CATALINA_HOME environment variable to the location where Tomcat is installed.</p>
          </li><li class="listitem">
            <p>Copy all of the JAR files from <code class="literal">%UIMA_HOME%/lib</code> to the
              <code class="literal">%CATALINA_HOME%/webapps/axis/WEB-INF/lib</code> in your installation.</p>
          </li><li class="listitem">
            <p>Copy your JAR files for the UIMA components that you wish to
              <code class="literal">%CATALINA_HOME%/webapps/axis/WEB-INF/lib</code> in your installation.</p>
          </li><li class="listitem">
            <p><span class="bold-italic">IMPORTANT</span>: any time you add JAR files to Tomcat (for
              instance, in the above 2 steps), you must shutdown and restart Tomcat before it
              <span class="quote">&#8220;<span class="quote">notices</span>&#8221;</span> this. So now, please shutdown and restart Tomcat.</p>
          </li><li class="listitem">
            <p>All the Java classes for the UIMA Examples are packaged in the
              <code class="literal">uima-examples.jar</code> file which is included in the
              <code class="literal">%UIMA_HOME%/lib</code> folder.</p>
          </li><li class="listitem">
            <p>In addition, if an annotator needs to locate resource files in the classpath, those resources
              must be available in the Axis classpath, so copy these also to
              <code class="literal">%CATALINA_HOME%/webapps/axis/WEB-INF/classes</code> .</p>
            
            <p>As an example, if you are deploying the GovernmentTitleRecognizer (found in
              <code class="literal">examples/descriptors/analysis_engine/
              GovernmentOfficialRecognizer_RegEx_TAE</code>) as a SOAP service, you need to copy the file
              <code class="literal">examples/resources/GovernmentTitlePatterns.dat</code> into
              <code class="literal">.../WEB-INF/classes</code>. </p>
          </li></ul></div>
      
      <p>Test your installation of Tomcat and Axis by starting Tomcat and going to
        <code class="literal">http://localhost:8080/axis/happyaxis.jsp</code> in your browser. Check to be sure that
        this reports that all of the required Axis libraries are present. One common missing file may be
        activation.jar, which you can get from java.sun.com.</p>
      
      <p>After completing these setup instructions, you can deploy Analysis Engines or CAS Consumers as SOAP web
        services by using the <code class="literal">deploytool</code> utility, with is located in the
        <code class="literal">/bin</code> directory of the UIMA SDK. <code class="literal">deploytool</code> is a command line
        program utility that takes as an argument a web services deployment descriptors (WSDD file); example WSDD
        files are provided in the <code class="literal">examples/deploy/soap</code> directory of the UIMA SDK. Deployment
        Descriptors have been provided for deploying and undeploying some of the example Analysis Engines that come
        with the SDK.</p>
      
      <p>As an example, the WSDD file for deploying the example Person Title annotator looks like this (important
        parts are in bold italics):
        
        
        </p><pre class="programlisting">&lt;deployment name="<span class="bold-italic">PersonTitleAnnotator</span>" 
            xmlns="http://xml.apache.org/axis/wsdd/" 
            xmlns:java="http://xml.apache.org/axis/wsdd/providers/java"&gt;

  &lt;service name="<span class="bold-italic">urn:PersonTitleAnnotator</span>" provider="java:RPC"&gt;

    &lt;parameter name="scope" value="Request"/&gt;

    &lt;parameter name="className" 
      value="org.apache.uima.reference_impl.analysis_engine
                .service.soap.AxisAnalysisEngineService_impl"/&gt;

    &lt;parameter name="allowedMethods" value="getMetaData process"/&gt;
    &lt;parameter name="allowedRoles" value="*"/&gt;
    &lt;parameter name="resourceSpecifierPath" 
      value="<span class="bold-italic">C:/Program Files/apache/uima/examples/
           descriptors/analysis_engine/PersonTitleAnnotator.xml</span>"/&gt;

    &lt;parameter name="numInstances" value="3"/&gt;

    &lt;!-- Type Mappings omitted from this document; 
          you will not need to edit them. --&gt;

    &lt;typeMapping .../&gt;
    &lt;typeMapping .../&gt;
    &lt;typeMapping .../&gt;

  &lt;/service&gt;

&lt;/deployment&gt;</pre>
      
      <p>To modify this WSDD file to deploy your own Analysis Engine or CAS Consumer, just replace the areas
        indicated in bold italics (deployment name, service name, and resource specifier path) with values
        appropriate for your component.</p>
      
      <p>The <code class="literal">numInstances</code> parameter specifies how many instances of your Analysis Engine
        or CAS Consumer will be created. This allows your service to support multiple clients concurrently. When a
        new request comes in, if all of the instances are busy, the new request will wait until an instance becomes
        available.</p>
      
      <p>To deploy the Person Title annotator service, issue the following command:
        
        
        </p><pre class="programlisting">C:/Program Files/apache/uima/bin&gt;deploytool 
../examples/deploy/soap/Deploy_PersonTitleAnnotator.wsdd</pre>
      
      <p>Test if the deployment was successful by starting up a browser, pointing it to your Tomcat
        installation's <span class="quote">&#8220;<span class="quote">axis</span>&#8221;</span> webpage (e.g., <code class="literal">http://localhost:8080/axis</code>)
        and clicking on the List link. This should bring up a page which shows the deployed services, where you should
        see the service you just deployed.</p>
      
      <p>The other components can be deployed by replacing
        <code class="literal">Deploy_PersonTitleAnnotator.wsdd</code> with one of the other Deploy descriptors in the
        deploy directory. The deploytool utility can also undeploy services when passed one of the Undeploy
        descriptors.</p> <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
      <p>The <code class="literal">deploytool</code> shell script assumes that the web services are to be installed at
        <code class="literal">http://localhost:8080/axis</code>. If this is not the case, you will need to update the shell
        script appropriately.</p> </div>
      
      <p>Once you have deployed your component as a web service, you may call it from a remote machine. See <a class="xref" href="#ugr.tug.application.how_to_call_a_uima_service" title="3.6.3.&nbsp;How to Call a UIMA Service">Section&nbsp;3.6.3, &#8220;Calling a UIMA Service&#8221;</a> for instructions.</p>
      
    </div>
    
    <div class="section" title="3.6.2.&nbsp;Deploying a UIMA Component as a Vinci Service"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.application.how_to_deploy_a_vinci_service">3.6.2.&nbsp;Deploying a UIMA Component as a Vinci Service</h3></div></div></div>
      
      
      
      <p>There are no software prerequisites for deploying a Vinci service. The necessary libraries are part of
        the UIMA SDK. However, before you can use Vinci services you need to deploy the Vinci Naming Service (VNS), as
        described in section <a class="xref" href="#ugr.tug.application.vns" title="3.6.5.&nbsp;The Vinci Naming Services (VNS)">Section&nbsp;3.6.5, &#8220;The Vinci Naming Services (VNS)&#8221;</a>.</p>
      
      <p>To deploy a service, you have to insure any components you want to include can be found on the class path.
        One way to do this is to set the environment variable UIMA_CLASSPATH to the set of class paths you need for any
        included components. Then run the <code class="literal">startVinciService</code> shell script, which is located
        in the <code class="literal">bin</code> directory, and pass it the path to a Vinci deployment descriptor, for
        example: <code class="literal">C:UIMA&gt;bin/startVinciService
        ../examples/deploy/vinci/Deploy_PersonTitleAnnotator.xml</code>.
      If you are running Eclipse, and have the <code class="literal">uimaj-examples</code> project
      in your workspace, you can use the Eclipse Menu <span class="symbol">&#8594;</span> Run <span class="symbol">&#8594;</span> Run... and then
      pick <span class="quote">&#8220;<span class="quote">UIMA Start Vinci Service</span>&#8221;</span>.</p>
      
      <p>This example deployment descriptor looks like:
        
        </p><pre class="programlisting">&lt;deployment name=<span class="bold-italic">"Vinci Person Title Annotator Service"</span>&gt;

  &lt;service name=<span class="bold-italic">"uima.annotator.PersonTitleAnnotator"</span> provider="vinci"&gt;

    &lt;parameter name="resourceSpecifierPath" 
      value=<span class="bold-italic">"C:/Program Files/apache/uima/examples/descriptors/
          analysis_engine/PersonTitleAnnotator.xml"</span>/&gt;

    &lt;parameter name="numInstances" value="1"/&gt;

    &lt;parameter name="serverSocketTimeout" value="120000"/&gt;

  &lt;/service&gt;

&lt;/deployment&gt;</pre>
      
      <p>To modify this deployment descriptor to deploy your own Analysis Engine or CAS Consumer, just replace
        the areas indicated in bold italics (deployment name, service name, and resource specifier path) with
        values appropriate for your component.</p>
      
      <p>The <code class="literal">numInstances</code> parameter specifies how many instances of your Analysis Engine
        or CAS Consumer will be created. This allows your service to support multiple clients concurrently. When a
        new request comes in, if all of the instances are busy, the new request will wait until an instance becomes
        available.</p>
      
      <p>The <code class="literal">serverSocketTimeout</code> parameter specifies the number of milliseconds
        (default = 5 minutes) that the service will wait between requests to process something. After this amount of
        time, the server will presume the client may have gone away - and it <span class="quote">&#8220;<span class="quote">cleans up</span>&#8221;</span>, releasing any
        resources it is holding. The next call to process on the service will result in a cycle which will cause the
        client to re-establish its connection with the service (some additional overhead).</p>

      <p>There are two additional parameters that you can add to your deployment descriptor:
        </p>
      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><code class="literal">&lt;parameter name="threadPoolMinSize" value="[Integer]"/&gt;</code>:
          Specifies the number of threads that the Vinci service creates on startup in order to
          serve clients' requests.</p></li><li class="listitem"><p><code class="literal">&lt;parameter name="threadPoolMaxSize" value="[Integer]"/&gt;</code>:
          Specifies the maximum number of threads that the Vinci service will create.  When the number of
          concurrent requests exceeds the <code class="literal">threadPoolMinSize</code>, additional threads will be
          created to serve requests, until the <code class="literal">threadPoolMaxSize</code> is reached.</p></li></ul></div>
      
      <p>The <code class="literal">startVinciService</code> script takes two additional optional parameters. The
        first one overrides the value of the VNS_HOST environment variable, allowing you to specify the name server
        to use. The second parameter if specified needs to be a unique (on this server) non-negative number,
        specifying the instance of this service. When used, this number allows multiple instances of the same named
        service to be started on one server; they will all register with the Vinci name service and be made available to
        client requests.</p>
      
      <p>Once you have deployed your component as a web service, you may call it from a remote machine. See <a class="xref" href="#ugr.tug.application.how_to_call_a_uima_service" title="3.6.3.&nbsp;How to Call a UIMA Service">Section&nbsp;3.6.3, &#8220;Calling a UIMA Service&#8221;</a> for instructions.</p>
      
    </div>
    
    <div class="section" title="3.6.3.&nbsp;How to Call a UIMA Service"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.application.how_to_call_a_uima_service">3.6.3.&nbsp;How to Call a UIMA Service</h3></div></div></div>
      
      
      
      <p>Once an Analysis Engine or CAS Consumer has been deployed as a service, it can be used from any UIMA
        application, in the exact same way that a local Analysis Engine or CAS Consumer is used. For example, you can
        call an Analysis Engine service from the Document Analyzer or use the CPE Configurator to build a CPE that
        includes Analysis Engine and CAS Consumer services.</p>
      
      <p>To do this, you use a <span class="emphasis"><em>service client descriptor</em></span> in place of the usual Analysis
        Engine or CAS Consumer Descriptor. A service client descriptor is a simple XML file that indicates the
        location of the remote service and a few parameters. Example service client descriptors are provided in the
        UIMA SDK under the directories <code class="literal">examples/descriptors/soapService</code> and
        <code class="literal">examples/descriptors/vinciService</code>. The contents of these descriptors are
        explained below.</p>
      
      <p>Also, before you can call a SOAP service, you need to have the necessary Axis JAR files in your classpath.
        If you use any of the scripts in the <code class="literal">bin</code> directory of the UIMA installation to launch your
        application, such as documentAnalyzer, these JARs are added to the classpath, automatically, using the
        <code class="literal">CATALINA_HOME</code> environment variable. The required files are the following (all part
        of the Apache Axis download)
        
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
            <p>activation.jar</p>
          </li><li class="listitem">
            <p>axis.jar</p>
          </li><li class="listitem">
            <p>commons-discovery.jar</p>
          </li><li class="listitem">
            <p>commons-logging.jar</p>
          </li><li class="listitem">
            <p>jaxrpc.jar</p>
          </li><li class="listitem">
            <p>saaj.jar</p>
          </li></ul></div>
      
      <div class="section" title="3.6.3.1.&nbsp;SOAP Service Client Descriptor"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.application.soap_service_client_descriptor">3.6.3.1.&nbsp;SOAP Service Client Descriptor</h4></div></div></div>
        
        
        <p>The descriptor used to call the PersonTitleAnnotator SOAP service from the example above is:
          
          
          </p><pre class="programlisting">&lt;uriSpecifier xmlns="http://uima.apache.org/resourceSpecifier"&gt;
   &lt;resourceType&gt;AnalysisEngine&lt;/resourceType&gt;
   &lt;uri&gt;http://localhost:8080/axis/services/urn:PersonTitleAnnotator&lt;/uri&gt;
    &lt;protocol&gt;SOAP&lt;/protocol&gt;
    &lt;timeout&gt;60000&lt;/timeout&gt;           
&lt;/uriSpecifier&gt;</pre>
        
        <p>The &lt;resourceType&gt; element must contain either AnalysisEngine or CasConsumer. This
          specifies what type of component you expect to be at the specified service address.</p>
        
        <p>The &lt;uri&gt; element describes which service to call. It specifies the host (localhost, in this
          example) and the service name (urn:PersonTitleAnnotator), which must match the name specified in the
          deployment descriptor used to deploy the service.</p>
        
      </div>
      <div class="section" title="3.6.3.2.&nbsp;Vinci Service Client Descriptor"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.application.vinci_service_client_descriptor">3.6.3.2.&nbsp;Vinci Service Client Descriptor</h4></div></div></div>
        
        
        <p>To call a Vinci service, a similar descriptor is used:
          
          
          </p><pre class="programlisting">&lt;uriSpecifier xmlns="http://uima.apache.org/resourceSpecifier"&gt;
   &lt;resourceType&gt;AnalysisEngine&lt;/resourceType&gt;
   &lt;uri&gt;uima.annot.PersonTitleAnnotator&lt;/uri&gt;
   &lt;protocol&gt;Vinci&lt;/protocol&gt;
   &lt;timeout&gt;60000&lt;/timeout&gt; 
   &lt;parameters&gt;
     &lt;parameter name="VNS_HOST" value="some.internet.ip.name-or-address"/&gt;
     &lt;parameter name="VNS_PORT" value="9000"/&gt;
   &lt;/parameters&gt;
&lt;/uriSpecifier&gt;</pre>
        
        <p>Note that Vinci uses a centralized naming server, so the host where the service is deployed does not
          need to be specified. Only a name (<code class="literal">uima.annot.PersonTitleAnnotator</code>) is given,
          which must match the name specified in the deployment descriptor used to deploy the service.</p>
        
        <p>The host and/or port where your Vinci Naming Service (VNS) server is running can be specified by the
          optional &lt;parameter&gt; elements. If not specified, the value is taken from the specification given
          your Java command line (if present) using <code class="literal">-DVNS_HOST=&lt;host&gt; </code>and
          <code class="literal">-DVNS_PORT=&lt;port&gt;</code> system arguments. If not specified on the Java command
          line, defaults are used: localhost for the <code class="literal">VNS_HOST</code>, and <code class="literal">9000</code>
          for the <code class="literal">VNS_PORT</code>. See the next section for details on setting up a VNS server.</p>
        
      </div>
    </div>
    <div class="section" title="3.6.4.&nbsp;Restrictions on remotely deployed services"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.application.restrictions_on_remotely_deployed_services">3.6.4.&nbsp;Restrictions on remotely deployed services</h3></div></div></div>
      
      
      <p>Remotely deployed services are started on remote machines, using UIMA component descriptors on those
        remote machines. These descriptors supply any configuration and resource parameters for the service
        (configuration parameters are not transmitted from the calling instance to the remote one). Likewise, the
        remote descriptors supply the type system specification for the remote annotators that will be run (the type
        system of the calling instance is not transmitted to the remote one).</p>
      
      <p>The remote service wrapper, when it receives a CAS from the caller, instantiates it for the remote
        service, making instances of all types which the remote service specifies. Other instances in the incoming
        CAS for types which the remote service has no type specification for are kept aside, and when the remote
        service returns the CAS back to the caller, these type instances are re-merged back into the CAS being
        transmitted back to the caller. Because of this design, a remote service which doesn't declare a type system
        won't receive any type instances.</p> <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
      <p>This behavior may change in future releases, to one where configuration parameters and / or type systems
        are transmitted to remote services. </p></div>
      
    </div>
    
    <div class="section" title="3.6.5.&nbsp;The Vinci Naming Services (VNS)"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.application.vns">3.6.5.&nbsp;The Vinci Naming Services (VNS)</h3></div></div></div>
      
      
      <p>Vinci consists of components for building network-accessible services, clients for accessing those
        services, and an infrastructure for locating and managing services. The primary infrastructure component
        is the Vinci directory, known as VNS (for Vinci Naming Service).</p>
      
      <p>On startup, Vinci services locate the VNS and provide it with information that is used by VNS during
        service discovery. Vinci service provides the name of the host machine on which it runs, and the name of the
        service. The VNS internally creates a binding for the service name and returns the port number on which the
        Vinci service will wait for client requests. This VNS stores its bindings in a filesystem in a file called
        vns.services.</p>
      
      <p>In Vinci, services are identified by their service name. If there is more than one physical service with
        the same service name, then Vinci assumes they are equivalent and will route queries to them randomly,
        provided that they are all running on different hosts. You should therefore use a unique service name if you
        don't want to conflict with other services listed in whatever VNS you have configured jVinci to use.</p>
      
      <div class="section" title="3.6.5.1.&nbsp;Starting VNS"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.application.vns.starting">3.6.5.1.&nbsp;Starting VNS</h4></div></div></div>
        
        
        <p>To run the VNS use the <code class="literal">startVNS</code> script found in the
          <code class="literal">bin</code> directory of the UIMA installation, 
        or launch it from Eclipse.  If you've installed the <code class="literal">uimaj-examples</code> project,
        it will supply a pre-configured launch script you can access in Eclipse by selecting
        Menu <span class="symbol">&#8594;</span> Run <span class="symbol">&#8594;</span> Run... and picking <span class="quote">&#8220;<span class="quote">UIMA Start VNS</span>&#8221;</span>.</p>
        <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>VNS runs on port 9000 by default so please make sure this port is
        available. If you see the following exception:
        
        </p><pre class="programlisting">java.net.BindException: Address already in use:

JVM_Bind</pre><p>
          it indicates that another process is running on port 9000. In this case, add the parameter <code class="literal">-p
          &lt;port&gt;</code> to the <code class="literal">startVNS</code> command, using
          <code class="literal">&lt;port&gt;</code> to specify an alternative port to use. </p></div>
        
        <p>When started, the VNS produces output similar to the following:
          
          
          </p><pre class="programlisting">[10/6/04 3:44 PM | main] WARNING: Config file doesn't exist, 
            creating a new empty config file!
[10/6/04 3:44 PM | main] Loading config file : .vns.services
[10/6/04 3:44 PM | main] Loading workspaces file : .vns.workspaces
[10/6/04 3:44 PM | main] ====================================
(WARNING) Unexpected exception:
java.io.FileNotFoundException: .vns.workspaces (The system cannot find
the file specified)
  at java.io.FileInputStream.open(Native Method)
  at java.io.FileInputStream.&lt;init&gt;(Unknown Source)
  at java.io.FileInputStream.&lt;init&gt;(Unknown Source)
  at java.io.FileReader.&lt;init&gt;(Unknown Source)
  at org.apache.vinci.transport.vns.service.VNS.loadWorkspaces(VNS.java:339
  at org.apache.vinci.transport.vns.service.VNS.startServing(VNS.java:237)
  at org.apache.vinci.transport.vns.service.VNS.main(VNS.java:179)
[10/6/04 3:44 PM | main] WARNING: failed to load workspace.
[10/6/04 3:44 PM | main] VNS Workspace : null
[10/6/04 3:44 PM | main] Loading counter file : .vns.counter
[10/6/04 3:44 PM | main] Could not load the counter file : .vns.counter
[10/6/04 3:44 PM | main] Starting backup thread,
            using files .vns.services.bak
and .vns.services
[10/6/04 3:44 PM | main] Serving on port : 9000
[10/6/04 3:44 PM | Thread-0] Backup thread started
[10/6/04 3:44 PM | Thread-0] Saving to config file : .vns.services.bak
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; VNS is up and running! &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Type 'quit' and hit ENTER to terminate VNS &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
[10/6/04 3:44 PM | Thread-0] Config save required 10 millis.
[10/6/04 3:44 PM | Thread-0] Saving to config file : .vns.services
[10/6/04 3:44 PM | Thread-0] Config save required 10 millis.
[10/6/04 3:44 PM | Thread-0] Saving counter file : .vns.counter</pre>
        <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
        <p>Disregard the <span class="emphasis"><em>java.io.FileNotFoundException: .\vns.workspaces (The system cannot
          find the file specified).</em></span> It is just a complaint. not a serious problem. VNS Workspace is a
          feature of the VNS that is not critical. The important information to note is <code class="literal">[10/6/04 3:44 PM |
          main] Serving on port : 9000</code> which states the actual port where VNS will listen for incoming
          requests. All Vinci services and all clients connecting to services must provide the VNS port on the
          command line IF the port is not a default. Again the default port is 9000. Please see <a class="xref" href="#ugr.tug.application.launching_vinci_services" title="3.6.5.3.&nbsp;Launching Vinci Services">Section&nbsp;3.6.5.3, &#8220;Launching Vinci Services&#8221;</a> below for details about the command
          line and parameters.</p> </div>
        
      </div>
      
      <div class="section" title="3.6.5.2.&nbsp;VNS Files"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.application.vns_files">3.6.5.2.&nbsp;VNS Files</h4></div></div></div>
        
        
        <p>The VNS maintains two external files:
          
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem">
              <p><code class="literal">vns.services</code></p>
            </li><li class="listitem">
              <p><code class="literal">vns.counter</code></p>
            </li></ul></div>
        
        <p>These files are generated by the VNS in the same directory where the VNS is launched from. Since these
          files may contain old information it is best to remove them before starting the VNS. This step ensures that
          the VNS has always the newest information and will not attempt to connect to a service that has been
          shutdown.</p>
      </div>
      
      <div class="section" title="3.6.5.3.&nbsp;Launching Vinci Services"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.application.launching_vinci_services">3.6.5.3.&nbsp;Launching Vinci Services</h4></div></div></div>
        
        
        <p>When launching Vinci service, you must indicate which VNS the service will
          connect to. A Vinci service is typically started using the script
          <code class="literal">startVinciService</code>, found in the <code class="literal">bin</code>
          directory of the UIMA installation. (If you're using Eclipse and have the 
          <code class="literal">uimaj-examples</code> project in the workspace, you will also find
          an Eclipse launcher named <span class="quote">&#8220;<span class="quote">UIMA Start Vinci Service</span>&#8221;</span> you can use.)  
          For the script, the environmental variable VNS_HOST should
          be set to the name or IP address of the machine hosting the Vinci Naming Service. The
          default is localhost, the machine the service is deployed on. This name can also be
          passed as the second argument to the startVinciService script. The default port
          for VNS is 9000 but can be overriden with the VNS_PORT environmental
          variable.</p>

        
        <p>If you write your own startup script, to define Vinci's default VNS you must provide the
          following JVM parameters:
          
          </p><pre class="programlisting">java -DVNS_HOST=localhost -DVNS_PORT=9000 ...</pre>
        
        <p>The above setting is for the VNS running on the same machine as the service. Of course one can deploy the
          VNS on a different machine and the JVM parameter will need to be changed to this:
          
          </p><pre class="programlisting">java -DVNS_HOST=&lt;host&gt; -DVNS_PORT=9000 ...</pre>
        
        <p>where <span class="quote">&#8220;<span class="quote">&lt;host&gt;</span>&#8221;</span> is a machine name or its IP where the VNS is running.</p>
        <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
        <p>VNS runs on port 9000 by default. If you see the following exception:
          
          
          </p><pre class="programlisting">(WARNING) Unexpected exception:
org.apache.vinci.transport.ServiceDownException: 
          VNS inaccessible: java.net.Connect
Exception: Connection refused: connect</pre><p>
          then, perhaps the VNS is not running OR the VNS is running but it is using a different port. To correct the
          latter, set the environmental variable VNS_PORT to the correct port before starting the service.</p>
        </div>
        
        <p>To get the right port check the VNS output for something similar to the following:
          
          </p><pre class="programlisting">[10/6/04 3:44 PM | main] Serving on port : 9000</pre>
        
        <p>It is printed by the VNS on startup.</p>
        
      </div>
    </div>
    
    <div class="section" title="3.6.6.&nbsp;Configuring Timeout Settings"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.configuring_timeout_settings">3.6.6.&nbsp;Configuring Timeout Settings</h3></div></div></div>
      
      
      <p>UIMA has several timeout specifications, summarized here.  The timeouts associated with remote 
      services are discussed below.  In addition there are timeouts that can be specified for:
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="bold"><strong>Acquiring an empty CAS from a CAS Pool:</strong></span>
      See <a class="xref" href="#ugr.tug.applications.multi_threaded" title="3.2.5.&nbsp;Multi-threaded Applications">Section&nbsp;3.2.5, &#8220;Multi-threaded Applications&#8221;</a>.</p></li><li class="listitem"><p><span class="bold"><strong>Reassembling chunks of a large document</strong></span>
        See <a href="references.html#ugr.ref.xml.cpe_descriptor.descriptor.operational_parameters" class="olink">Section&nbsp;3.7, &#8220;CPE Operational Parameters&#8221;</a></p>
        </li></ul></div>
      
      <p>If your application uses remote UIMA services it is important to consider how to set the
        <span class="emphasis"><em>timeout</em></span> values appropriately. This is particularly important if your service can
        take a long time to process each request.</p>
      
      <p>There are two types of timeout settings in UIMA, the <span class="emphasis"><em>client timeout</em></span> and the
        <span class="emphasis"><em>server socket timeout</em></span>. The client timeout is usually the most important, it
        specifies how long that client is willing to wait for the service to process each CAS. The client timeout can be
        specified for both Vinci and SOAP. The server socket timeout (Vinci only) specifies how long the service
        holds the connection open between calls from the client. After this amount of time, the server will presume
        the client may have gone away - and it <span class="quote">&#8220;<span class="quote">cleans up</span>&#8221;</span>, releasing any resources it is holding. The
        next call to process on the service will cause the client to re-establish its connection with the service
        (some additional overhead).</p>
      <div class="section" title="3.6.6.1.&nbsp;Setting the Client Timeout"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.setting_client_timeout">3.6.6.1.&nbsp;Setting the Client Timeout</h4></div></div></div>
        
        <p>The way to set the client timeout is different depending on what deployment mode you use in your CPE (if
          any).</p>
        
        <p>If you are using the default <span class="quote">&#8220;<span class="quote">integrated</span>&#8221;</span> deployment mode in your CPE, or if you are not
          using a CPE at all, then the client timeout is specified in your Service Client Descriptor (see <a class="xref" href="#ugr.tug.application.how_to_call_a_uima_service" title="3.6.3.&nbsp;How to Call a UIMA Service">Section&nbsp;3.6.3, &#8220;Calling a UIMA Service&#8221;</a>). For example:</p>
        
        
        <pre class="programlisting">&lt;uriSpecifier xmlns="http://uima.apache.org/resourceSpecifier"&gt;
   &lt;resourceType&gt;AnalysisEngine&lt;/resourceType&gt;
   &lt;uri&gt;uima.annot.PersonTitleAnnotator&lt;/uri&gt;
   &lt;protocol&gt;Vinci&lt;/protocol&gt;
   <span class="bold-italic">&lt;timeout&gt;60000&lt;/timeout&gt;</span> 
   &lt;parameters&gt;
     &lt;parameter name="VNS_HOST" value="some.internet.ip.name-or-address"/&gt;
     &lt;parameter name="VNS_PORT" value="9000"/&gt;
   &lt;/parameters&gt;
&lt;/uriSpecifier&gt;</pre>
        
        <p>The client timeout in this example is <code class="literal">60000</code>. This value specifies the number of
          milliseconds that the client will wait for the service to respond to each request. In this example, the
          client will wait for one minute.</p>
        <p>If the service does not respond within this amount of time, processing of the current CAS will abort. If
          you called the <code class="literal">AnalysisEngine.process</code> method directly from your application, an
          Exception will be thrown. If you are running a CPE, what happens next is dependent on the error handling
          settings in your CPE descriptor (see <a href="references.html#ugr.ref.xml.cpe_descriptor.descriptor.cas_processors.individual.error_handling" class="olink">Section&nbsp;3.6.1.7, &#8220;&lt;errorHandling&gt; Element&#8221;</a>
          ). The default action is for the CPE to terminate, but you can override this. </p>
        
        <p>If you are using the <span class="quote">&#8220;<span class="quote">managed</span>&#8221;</span> or <span class="quote">&#8220;<span class="quote">non-managed</span>&#8221;</span> deployment mode in your
          CPE, then the client timeout is specified in your CPE desciptor's <code class="literal">errorHandling</code>
          element. For example:</p>
        
        
        <pre class="programlisting">&lt;errorHandling&gt;
  &lt;maxConsecutiveRestarts .../&gt;
  &lt;errorRateThreshold .../&gt;
  &lt;timeout max="60000"/&gt;
&lt;/errorHandling&gt;</pre>
        
        <p>As in the previous example, the client timeout is set to <code class="literal">60000</code>, and this
          specifies the number of milliseconds that the client will wait for the service to respond to each
          request.</p>
        <p>If the service does not respond within the specified amount of time, the action is determined by the
          settings for <code class="literal">maxConsecutiveRestarts</code> and
          <code class="literal">errorRateThreshold</code>. These settings support such things as restarting the process
          (for <span class="quote">&#8220;<span class="quote">managed</span>&#8221;</span> deployment mode), dropping and reestablishing the connection (for
          <span class="quote">&#8220;<span class="quote">non-managed</span>&#8221;</span> deployment mode), and removing the offending service from the pipeline. See
            <a href="references.html#ugr.ref.xml.cpe_descriptor.descriptor.cas_processors.individual.error_handling" class="olink">Section&nbsp;3.6.1.7, &#8220;&lt;errorHandling&gt; Element&#8221;</a>
          ) for details. </p>
        
        <p>Note that the client timeout does not apply to the <code class="literal">GetMetaData</code>
          request that is made when the client first connects to the service.  This call is typically
          very fast and does not need a large timeout (the default is 60 seconds).  However, if many
          clients are competing for a small number of services, it may be necessary to increase this
          value.  See <a href="references.html#ugr.ref.xml.component_descriptor.service_client" class="olink">Section&nbsp;2.7, &#8220;Service Client Descriptors&#8221;</a></p>
      </div>
      
      <div class="section" title="3.6.6.2.&nbsp;Setting the Server Socket Timeout"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.setting_server_socket_timeout">3.6.6.2.&nbsp;Setting the Server Socket Timeout</h4></div></div></div>
        
        <p>The Server Socket Timeout applies only to Vinci services, and is specified in the Vinci deployment
          descriptor as discussed in section <a class="xref" href="#ugr.tug.application.how_to_deploy_a_vinci_service" title="3.6.2.&nbsp;Deploying a UIMA Component as a Vinci Service">Section&nbsp;3.6.2, &#8220;Deploying as a Vinci Service&#8221;</a>. For example:
          
          </p><pre class="programlisting">&lt;deployment name="Vinci Person Title Annotator Service"&gt;

  &lt;service name="uima.annotator.PersonTitleAnnotator" provider="vinci"&gt;

    &lt;parameter name="resourceSpecifierPath" 
      value="C:/Program Files/apache/uima/examples/descriptors/
          analysis_engine/PersonTitleAnnotator.xml"/&gt;

    &lt;parameter name="numInstances" value="1"/&gt;

    &lt;parameter name="serverSocketTimeout" value=<span class="bold-italic">"120000"</span>/&gt;

  &lt;/service&gt;

&lt;/deployment&gt;</pre><p>
         </p>
        
        <p>The server socket timeout here is set to <code class="literal">120000</code> milliseconds, or two minutes.
          This parameter specifies how long the service will wait between requests to process something. After this
          amount of time, the server will presume the client may have gone away - and it <span class="quote">&#8220;<span class="quote">cleans up</span>&#8221;</span>,
          releasing any resources it is holding. The next call to process on the service will cause the client to
          re-establish its connection with the service (some additional overhead). The service may print a
          <span class="quote">&#8220;<span class="quote">Read Timed Out</span>&#8221;</span> message to the console when the server socket timeout elapses.</p>
        
        <p>In most cases, it is not a problem if the server socket timeout elapses. The client will simply
          reconnect. However, if you notice <span class="quote">&#8220;<span class="quote">Read Timed Out</span>&#8221;</span> messages on your server console,
          followed by other connection problems, it is possible that the client is having trouble reconnecting for
          some reason. In this situation it may help increase the stability of your application if you increase the
          server socket timeout so that it does not elapse during actual processing.</p>
      </div>
      
    </div>
  </div>
  
  <div class="section" title="3.7.&nbsp;Increasing performance using parallelism"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.application.increasing_performance_using_parallelism">3.7.&nbsp;Increasing performance using parallelism</h2></div></div></div>
    
    
    <p>There are several ways to exploit parallelism to increase performance in the UIMA Framework. These range
      from running with additional threads within one Java virtual machine on one host (which might be a
      multi-processor or hyper-threaded host) to deploying analysis engines on a set of remote machines.</p>
    
    <p>The Collection Processing facility in UIMA provides the ability to scale the pipe-line of analysis
      engines. This scale-out runs multiple threads within the Java virtual machine running the CPM, one for each
      pipe in the pipe-line. To activate it, in the <code class="literal">&lt;casProcessors&gt;</code> descriptor
      element, set the attribute <code class="literal">processingUnitThreadCount</code>, which specifies the number of
      replicated processing pipelines, to a value greater than 1, and insure that the size of the CAS pool is equal to or
      greater than this number (the attribute of <code class="literal">&lt;casProcessors&gt;</code> to set is
      <code class="literal">casPoolSize</code>). For more details on these settings, see <a href="references.html#ugr.ref.xml.cpe_descriptor.descriptor.cas_processors" class="olink">Section&nbsp;3.6, &#8220;CAS Processors&#8221;</a> .</p>
    
    <p>For deployments that incorporate remote analysis engines in the Collection Manager pipe-line, running
      on multiple remote hosts, scale-out is supported which uses the Vinci naming service. If multiple instances of
      a service with the same name, but running on different hosts, are registered with the Vinci Name Server, it will
      assign these instances to incoming requests.</p>
    
    <p>There are two modes supported: a <span class="quote">&#8220;<span class="quote">random</span>&#8221;</span> assignment, and a <span class="quote">&#8220;<span class="quote">exclusive</span>&#8221;</span>
      one. The <span class="quote">&#8220;<span class="quote">random</span>&#8221;</span> mode distributes load using an algorithm that selects a service instance at
      random. The UIMA framework supports this only for the case where all of the instances are running on unique
      hosts; the framework does not support starting 2 or more instances on the same host.</p>
    
    <p>The exclusive mode dedicates a particular remote instance to each Collection Manager pip-line instance.
      This mode is enabled by adding a configuration parameter in the
      &lt;casProcessor&gt; section of the CPE descriptor:</p>
    
    
    <div class="literallayout"><p>&lt;deploymentParameters&gt;<br>
&nbsp;&nbsp;&lt;parameter&nbsp;name="service-access"&nbsp;value="exclusive"&nbsp;/&gt;<br>
&lt;/deploymentParameters&gt;</p></div>
    
    <p>If this is not specified, the <span class="quote">&#8220;<span class="quote">random</span>&#8221;</span> mode is used.</p>
    
    <p>In addition, remote UIMA engine services can be started with a parameter that specifies the number of
      instances the service should support (see the <code class="literal">&lt;parameter name="numInstances"&gt;</code>
      XML element in remote deployment descriptor <a class="xref" href="#ugr.tug.application.remote_services" title="3.6.&nbsp;Working with Remote Services">Section&nbsp;3.6, &#8220;Working with Remote Services&#8221;</a>
      Specifying more than one causes the service wrapper for the analysis engine to use multi-threading (within the
      single Java Virtual Machine &#8211; which can take advantage of multi-processor and hyper-threaded
      architectures).</p> <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
    <p>When using Vinci in <span class="quote">&#8220;<span class="quote">exclusive</span>&#8221;</span> mode (see service access under <a href="references.html#ugr.ref.xml.cpe_descriptor.descriptor.cas_processors.individual.deployment_parameters" class="olink">Section&nbsp;3.6.1.5, &#8220;&lt;deploymentParameters&gt; Element&#8221;</a>
      ), only one thread is used. To achieve multi-processing on a server in this case, use multiple instances of the
      service, instead of multiple threads (see <a class="xref" href="#ugr.tug.application.how_to_deploy_a_vinci_service" title="3.6.2.&nbsp;Deploying a UIMA Component as a Vinci Service">Section&nbsp;3.6.2, &#8220;Deploying as a Vinci Service&#8221;</a>.</p> </div>
  </div>
  
  <div class="section" title="3.8.&nbsp;Monitoring AE Performance using JMX"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.application.jmx">3.8.&nbsp;Monitoring AE Performance using JMX</h2></div></div></div>
    
    
    <p>As of version 2, UIMA supports remote monitoring of Analysis Engine performance via the Java Management
      Extensions (JMX) API. JMX is a standard part of the Java Runtime Environment v5.0; there is also a reference
      implementation available from Sun for Java 1.4. An introduction to JMX is available from Sun here: <a class="ulink" href="http://java.sun.com/developer/technicalArticles/J2SE/jmx.html" target="_top">http://java.sun.com/developer/technicalArticles/J2SE/jmx.html</a>. When you run a UIMA with a
      JVM that supports JMX, the UIMA framework will automatically detect the presence of JMX and will register
      <span class="emphasis"><em>MBeans</em></span> that provide access to the performance statistics.</p>
    
    <p>Note: The Sun JVM supports local monitoring; for others you can configure your
      application for remote monitoring (even when on the same host) by specifying a unique port number, e.g.
      <code class="literal">
      -Dcom.sun.management.jmxremote.port=1098
      -Dcom.sun.management.jmxremote.authenticate=false
      -Dcom.sun.management.jmxremote.ssl=false</code></p>
    
    <p>Now, you can use any JMX client to view the statistics. JDK 5.0 or later provides a standard client that you can use.
      Simply open a command prompt, make sure the JDK <code class="literal">bin</code> directory is in your path, and
      execute the <code class="literal">jconsole</code> command. This should bring up a window allowing you to
      select one of the local JMX-enabled applications currently running, or to enter a remote (or local) host and
      port, e.g. localhost:1098.  The next screen will show a summary of
      information about the Java process that you connected to. Click on the <span class="quote">&#8220;<span class="quote">MBeans</span>&#8221;</span> tab, then expand
      <span class="quote">&#8220;<span class="quote">org.apache.uima</span>&#8221;</span> in the tree at the left. You should see a view like this:
      
      
      </p><div class="screenshot">
    <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="564"><tr><td><img src="images/tutorials_and_users_guides/tug.application/image006.jpg" width="564" alt="Screenshot of JMX console monitoring UIMA components"></td></tr></table></div>
  </div>
    
    <p>Each of the nodes under <span class="quote">&#8220;<span class="quote"><code class="literal">org.apache.uima</code></span>&#8221;</span> in the tree represents one
      of the UIMA Analysis Engines in the application that you connected to. You can select one of the analysis engines
      to view its performance statistics in the view at the right.</p>
    
    <p>Probably the most useful statistic is <span class="quote">&#8220;<span class="quote">CASes Per Second</span>&#8221;</span>, which is the number of CASes that
      this AE has processed divided by the amount of time spent in the AE's process method, in seconds. Note that this is
      the total elapsed time, not CPU time. Even so, it can be useful to compare the <span class="quote">&#8220;<span class="quote">CASes Per Second</span>&#8221;</span>
      numbers of all of your Analysis Engines to discover where the bottlenecks occur in your application.</p>
    
    <p>The <code class="literal">AnalysisTime</code>, <code class="literal">BatchProcessCompleteTime</code>, and
      <code class="literal">CollectionProcessCompleteTime</code> properties show the total elapsed time, in
      milliseconds, that has been spent in the AnalysisEngine's <code class="literal">process(), batchProcessComplete(),
      </code>and <code class="literal">collectionProcessComplete()</code> methods, respectively. (Note that for
      CAS Multipliers, time spent in the <code class="literal">hasNext()</code> and <code class="literal">next()</code> methods is
      also counted towards the AnalysisTime.)</p>
    
    <p>Note that once your UIMA application terminates, you can no longer view the statistics through the JMX
      console. If you want to use JMX to view processes that have completed, you will need to write your application so
      that the JVM remains running after processing completes, waiting for some user signal before
      terminating.</p>
    
    <p>It is possible to override the default JMX MBean names UIMA uses, for
      example to better organize the UIMA MBeans with respect to MBeans exposed by
      other parts of your application.  This is done using the
      <code class="literal">AnalysisEngine.PARAM_MBEAN_NAME_PREFIX</code> additional parameter 
      when creating your AnalysisEngine:
        
        </p><pre class="programlisting">  //set up Map with custom JMX MBean name prefix
  Map paramMap = new HashMap();
  paramMap.put(AnalysisEngine.PARAM_MBEAN_NAME_PREFIX,
               "org.myorg:category=MyApp");
        
  // create Analysis Engine
  AnalysisEngine ae = 
      UIMAFramework.produceAnalysisEngine(specifier, paramMap);
</pre><p>    
    </p>
    <p>Similary, you can use the <code class="literal">AnalysisEngine.PARAM_MBEAN_SERVER</code>
      parameter to specify a particular instance of a JMX MBean Server with which UIMA
      should register the MBeans.  If no specified then the default is to register with
      the platform MBeanServer (Java 5+ only).</p>
        
    <p>More information on JMX can be found in the <a class="ulink" href="http://java.sun.com/j2se/1.5.0/docs/api/javax/management/package-summary.html#package_description" target="_top">
      Java 5 documentation</a>.</p>    
  </div>
  
  <div class="section" title="3.9.&nbsp;Performance Tuning Options"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="tug.application.pto">3.9.&nbsp;Performance Tuning Options</h2></div></div></div>
  

  <p>
  	There are a small number of performance tuning options available to
  	influence the runtime behavior of UIMA applications. Performance
  	tuning options need to be set programmatically when an analysis
  	engine is created. You simply create a Java Properties object with
  	the relevant options and pass it to the UIMA framework on the call
  	to create an analysis engine. Below is an example.
  	
  	</p><pre class="programlisting">
  	  XMLParser parser = UIMAFramework.getXMLParser();
      ResourceSpecifier spec = parser.parseResourceSpecifier(
            new XMLInputSource(descriptorFile));
      // Create a new properties object to hold the settings.
      Properties performanceTuningSettings = new Properties();
      // Set the initial CAS heap size.
      performanceTuningSettings.setProperty(
            UIMAFramework.CAS_INITIAL_HEAP_SIZE, 
            "1000000");
      // Disable JCas cache.
      performanceTuningSettings.setProperty(
            UIMAFramework.JCAS_CACHE_ENABLED, 
            "false");
      // Create a wrapper properties object that can
      // be passed to the framework.
      Properties additionalParams = new Properties();
      // Set the performance tuning properties as value to
      // the appropriate parameter.
      additionalParams.put(
            Resource.PARAM_PERFORMANCE_TUNING_SETTINGS, 
            performanceTuningSettings);
      // Create the analysis engine with the parameters.
      // The second, unused argument here is a custom 
      // resource manager.
      this.ae = UIMAFramework.produceAnalysisEngine(
          spec, null, additionalParams);
  	
  	</pre><p>
  </p>
  
  <p>
  The following options are supported:
  </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
  <p><code class="literal">UIMAFramework.JCAS_CACHE_ENABLED</code>: allows you to disable
  the JCas cache (true/false).  The JCas cache is an internal datastructure that caches any JCas 
  object created
  by the CAS.  This may result in better performance for applications that make extensive use of
  the JCas, but also incurs a steep memory overhead.  If you're processing large documents and have
  memory issues, you should disable this option.  In general, just try running a few experiments to
  see what setting works better for your application.  The JCas cache is enabled by default.  
  </p>
  </li><li class="listitem">
  <p><code class="literal">UIMAFramework.CAS_INITIAL_HEAP_SIZE</code>: set the initial CAS heap size in
  number of cells (integer valued).  The CAS uses 32bit integer cells, so four times the initial 
  size is the
  approximate minimum size of the CAS in bytes.  This is another space/time trade-off as growing
  the CAS heap is relatively expensive.  On the other hand, setting the initial size too high is
  wasting memory.  Unless you know you are processing very small or very large documents, you should
  probably leave this option unchanged.
  </p>
  </li><li class="listitem">
  <p><code class="literal">UIMAFramework.PROCESS_TRACE_ENABLED</code>: enable the process trace mechanism
  (true/false).  When enabled, UIMA tracks the time spent in individual components of an aggregate 
  AE or CPE.  For more information, see the API documentation of 
  <code class="literal">org.apache.uima.util.ProcessTrace</code>.
  </p>
  </li><li class="listitem">
  <p><code class="literal">UIMAFramework.SOCKET_KEEPALIVE_ENABLED</code>: enable socket KeepAlive
  (true/false).  This setting is currently only supported by Vinci clients.  Defaults to 
  <code class="literal">true</code>.
  </p>
  </li></ul></div><p>
  </p>
  

  </div>
  
<div class="footnotes"><br><hr width="100" align="left"><div class="footnote">
        <p><sup>[<a name="ftn.d4e1694" href="#d4e1694" class="para">7</a>] </sup> Both the UIMA Collection Processing Manager framework and the remote deployment services framework
          have implementations which use CAS pools in this manner, and thereby relieve the annotator developer of
          the necessity to make their annotators thread-safe.</p> </div></div></div>
  <div class="chapter" title="Chapter&nbsp;4.&nbsp;Flow Controller Developer's Guide" id="ugr.tug.fc"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;4.&nbsp;Flow Controller Developer's Guide</h2></div></div></div>
  
  
  <p>A Flow Controller is a component that plugs into an Aggregate Analysis Engine. When a CAS is input to the
    Aggregate, the Flow Controller determines the order in which the components of that aggregate are invoked on that
    CAS. The ability to provide your own Flow Controller implementation is new as of release 2.0 of UIMA.</p>
  
  <p>Flow Controllers may decide the flow dynamically, based on the contents of the CAS. So, as just one example,
    you could develop a Flow Controller that first sends each CAS to a Language Identification Annotator and then,
    based on the output of the Language Identification Annotator, routes that CAS to an Annotator that is specialized
    for that particular language.</p>
  
  <div class="section" title="4.1.&nbsp;Developing the Flow Controller Code"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.fc.developing_fc_code">4.1.&nbsp;Developing the Flow Controller Code</h2></div></div></div>
    
    
    <div class="section" title="4.1.1.&nbsp;Flow Controller Interface Overview"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.fc.fc_interface_overview">4.1.1.&nbsp;Flow Controller Interface Overview</h3></div></div></div>
      
      
      <p>Flow Controller implementations should extend from the
        <code class="literal">JCasFlowController_ImplBase</code> or
        <code class="literal">CasFlowController_ImplBase</code> classes, depending on which CAS interface they prefer
        to use. As with other types of components, the Flow Controller ImplBase classes define optional
        <code class="literal">initialize</code>, <code class="literal">destroy</code>, and <code class="literal">reconfigure</code>
        methods. They also define the required method <code class="literal">computeFlow</code>.</p>
      
      <p>The <code class="literal">computeFlow</code> method is called by the framework whenever a new CAS enters the
        Aggregate Analysis Engine. It is given the CAS as an argument and must return an object which implements the
        <code class="literal">Flow</code> interface (the Flow object). The Flow Controller developer must define this
        object. It is the object that is responsible for routing this particular CAS through the components of the
        Aggregate Analysis Engine. For convenience, the framework provides basic implementation of flow objects
        in the classes CasFlow_ImplBase and JCasFlow_ImplBase; use the JCas one if you are using the JCas interface
        to the CAS.</p>
      
      <p>The framework then uses the Flow object and calls its <code class="literal">next()</code> method, which returns
        a <code class="literal">Step</code> object (implemented by the UIMA Framework) that indicates what to do next with
        this CAS next. There are three types of steps currently supported:</p>
      
      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p><code class="literal">SimpleStep</code>, which specifies a single Analysis Engine that should receive
            the CAS next.</p>
        </li><li class="listitem">
          <p><code class="literal">ParallelStep</code>, which specifies that multiple Analysis Engines should
            receive the CAS next, and that the relative order in which these Analysis Engines execute does not
            matter. Logically, they can run in parallel. The runtime is not obligated to actually execute them in
            parallel, however, and the current implementation will execute them serially in an arbitrary
            order.</p>
        </li><li class="listitem">
          <p><code class="literal">FinalStep</code>, which indicates that the flow is completed. </p>
        </li></ul></div>
      
      <p>After executing the step, the framework will call the Flow object's <code class="literal">next()</code>
        method again to determine the next destination, and this will be repeated until the Flow Object indicates
        that processing is complete by returning a <code class="literal">FinalStep</code>.</p>
      
      <p>The Flow Controller has access to a <code class="literal">FlowControllerContext</code>, which is a subtype of
        <code class="literal">UimaContext</code>. In addition to the configuration parameter and resource access
        provided by a <code class="literal">UimaContext</code>, the <code class="literal">FlowControllerContext</code> also
        gives access to the metadata for all of the Analysis Engines that the Flow Controller can route CASes to. Most
        Flow Controllers will need to use this information to make routing decisions. You can get a handle to the
        <code class="literal">FlowControllerContext</code> by calling the <code class="literal">getContext()</code> method
        defined in <code class="literal">JCasFlowController_ImplBase</code> and
        <code class="literal">CasFlowController_ImplBase</code>. Then, the
        <code class="literal">FlowControllerContext.getAnalysisEngineMetaDataMap</code> method can be called to get a
        map containing an entry for each of the Analysis Engines in the Aggregate. The keys in this map are the same as
        the delegate analysis engine keys specified in the aggregate descriptor, and the values are the
        corresponding <code class="literal">AnalysisEngineMetaData</code> objects.</p>
      
      <p>Finally, the Flow Controller has optional methods <code class="literal">addAnalysisEngines</code> and
        <code class="literal">removeAnalysisEngines</code>. These methods are intended to notify the Flow Controller if
        new Analysis Engines are available to route CASes to, or if previously available Analysis Engines are no
        longer available. However, the current version of the Apache UIMA framework does not support dynamically
        adding or removing Analysis Engines to/from an aggregate, so these methods are not currently called. Future
        versions may support this feature. </p>
    </div>
    
    <div class="section" title="4.1.2.&nbsp;Example Code"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.fc.example_code">4.1.2.&nbsp;Example Code</h3></div></div></div>
      
      
      <p>This section walks through the source code of an example Flow Controller that simluates a simple version
        of the <span class="quote">&#8220;<span class="quote">Whiteboard</span>&#8221;</span> flow model. At each step of the flow, the Flow Controller looks it all of the
        available Analysis Engines that have not yet run on this CAS, and picks one whose input requirements are
        satisfied.</p>
      
      <p>The Java class for the example is
        <code class="literal">org.apache.uima.examples.flow.WhiteboardFlowController</code> and the source code is
        included in the UIMA SDK under the <code class="literal">examples/src</code> directory.</p>
      
      <div class="section" title="4.1.2.1.&nbsp;The WhiteboardFlowController Class"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.fc.whiteboard">4.1.2.1.&nbsp;The WhiteboardFlowController Class</h4></div></div></div>
        
        
        
        <pre class="programlisting">public class WhiteboardFlowController 
          extends CasFlowController_ImplBase {
  public Flow computeFlow(CAS aCAS) 
          throws AnalysisEngineProcessException {
    WhiteboardFlow flow = new WhiteboardFlow();
    // As of release 2.3.0, the following is not needed,
    //   because the framework does this automatically
    // flow.setCas(aCAS); 
                        
    return flow;
  }

  class WhiteboardFlow extends CasFlow_ImplBase {
     // Discussed Later
  }
}</pre>
        
        <p>The <code class="literal">WhiteboardFlowController</code> extends from
          <code class="literal">CasFlowController_ImplBase</code> and implements the
          <code class="literal">computeFlow</code> method. The implementation of the <code class="literal">computeFlow</code>
          method is very simple; it just constructs a new <code class="literal">WhiteboardFlow</code> object that will be
          responsible for routing this CAS.  The framework will add a handle to that CAS
          which it will later use to make its routing decisions.</p>
        
        <p>Note that we will have one instance of <code class="literal">WhiteboardFlow</code> per CAS, so if there are
          multiple CASes being simultaneously processed there will not be any confusion.</p>
        
      </div>
      <div class="section" title="4.1.2.2.&nbsp;The WhiteboardFlow Class"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.fc.whiteboardflow">4.1.2.2.&nbsp;The WhiteboardFlow Class</h4></div></div></div>
        
        
        
        <pre class="programlisting">class WhiteboardFlow extends CasFlow_ImplBase {
  private Set mAlreadyCalled = new HashSet();

  public Step next() throws AnalysisEngineProcessException {
    // Get the CAS that this Flow object is responsible for routing.
    // Each Flow instance is responsible for a single CAS.
    CAS cas = getCas();

    // iterate over available AEs
    Iterator aeIter = getContext().getAnalysisEngineMetaDataMap().
        entrySet().iterator();
    while (aeIter.hasNext()) {
      Map.Entry entry = (Map.Entry) aeIter.next();
      // skip AEs that were already called on this CAS
      String aeKey = (String) entry.getKey();
      if (!mAlreadyCalled.contains(aeKey)) {
        // check for satisfied input capabilities 
        //(i.e. the CAS contains at least one instance
        // of each required input
        AnalysisEngineMetaData md = 
            (AnalysisEngineMetaData) entry.getValue();
        Capability[] caps = md.getCapabilities();
        boolean satisfied = true;
        for (int i = 0; i &lt; caps.length; i++) {
          satisfied = inputsSatisfied(caps[i].getInputs(), cas);
          if (satisfied)
            break;
        }
        if (satisfied) {
          mAlreadyCalled.add(aeKey);
          if (mLogger.isLoggable(Level.FINEST)) {
            getContext().getLogger().log(Level.FINEST, 
                "Next AE is: " + aeKey);
          }
          return new SimpleStep(aeKey);
        }
      }
    }
    // no appropriate AEs to call - end of flow
    getContext().getLogger().log(Level.FINEST, "Flow Complete.");
    return new FinalStep();
  }

  private boolean inputsSatisfied(TypeOrFeature[] aInputs, CAS aCAS) {
      //implementation detail; see the actual source code
  }
}</pre>
        
        <p>Each instance of the <code class="literal">WhiteboardFlowController</code> is responsible for routing a
          single CAS. A handle to the CAS instance is available by calling the <code class="literal">getCas()</code> method,
          which is a standard method defined on the <code class="literal">CasFlow_ImplBase </code>superclass.</p>
        
        <p>Each time the <code class="literal">next</code> method is called, the Flow object iterates over the metadata
          of all of the available Analysis Engines (obtained via the call to <code class="literal">getContext().
          getAnalysisEngineMetaDataMap)</code> and sees if the input types declared in an
          AnalysisEngineMetaData object are satisfied by the CAS (that is, the CAS contains at least one instance of
          each declared input type). The exact details of checking for instances of types in the CAS are not discussed
          here &#8211; see the WhiteboardFlowController.java file for the complete source.</p>
        
        <p>When the Flow object decides which AnalysisEngine should be called next, it indicates this by
          creating a SimpleStep object with the key for that AnalysisEngine and returning it:</p>
        
        <pre class="programlisting">return new SimpleStep(aeKey);</pre>
        
        <p>The Flow object keeps a list of which Analysis Engines it has invoked in the
          <code class="literal">mAlreadyCalled</code> field, and never invokes the same Analysis Engine twice. Note this
          is not a hard requirement. It is acceptable to design a FlowController that invokes the same Analysis
          Engine more than once. However, if you do this you must make sure that the flow will eventually
          terminate.</p>
        
        <p>If there are no Analysis Engines left whose input requirements are satisfied, the Flow object signals
          the end of the flow by returning a FinalStep object:</p>
        
        <pre class="programlisting">return new FinalStep();</pre>
        
        <p>Also, note the use of the logger to write tracing messages indicating the decisions made by the Flow
          Controller. This is a good practice that helps with debugging if the Flow Controller is behaving in an
          unexpected way.</p>
      </div>
    </div>
  </div>
  
  <div class="section" title="4.2.&nbsp;Creating the Flow Controller Descriptor"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.fc.creating_fc_descriptor">4.2.&nbsp;Creating the Flow Controller Descriptor</h2></div></div></div>
    
    
    <p>To create a Flow Controller Descriptor in the CDE, use File <span class="symbol">&#8594;</span> New <span class="symbol">&#8594;</span> Other
      <span class="symbol">&#8594;</span> UIMA <span class="symbol">&#8594;</span> Flow Controller Descriptor File:
      
      
      </p><div class="screenshot">
    <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="545"><tr><td><img src="images/tutorials_and_users_guides/tug.fc/image002.jpg" width="545" alt="Screenshot of Eclipse new object wizard showing Flow Controller"></td></tr></table></div>
  </div>
    
    <p>This will bring up the Overview page for the Flow Controller Descriptor:
      
      
      </p><div class="screenshot">
    <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="545"><tr><td><img src="images/tutorials_and_users_guides/tug.fc/image004.jpg" width="545" alt="Screenshot of Component Descriptor Editor Overview page for new Flow Controller"></td></tr></table></div>
  </div>
    
    <p>Type in the Java class name that implements the Flow Controller, or use the <span class="quote">&#8220;<span class="quote">Browse</span>&#8221;</span> button
      to select it. You must select a Java class that implements the <code class="literal">FlowController</code>
      interface.</p>
    
    <p>Flow Controller Descriptors are very similar to Primitive Analysis Engine Descriptors &#8211; for
      example you can specify configuration parameters and external resources if you wish.</p>
    
    <p>If you wish to edit a Flow Controller Descriptor by hand, see section <a href="references.html#ugr.ref.xml.component_descriptor.flow_controller" class="olink">Section&nbsp;2.5, &#8220;Flow Controller Descriptors&#8221;</a> for the syntax.</p>
  </div>
  
  <div class="section" title="4.3.&nbsp;Adding a Flow Controller to an Aggregate Analysis Engine"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.fc.adding_fc_to_aggregate">4.3.&nbsp;Adding a Flow Controller to an Aggregate Analysis Engine</h2></div></div></div>
    
    
    
    <p>To use a Flow Controller you must add it to an Aggregate Analysis Engine. You can only have one Flow
      Controller per Aggregate Analysis Engine. In the Component Descriptor Editor, the Flow Controller is
      specified on the Aggregate page, as a choice in the flow control kind - pick <span class="quote">&#8220;<span class="quote">User-defined Flow</span>&#8221;</span>.
      When you do, the Browse and Search buttons underneath become active, and allow you to specify an existing Flow
      Controller Descriptor, which when you select it, will be imported into the aggregate descriptor.
      
      
      </p><div class="screenshot">
    <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="446"><tr><td><img src="images/tutorials_and_users_guides/tug.fc/image006.jpg" width="446" alt="Screenshot of Component Descriptor Editor Aggregate page showing selecting user-defined flow"></td></tr></table></div>
  </div>
    
    <p>The key name is created automatically from the name element in the Flow Controller Descriptor being
      imported. If you need to change this name, you can do so by switching to the <span class="quote">&#8220;<span class="quote">Source</span>&#8221;</span> view using the
      bottom tabs, and editing the name in the XML source.</p>
    
    <p>If you edit your Aggregate Analysis Engine Descriptor by hand, the syntax for adding a Flow Controller is:
      
      
      </p><pre class="programlisting">  &lt;delegateAnalysisEngineSpecifiers&gt;
    ...
  &lt;/delegateAnalysisEngineSpecifiers&gt;  
  <span class="bold"><strong>&lt;flowController key=<span class="quote">&#8220;<span class="quote">[String]</span>&#8221;</span>&gt;
    &lt;import .../&gt; 
  &lt;/flowController&gt;</strong></span></pre>
    
    <p>As usual, you can use either in import by location or import by name &#8211; see <a href="references.html#ugr.ref.xml.component_descriptor.imports" class="olink">Section&nbsp;2.2, &#8220;Imports&#8221;</a>.</p>
    
    <p>The key that you assign to the FlowController can be used elsewhere in the Aggregate Analysis Engine
      Descriptor &#8211; in parameter overrides, resource bindings, and Sofa mappings.</p>
  </div>
  
  <div class="section" title="4.4.&nbsp;Adding a Flow Controller to a Collection Processing Engine"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.fc.adding_fc_to_cpe">4.4.&nbsp;Adding a Flow Controller to a Collection Processing Engine</h2></div></div></div>
    
    
    
    <p>Flow Controllers cannot be added directly to Collection Processing Engines. To use a Flow Controller in a
      CPE you first need to wrap the part of your CPE that requires complex flow control into an Aggregate Analysis
      Engine, and then add the Aggregate Analysis Engine to your CPE. The CPE's deployment and error handling
      options can then only be configured for the entire Aggregate Analysis Engine as a unit.</p>
    
  </div>
  
  <div class="section" title="4.5.&nbsp;Using Flow Controllers with CAS Multipliers"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.fc.using_fc_with_cas_multipliers">4.5.&nbsp;Using Flow Controllers with CAS Multipliers</h2></div></div></div>
    
    
    <p>If you want your Flow Controller to work inside an Aggregate Analysis Engine that contains a CAS Multiplier
      (see <a href="tutorials_and_users_guides.html#ugr.tug.cm" class="olink">Chapter&nbsp;7, <i>CAS Multiplier Developer's Guide</i></a>), there are additional
      things you must consider.</p>
    
    <p>When your Flow Controller routes a CAS to a CAS Multiplier, the CAS Multiplier may produce new CASes that
      then will also need to be routed by the Flow Controller. When a new output CAS is produced, the framework will call
      the <code class="literal">newCasProduced</code> method on the Flow object that was managing the flow of the parent CAS 
      (the one that was input to the CAS Multiplier). The <code class="literal">newCasProduced</code> method must create a new Flow 
      object that will be responsible for routing the new output CAS.</p>
    
    <p>In the <code class="literal">CasFlow_ImplBase</code> and <code class="literal">JCasFlow_ImplBase</code> classes, the
      <code class="literal">newCasProduced</code> method is defined to throw an exception indicating that the Flow
      Controller does not handle CAS Multipliers. If you want your Flow Controller to properly deal with CAS
      Multipliers you must override this method.</p>
        
    <p>If your Flow class extends <code class="literal">CasFlow_ImplBase</code>, the method signature to override is:           
      </p><pre class="programlisting">protected Flow newCasProduced(CAS newOutputCas, String producedBy)</pre><p>
    </p>
    
    <p>If your Flow class extends <code class="literal">JCasFlow_ImplBase</code>, the method signature to override is:
      </p><pre class="programlisting">protected Flow newCasProduced(JCas newOutputCas, String producedBy)</pre><p>
    </p>  
    
    <p>Also, there is a variant of <code class="literal">FinalStep</code> which can only be specified for output CASes
      produced by CAS Multipliers within the Aggregate Analysis Engine containing the Flow Controller. This
      version of <code class="literal">FinalStep</code> is produced by the calling the constructor with a
      <code class="literal">true</code> argument, and it causes the CAS to be immediately released back to the pool. No
      further processing will be done on it and it will not be output from the aggregate. This is the way that you can
      build an Aggregate Analysis Engine that outputs some new CASes but not others. Note that if you never want any new
      CASes to be output from the Aggregate Analysis Engine, you don't need to use this; instead just declare
      <code class="literal">&lt;outputsNewCASes&gt;false&lt;/outputsNewCASes&gt;</code> in your Aggregate Analysis
      Engine Descriptor as described in <a href="tutorials_and_users_guides.html#ugr.tug.cm.aggregate_cms" class="olink">Section&nbsp;7.3.3, &#8220;Aggregate CAS Multipliers&#8221;</a>.</p>
    
    <p>For more information on how CAS Multipliers interact with Flow Controllers, see 
      <a href="tutorials_and_users_guides.html#ugr.tug.cm.cm_and_fc" class="olink">Section&nbsp;7.3.2, &#8220;CAS Multipliers and Flow Control&#8221;</a>.
    </p>
  </div>
  
  <div class="section" title="4.6.&nbsp;Continuing the Flow When Exceptions Occur"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.fc.continuing_when_exceptions_occur">4.6.&nbsp;Continuing the Flow When Exceptions Occur</h2></div></div></div>
    
    <p> If an exception occurs when processing a CAS, the framework may call the method     
      </p><pre class="programlisting">boolean continueOnFailure(String failedAeKey, Exception failure)</pre><p>
      on the Flow object that was managing the flow of that CAS. If this method returns <code class="literal">true</code>, then
      the framework may continue to call the <code class="literal">next()</code> method to continue routing the CAS. If this
      method returns <code class="literal">false</code> (the default), the framework will not make any more calls to the
      <code class="literal">next()</code> method. </p>
    <p>In the case where the last Step was a ParallelStep, if at least one of the destinations resulted in a failure,
      then <code class="literal">continueOnFailure</code> will be called to report one of the failures. If this method
      returns true, but one of the other destinations in the ParallelStep resulted in a failure, then the
      <code class="literal">continueOnFailure</code> method will be called again to report the next failure. This
      continues until either this method returns false or there are no more failures. </p>
    <p>Note that it is possible for processing of a CAS to be aborted without this method being called. This method
      is only called when an attempt is being made to continue processing of the CAS following an exception, which may
      be an application configuration decision.</p>
    <p>In any case, if processing is aborted by the framework for any reason, including because
      <code class="literal">continueOnFailure</code> returned false, the framework will call the
      <code class="literal">Flow.aborted()</code> method to allow the Flow object to clean up any resources.</p>   
    <p>For an example of how to continue after an exception, see the example
      code <code class="literal">org.apache.uima.examples.flow.AdvancedFixedFlowController</code>, in
      the <code class="literal">examples/src</code> directory of the UIMA SDK.  This exampe also demonstrates the use of
      <code class="literal">ParallelStep</code>.</p>
  </div>
</div>
  <div class="chapter" title="Chapter&nbsp;5.&nbsp;Annotations, Artifacts, and Sofas" id="ugr.tug.aas"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;5.&nbsp;Annotations, Artifacts, and Sofas</h2></div></div></div>
  
  
  
  <p>Up to this point, the documentation has focused on analyzing strings of Unicode text,
    producing subtypes of Annotations which reference offsets in those strings. This
    chapter generalizes this concept and shows how other kinds of artifacts can be handled,
    including non-text things like audio and images, and how you can define your own kinds of
    <span class="quote">&#8220;<span class="quote">annotations</span>&#8221;</span> for these.</p>
  
  <div class="section" title="5.1.&nbsp;Terminology"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.aas.terminology">5.1.&nbsp;Terminology</h2></div></div></div>
    
    
    <div class="section" title="5.1.1.&nbsp;Artifact"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aas.artifact">5.1.1.&nbsp;Artifact</h3></div></div></div>
      
      
      <p>The Artifact is the unstructured thing being analyzed by an annotator. It could
        be an HTML web page, an image, a video stream, a recorded audio conversation, an MPEG-4
        stream, etc. Artifacts are often restructured in the course of processing to
        facilitate particular kinds of analysis. For instance, an HTML page may be converted
        into a <span class="quote">&#8220;<span class="quote">de-tagged</span>&#8221;</span> version. Annotators at different places in the
        pipeline may be analyzing different versions of the artifact.</p>
      
    </div>
    
    <div class="section" title="5.1.2.&nbsp;Subject of Analysis &#8212; Sofa"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aas.sofa">5.1.2.&nbsp;Subject of Analysis &#8212; Sofa</h3></div></div></div>
      
      
      <p>Each representation of an Artifact is called a Subject of Analysis, abbreviated
        using the acronym <span class="quote">&#8220;<span class="quote">Sofa</span>&#8221;</span> which stands for <span class="underline">S</span>ubject <span class="underline">
        OF</span> <span class="underline">A</span>nalysis. Annotation
        metadata, which have explicit designations of sub-regions of the artifact to which
        they apply, are always associated with a particular Sofa. For instance, an
        annotation over text specifies two features, the begin and end, which represent the
        character offsets into the text string Sofa being analyzed.</p>
      
      <p>Other examples of representations of Artifacts, which could be Sofas include:
        An HTML web page, a detagged web page, the translated text of that document, an audio or
        video stream, closed-caption text from a video stream, etc.</p>
      
      <p>Often, there is one Sofa being analyzed in a CAS. The next chapter will show how
        UIMA facilitates working with multiple representations of an artifact at the same
        time, in the same CAS.</p>
      
    </div>
  </div>
  
  <div class="section" title="5.2.&nbsp;Formats of Sofa Data"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.aas.sofa_data_formats">5.2.&nbsp;Formats of Sofa Data</h2></div></div></div>
    
    
    <p>Sofa data can be Java Unicode Strings, Feature Structure arrays of primitive
      types, or a URI which references remote data available via a network
      connection.</p>
    
    <p>The arrays of primitive types can be things like byte arrays or float arrays, and are
      intended to be used for artifacts like audio data, image data, etc.</p>
    
    <p>The URI form holds a URI specification String.</p>
    
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Sofa data can be "serialized" using an XML format; when it is, the String data 
      being serialized must not include invalid XML characters.  See
      <a class="xref" href="#ugr.tug.xmi_emf.xml_character_issues" title="8.3.1.&nbsp;Character Encoding Issues with XML Serialization">Section&nbsp;8.3.1, &#8220;Character Encoding Issues with XML Serialization&#8221;</a>.
      </p></div>
    
  </div>
  
  <div class="section" title="5.3.&nbsp;Setting and Accessing Sofa Data"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.aas.setting_accessing_sofa_data">5.3.&nbsp;Setting and Accessing Sofa Data</h2></div></div></div>
    
    
    <div class="section" title="5.3.1.&nbsp;Setting Sofa Data"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aas.setting_sofa_data">5.3.1.&nbsp;Setting Sofa Data</h3></div></div></div>
      
      
      <p>When a CAS is created, you can set its Sofa Data, just one time; this property
        insures that metadata describing regions of the Sofa remain valid. As a consequence,
        the following methods that set data for a given Sofa can only be called once for a given
        Sofa.</p>
      
      <p>The following methods on the CAS set the Sofa Data to one of the 3 formats. Assume
        that the variable <span class="quote">&#8220;<span class="quote">aCas</span>&#8221;</span> holds a reference to a CAS:</p>
      
      
      <pre class="programlisting">aCas.<span class="bold"><strong>setSofaDataString</strong></span>(document_text_string, mime_type_string);
aCas.<span class="bold"><strong>setSofaDataArray</strong></span>(feature_structure_primitive_array, mime_type_string);
aCas.<span class="bold"><strong>setSofaDataURI</strong></span>(uri_string, mime_type_string);</pre>
      
      <p>In addition, the method
        <code class="literal">aCas.setDocumentText(document_text_string)</code> may still be
        used, and is equivalent to <code class="literal">setSofaDataString(string,
        "text")</code>. The mime type is currently not used by the UIMA framework, but may
        be set and retrieved by user code.</p>
      
      <p>Feature Structure primitive arrays are all the UIMA Array types except arrays of
        Feature Structures, Strings, and Booleans. Typically, these are arrays of bytes,
        but can be other types, such as floats, longs, etc.</p>
      
      <p>The URI string should conform to the standard URI format.</p>
      
    </div>
    
    <div class="section" title="5.3.2.&nbsp;Accessing Sofa Data"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aas.accessing_sofa_data">5.3.2.&nbsp;Accessing Sofa Data</h3></div></div></div>
      
      
      <p>The analysis algorithms typically work with the Sofa data. The following
        methods on the CAS access the Sofa Data:</p>
      
      
      <pre class="programlisting">String           aCas.getDocumentText();
String           aCas.getSofaDataString();
FeatureStructure aCas.getSofaDataArray();
String           aCas.getSofaDataURI();
String           aCas.getSofaMimeType();</pre>
      
      <p>The <code class="literal">getDocumentText</code> and
        <code class="literal">getSofaDataString</code> return the same text string. The
        <code class="literal">getSofaDataURI</code> returns the URI itself, not the data the URI is
        pointing to. You can use standard Java I/O capabilities to get the data associated
        with the URI, or use the UIMA Framework Streaming method described next.</p>
      
    </div>
    
    <div class="section" title="5.3.3.&nbsp;Accessing Sofa Data using a Java Stream"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aas.accessing_sofa_data_using_java_stream">5.3.3.&nbsp;Accessing Sofa Data using a Java Stream</h3></div></div></div>
      
      
      <p>The framework provides a consistent method for accessing the Sofa data,
        independent of it being stored locally, or accessed remotely using the URI. Get a Java
        InputStream instance from the Sofa data using:</p>
      
      
      <pre class="programlisting">InputStream inputStream = aCas.getSofaDataStream();</pre>
      
      <div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>If the data is local, this method
        returns a ByteArrayInputStream. This stream provides bytes.
        
        </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>If the Sofa data was set using setDocumentText or
          setSofaDataString, the String is converted to bytes by using the UTF-8
          encoding.</p></li><li class="listitem"><p>If the Sofa data was set as a DataArray, the bytes in the data array
            are serialized, high-byte first. </p></li></ul></div><p>
        </p></li><li class="listitem"><p>If the Sofa data was specified as a URI, this method returns the
          handle from url.openStream(). Java offers built-in support for several URI
          schemes including <span class="quote">&#8220;<span class="quote">FILE:</span>&#8221;</span>, <span class="quote">&#8220;<span class="quote">HTTP:</span>&#8221;</span>,
          <span class="quote">&#8220;<span class="quote">FTP:</span>&#8221;</span> and has an extensible mechanism,
          <code class="literal">URLStreamHandlerFactory</code>, for customizing access to an
          arbitrary URI. See more details at <a class="ulink" href="http://java.sun.com/j2se/1.5.0/docs/api/java/net/URLStreamHandlerFactory.html" target="_top">http://java.sun.com/j2se/1.5.0/docs/api/java/net/URLStreamHandlerFactory.html</a>
          . </p></li></ul></div>
      
    </div>
  </div>
  
  <div class="section" title="5.4.&nbsp;The Sofa Feature Structure"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.aas.sofa_fs">5.4.&nbsp;The Sofa Feature Structure</h2></div></div></div>
    
    
    <p>Information about a Sofa is contained in a special built-in Feature Structure of
      type <code class="literal">uima.cas.Sofa</code>. This feature structure is created and
      managed by the UIMA Framework; users must not create it directly. Although these Sofa
      type instances are implemented as standard feature structures, <span class="emphasis"><em>generic
      CAS APIs can not be used to create Sofas or set their features</em></span>. Instead,
      Sofas are created implicitly by the creation of new CAS views. Similarly, Sofa features
      are set by CAS methods such as <code class="literal">cas.setDocumentText()</code>.</p>
    
    <p>Features of the Sofa type include</p>
    
    <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>SofaID: Every Sofa in a CAS has a unique SofaID. SofaIDs
      are the primary handle for access. This ID is often the same as the name string given to the
      Sofa by the developer, but it can be mapped to a different name (see <a href="tutorials_and_users_guides.html#ugr.tug.mvs.sofa_name_mapping" class="olink">Section&nbsp;6.4, &#8220;Sofa Name Mapping&#8221;</a>.</p></li><li class="listitem"><p>Mime type: This string feature can be used to describe the type of the
        data represented by a Sofa. It is not used by the framework; the framework provides
        APIs to set and get its value.</p></li><li class="listitem"><p>Sofa Data: The Sofa data itself. This data can be resident in the CAS or
        it can be a reference to data outside the CAS. </p></li></ul></div>
    
  </div>
  
  <div class="section" title="5.5.&nbsp;Annotations"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.aas.annotations">5.5.&nbsp;Annotations</h2></div></div></div>
    
    
    <p>Annotators add meta data about a Sofa to the CAS. It is often useful to have this
      metadata denote a region of the Sofa to which it applies. For instance, assuming the Sofa
      is a String, the metadata might describe a particular substring as the name of a person.
      The built-in UIMA type, uima.tcas.Annotation, has two extra features that enable this
      - the begin and end features - which denote a character position offset into the text
      string being analyzed.</p>
    
    <p>The concept of <span class="quote">&#8220;<span class="quote">annotations</span>&#8221;</span> can be generalized for non-string
      kinds of Sofas. For instance, an audio stream might have an audio annotation which
      describes sounds regions in terms of floating point time offsets in the Sofa. An image
      annotation might use two pairs of x,y coordinates to define the region the annotation
      applies to.</p>
    
    <div class="section" title="5.5.1.&nbsp;Built-in Annotation types"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aas.built_in_annotation_types">5.5.1.&nbsp;Built-in Annotation types</h3></div></div></div>
      
      
      <p>The built-in CAS type, <code class="literal">uima.tcas.Annotation</code>, is just one
        kind of definition of an Annotation. It was designed for annotating text strings, and
        has begin and end features which describe which substring of the Sofa being
        annotated.</p>
      
      <p>For applications which have other kinds of Sofas, the UIMA developer will design
        their own kinds of Annotation types, as needed to describe an annotation, by
        declaring new types which are subtypes of
        <code class="literal">uima.cas.AnnotationBase</code>. For instance, for images, you
        might have the concept of a rectangular region to which the annotation applies. In
        this case, you might describe the region with 2 pairs of x, y coordinates.</p>
      
    </div>
    
    <div class="section" title="5.5.2.&nbsp;Annotations have an associated Sofa"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.aas.annotations_associated_sofa">5.5.2.&nbsp;Annotations have an associated Sofa</h3></div></div></div>
      
      
      <p>Annotations are always associated with a particular Sofa. In subsequent
        chapters, you will learn how there can be multiple Sofas associated with an artifact;
        which Sofa an annotation refers to is described by the Annotation feature structure
        itself.</p>
      
      <p>All annotation types extend from the built-in type uima.cas.AnnotationBase.
        This type has one feature, a reference to the Sofa associated with the annotation.
        This value is currently used by the Framework to support the getCoveredText() method
        on the annotation instance - this returns the portion of a text Sofa that the
        annotation spans. It also is used to insure that the Annotation is indexed only in the
        CAS View associated with this Sofa.</p>
    </div>
  </div>
  
  <div class="section" title="5.6.&nbsp;AnnotationBase"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.aas.annotationbase">5.6.&nbsp;AnnotationBase</h2></div></div></div>
    
    
    <p>A built-in type, <code class="literal">uima.cas.AnnotationBase</code>, is provided by
      UIMA to allow users to extend the Annotation capabilities to different kinds of
      Annotations. The <code class="literal">AnnotationBase</code> type has one feature, named
      <code class="literal">sofa</code>, which holds a reference to the
      <code class="literal">Sofa</code> feature structure with which this annotation is associated. 
      The <code class="literal">sofa</code> feature is automatically set when creating an annotation 
      (meaning &#8212; any type derived from the built-in 
      <code class="literal">uima.cas.AnnotationBase</code> type); it should not be set by the user.</p>
    
    <p>There is one method, <code class="literal">getView</code>(), provided by
      <code class="literal">AnnotationBase</code> that returns the CAS View for the Sofa the
      annotation is pointing at. Note that this method always returns a CAS, even when applied
      to JCas annotation instances.</p>
    
    <p>The built-in type <code class="literal">uima.tcas.Annotation</code> extends
      <code class="literal">uima.cas.AnnotationBase</code> and adds two features, a begin and an
      end feature, which are suitable for identifying a span in a text string that the
      annotation applies to. Users may define other extensions to
      <code class="literal">AnnotationBase</code> with alternative specifications that can
      denote a particular region within the subject of analysis, as appropriate to their
      application.</p>
    
  </div>
</div>
  <div class="chapter" title="Chapter&nbsp;6.&nbsp;Multiple CAS Views of an Artifact" id="ugr.tug.mvs"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;6.&nbsp;Multiple CAS Views of an Artifact</h2></div></div></div>
  
  
  
  <p>UIMA provides an extension to the basic model of the CAS which supports analysis of
    multiple views of the same artifact, all contained with the CAS. This chapter describes
    the concepts, terminology, and the API and XML extensions that enable this.</p>
  
  <p>Multiple CAS Views can simplify things when different versions of the artifact are
    needed at different stages of the analysis. They are also key to enabling multimodal
    analysis where the initial artifact is transformed from one modality to another, or where
    the artifact itself is multimodal, such as the audio, video and closed-captioned text
    associated with an MPEG object. Each representation of the artifact can be analyzed
    independently with the standard UIMA programming model; in addition, multi-view
    components and applications can be constructed.</p>
  
  <p>UIMA supports this by augmenting the CAS with additional light-weight CAS objects,
    one for each view, where these objects share most of the same underlying CAS, except for two
    things: each view has its own set of indexed Feature Structures, and each view has its own
    subject of analysis (Sofa) - its own version of the artifact being analyzed. The Feature
    Structure instances themselves are in the shared part of the CAS; only the entries in the
    indexes are unique for each CAS view.</p>
  
  <p>All of these CAS view objects are kept together with the CAS, and passed as a unit
    between components in a UIMA application. APIs exist which allow components and
    applications to switch among the various view objects, as needed.</p>
  
  <p>Feature Structures may be indexed in multiple views, if necessary. New methods on CAS
    Views facilitate adding or removing Feature Structures to or from their index
    repositories:</p>
  
  
  <pre class="programlisting">aView.addFsToIndexes(aFeatureStructure) 
aView.removeFsFromIndexes(aFeatureStructure)</pre>
  
  <p>specify the view in which this Feature Structure should be added to or removed from the
    indexes.</p>
  
  <div class="section" title="6.1.&nbsp;CAS Views and Sofas"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.mvs.cas_views_and_sofas">6.1.&nbsp;CAS Views and Sofas</h2></div></div></div>
    
    
    <p>Sofas (see <a href="tutorials_and_users_guides.html#ugr.tug.aas.sofa" class="olink">Section&nbsp;5.1.2, &#8220;Subject of Analysis &#8212; Sofa&#8221;</a>) and CAS Views are linked. In this implementation,
      every CAS view has one associated Sofa, and every Sofa has one associated CAS
      View.</p>
    
    <div class="section" title="6.1.1.&nbsp;Naming CAS Views and Sofas"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.mvs.naming_views_sofas">6.1.1.&nbsp;Naming CAS Views and Sofas</h3></div></div></div>
      
      
      <p>The developer assigns a name to the View / Sofa, which is a simple string
        (following the rules for Java identifiers, usually without periods, but see special
        exception below). These names are declared in the component XML metadata, and are
        used during assembly and by the runtime to enable switching among multiple Views of
        the CAS at the same time.</p>
      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>The name is called the Sofa name, for historical reasons, but it applies
      equally to the View. In the rest of this chapter, we'll refer to it as the Sofa
      name.</p></div>
      
      <p>Some applications contain components that expect a variable number of Sofas as
        input or output. An example of a component that takes a variable number of input Sofas
        could be one that takes several translations of a document and merges them, where each
        translation was in a separate Sofa. </p>
      
      <p> You can specify a variable number of input or output sofa names, where each name
        has the same base part, by writing the base part of the name (with no periods), followed
        by a period character and an asterisk character (.*). These denote sofas that have
        names matching the base part up to the period; for example, names such as
        <code class="literal">base_name_part.TTX_3d</code> would match a specification of
        <code class="literal">base_name_part.*</code>.</p>
      
    </div>
    
    <div class="section" title="6.1.2.&nbsp;Multi-View, Single-View components &amp; applications"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.mvs.multi_view_and_single_view">6.1.2.&nbsp;Multi-View, Single-View components &amp; applications</h3></div></div></div>
      
      
      
      <p>Components and applications can be written to be Multi-View or Single-View.
        Most components used as primitive building blocks are expected to be Single-View.
        UIMA provides capabilities to combine these kinds of components with Multi-View
        components when assembling analysis aggregates or applications.</p>
      
      <p>Single-View components and applications use only one subject of analysis, and
        one CAS View. The code and descriptors for these components do not use the facilities
        described in this chapter.</p>
      
      <p>Conversely, Multi-View components and applications are aware of the
        possibility of multiple Views and Sofas, and have code and XML descriptors that
        create and manipulate them.</p>
      
    </div>
  </div>
  
  <div class="section" title="6.2.&nbsp;Multi-View Components"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.mvs.multi_view_components">6.2.&nbsp;Multi-View Components</h2></div></div></div>
    
    <div class="section" title="6.2.1.&nbsp;How UIMA decides if a component is Multi-View"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.mvs.deciding_multi_view">6.2.1.&nbsp;How UIMA decides if a component is Multi-View</h3></div></div></div>
      
      
      
      <p>Every UIMA component has an associated XML Component Descriptor. Multi-View
        components are identified simply as those whose descriptors declare one or more Sofa
        names in their Capability sections, as inputs or outputs. If a Component Descriptor
        does not mention any input or output Sofa names, the framework treats that component
        as a Single-View component.</p>
      
      <p>A Multi-View component is passed a special kind of a CAS object, called a base CAS,
        which it must use to switch to the particular view it wishes to process. The base CAS
        object itself has no Sofa and no ability to use Indexes; only the views have that
        capability.</p>
      
    </div>
    
    <div class="section" title="6.2.2.&nbsp;Multi-View: additional capabilities"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.mvs.additional_capabilities">6.2.2.&nbsp;Multi-View: additional capabilities</h3></div></div></div>
      
      
      <p>Additional capabilities provided for components and applications aware of the
        possibilities of multiple Views and Sofas include:</p>
      
      <div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>Creating new Views, and for
        each, setting up the associated Sofa data</p></li><li class="listitem"><p>Getting a reference to an existing View and its associated Sofa, by
          name </p></li><li class="listitem"><p>Specifying a view in which to index a particular Feature Structure
          instance </p></li></ul></div>
      
    </div>
    
    <div class="section" title="6.2.3.&nbsp;Component XML metadata"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.mvs.component_xml_metadata">6.2.3.&nbsp;Component XML metadata</h3></div></div></div>
      
      
      <p>Each Multi-View component that creates a Sofa or wants to switch to a specific
        previously created Sofa must declare the name for the Sofa in the capabilities
        section. For example, a component expecting as input a web document in html format and
        creating a plain text document for further processing might declare:</p>
      
      
      <pre class="programlisting">&lt;capabilities&gt;
  &lt;capability&gt;
    &lt;inputs/&gt;
    &lt;outputs/&gt;
    &lt;inputSofas&gt;
<span class="bold"><strong>      &lt;sofaName&gt;rawContent&lt;/sofaName&gt;</strong></span>
    &lt;/inputSofas&gt;
    &lt;outputSofas&gt;
<span class="bold"><strong>      &lt;sofaName&gt;detagContent&lt;/sofaName&gt;</strong></span>
    &lt;/outputSofas&gt;
  &lt;/capability&gt;
&lt;/capabilities&gt;</pre>
      
      <p>Details on this specification are found in <a href="references.html#ugr.ref.xml.component_descriptor" class="olink">Chapter&nbsp;2, <i>Component Descriptor Reference</i></a>. The Component Descriptor
        Editor supports Sofa declarations on the <a href="tools.html#ugr.tools.cde.capabilities" class="olink">Section&nbsp;1.9, &#8220;Capabilities Page&#8221;</a>.</p>
      
    </div>
  </div>
  
  <div class="section" title="6.3.&nbsp;Sofa Capabilities and APIs for Applications"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.mvs.sofa_capabilities_and_apis_for_apps">6.3.&nbsp;Sofa Capabilities and APIs for Applications</h2></div></div></div>
    
    
    
    <p>In addition to components, applications can make use of these capabilities. When
      an application creates a new CAS, it also creates the initial view of that CAS - and this
      view is the object that is returned from the create call. Additional views beyond this
      first one can be dynamically created at any time. The application can use the Sofa APIs
      described in <a href="tutorials_and_users_guides.html#ugr.tug.aas" class="olink">Chapter&nbsp;5, <i>Annotations, Artifacts, and Sofas</i></a> to specify the data to be analyzed.</p>
    
    <p>If an Application creates a new CAS, the initial CAS that is created will be a view
      named <span class="quote">&#8220;<span class="quote">_InitialView</span>&#8221;</span>. This name can be used in the application and in
      Sofa Mapping (see the next section) to refer to this otherwise unnamed view.</p>
    
  </div>
  
  <div class="section" title="6.4.&nbsp;Sofa Name Mapping"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.mvs.sofa_name_mapping">6.4.&nbsp;Sofa Name Mapping</h2></div></div></div>
    
    
    <p>Sofa Name mapping is the mechanism which enables UIMA component developers to
      choose locally meaningful Sofa names in their source code and let aggregate,
      collection processing engine developers, and application developers connect output
      Sofas created in one component to input Sofas required in another.</p>
    
    <p>At a given aggregation level, the assembler or application developer defines
      names for all the Sofas, and then specifies how these names map to the contained
      components, using the Sofa Map.</p>
    
    <p>Consider annotator code to create a new CAS view:</p>
    
    
    <pre class="programlisting">CAS viewX = cas.createView("X");</pre>
    
    <p>Or code to get an existing CAS view:</p>
    
    <pre class="programlisting">CAS viewX = cas.getView("X");</pre>
    
    <p>Without Sofa name mapping the SofaID for the new Sofa will be <span class="quote">&#8220;<span class="quote">X</span>&#8221;</span>.
      However, if a name mapping for <span class="quote">&#8220;<span class="quote">X</span>&#8221;</span> has been specified by the aggregate or
      CPE calling this annotator, the actual SofaID in the CAS can be different.</p>
    
    <p>All Sofas in a CAS must have unique names. This is accomplished by mapping all
      declared Sofas as described in the following sections. An attempt to create a Sofa with a
      SofaID already in use will throw an exception.</p>
    
    <p>Sofa name mapping must not use the <span class="quote">&#8220;<span class="quote">.</span>&#8221;</span> (period) character. Runtime Sofa
      mapping maps names up to the <span class="quote">&#8220;<span class="quote">.</span>&#8221;</span> and appends the period and the following
      characters to the mapped name.</p>
    
    <p>To get a Java Iterator for all the views in a CAS:</p>
    
    <pre class="programlisting">Iterator allViews = cas.getViewIterator();</pre>
    
    <p>To get a Java Iterator for selected views in a CAS, for example, views whose name 
      is either exactly equal to namePrefix or is of the form namePrefix.suffix, where suffix 
      can be any String:</p>
    
    <pre class="programlisting">Iterator someViews = cas.getViewIterator(String namePrefix);</pre>

      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>Sofa name mapping is applied to namePrefix.</p></div>
    
    <p>Sofa name mappings are not currently supported for remote Analysis Engines.
      See <a class="xref" href="#ugr.tug.mvs.name_mapping_remote_services" title="6.4.5.&nbsp;Name Mapping for Remote Services">Section&nbsp;6.4.5, &#8220;Name Mapping for Remote Services&#8221;</a>.</p>
               
    <div class="section" title="6.4.1.&nbsp;Name Mapping in an Aggregate Descriptor"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.mvs.name_mapping_aggregate">6.4.1.&nbsp;Name Mapping in an Aggregate Descriptor</h3></div></div></div>
      
      
      <p>For each component of an Aggregate, name mapping specifies the conversion
        between component Sofa names and names at the aggregate level.</p>
      
      <p>Here's an example. Consider two Multi-View annotators to be assembled
        into an aggregate which takes an audio segment consisting of spoken English and
        produces a German text translation.</p>
      
      <p>The first annotator takes an audio segment as input Sofa and produces a text
        transcript as output Sofa. The annotator designer might choose these Sofa names to be
        <span class="quote">&#8220;<span class="quote">AudioInput</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">TranscribedText</span>&#8221;</span>.</p>
      
      <p>The second annotator is designed to translate text from English to German. This
        developer might choose the input and output Sofa names to be
        <span class="quote">&#8220;<span class="quote">EnglishDocument</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">GermanDocument</span>&#8221;</span>,
        respectively.</p>
      
      <p>In order to hook these two annotators together, the following section would be
        added to the top level of the aggregate descriptor:</p>
      
      
      <pre class="programlisting">&lt;sofaMappings&gt;
  &lt;sofaMapping&gt;
    &lt;componentKey&gt;SpeechToText&lt;/componentKey&gt;
    &lt;componentSofaName&gt;AudioInput&lt;/componentSofaName&gt;
    &lt;aggregateSofaName&gt;SegementedAudio&lt;/aggregateSofaName&gt;
  &lt;/sofaMapping&gt;
  &lt;sofaMapping&gt;
    &lt;componentKey&gt;SpeechToText&lt;/componentKey&gt;
    &lt;componentSofaName&gt;TranscribedText&lt;/componentSofaName&gt;
    &lt;aggregateSofaName&gt;EnglishTranscript&lt;/aggregateSofaName&gt;
  &lt;/sofaMapping&gt;
  &lt;sofaMapping&gt;
    &lt;componentKey&gt;EnglishToGermanTranslator&lt;/componentKey&gt;
    &lt;componentSofaName&gt;EnglishDocument&lt;/componentSofaName&gt;
    &lt;aggregateSofaName&gt;EnglishTranscript&lt;/aggregateSofaName&gt;
  &lt;/sofaMapping&gt;
  &lt;sofaMapping&gt;
    &lt;componentKey&gt;EnglishToGermanTranslator&lt;/componentKey&gt;
    &lt;componentSofaName&gt;GermanDocument&lt;/componentSofaName&gt;
    &lt;aggregateSofaName&gt;GermanTranslation&lt;/aggregateSofaName&gt;
  &lt;/sofaMapping&gt;
&lt;/sofaMappings&gt;</pre>
      
      <p>The Component Descriptor Editor supports Sofa name mapping in aggregates and
        simplifies the task. See <a href="tools.html#ugr.tools.cde.capabilities.sofa_name_mapping" class="olink">Section&nbsp;1.9.1, &#8220;Sofa (and view) name mappings&#8221;</a> for details.</p> 
    </div>
    
    <div class="section" title="6.4.2.&nbsp;Name Mapping in a CPE Descriptor"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.mvs.name_mapping_cpe">6.4.2.&nbsp;Name Mapping in a CPE
      Descriptor</h3></div></div></div>
      
      <p>The CPE descriptor aggregates together a Collection Reader and CAS Processors
        (Annotators and CAS Consumers). Sofa mappings can be added to the following elements
        of CPE descriptors: <code class="literal">&lt;collectionIterator&gt;</code>,
        <code class="literal">&lt;casInitializer&gt;</code> and the
        <code class="literal">&lt;casProcessor&gt;</code>. To be consistent with the
        organization of CPE descriptors, the maps for the CPE descriptor are distributed
        among the XML markup for each of the parts (collectionIterator, casInitializer,
        casProcessor). Because of this the<code class="literal">
        &lt;componentKey&gt;</code> element is not needed. Finally, rather than
        sub-elements for the parts, the XML markup for these uses attributes. See <a href="references.html#ugr.ref.xml.cpe_descriptor.descriptor.cas_processors.individual.sofa_name_mappings" class="olink">Section&nbsp;3.6.1.3, &#8220;&lt;sofaNameMappings&gt; Element&#8221;</a>.</p>
      
      <p>Here's an example. Let's use the aggregate from the previous section
        in a collection processing engine. Here we will add a Collection Reader that outputs
        audio segments in an output Sofa named <span class="quote">&#8220;<span class="quote">nextSegment</span>&#8221;</span>. Remember to
        declare an output Sofa nextSegment in the collection reader description.
        We'll add a CAS Consumer in the next section.</p>
      
      
      <pre class="programlisting">&lt;collectionReader&gt;
  &lt;collectionIterator&gt;
    &lt;descriptor&gt;
    . . .
    &lt;/descriptor&gt;
    &lt;configurationParameterSettings&gt;...&lt;/configurationParameterSettings&gt;
<span class="bold"><strong>    &lt;sofaNameMappings&gt;
      &lt;sofaNameMapping componentSofaName="nextSegment"
                       cpeSofaName="SegementedAudio"/&gt;
      &lt;/sofaNameMappings&gt;
</strong></span>  &lt;/collectionIterator&gt;
  &lt;casInitializer/&gt;
&lt;collectionReader&gt;</pre>
      
      <p>At this point the CAS Processor section for the aggregate does not need any Sofa
        mapping because the aggregate input Sofa has the same name,
        <span class="quote">&#8220;<span class="quote">SegementedAudio</span>&#8221;</span>, as is being produced by the Collection
        Reader.</p>
      
    </div>
    
    <div class="section" title="6.4.3.&nbsp;Specifying the CAS View for a Single-View Component"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.mvs.specifying_cas_view_for_single_view">6.4.3.&nbsp;Specifying the CAS View for a Single-View Component</h3></div></div></div>
      
      
      
      <p>Single-View components receive a Sofa named <span class="quote">&#8220;<span class="quote">_InitialView</span>&#8221;</span>, or
        a Sofa that is mapped to this name.</p>
      
      <p>For example, assume that the CAS Consumer to be used in our CPE is a Single-View
        component that expects the analysis results associated with the input CAS, and that
        we want it to use the results from the translated German text Sofa. The following
        mapping added to the CAS Processor section for the CPE will instruct the CPE to get the
        CAS view for the German text Sofa and pass it to the CAS Consumer:</p>
      
      
      <pre class="programlisting">&lt;casProcessor&gt;
  . . .
  <span class="bold"><strong>&lt;sofaNameMappings&gt;
    &lt;sofaNameMapping componentSofaName="_InitialView"
                           cpeSofaName="GermanTranslation"/&gt;
  &lt;sofaNameMappings&gt;
</strong></span>&lt;/casProcessor&gt;</pre>
      
      <p><a name="ugr.tug.mvs.sofa_mapping_leav_out_name"></a>An alternative syntax for
        this kind of mapping is to simply leave out the component sofa name in this
        case.</p>
      
    </div>
    
    <div class="section" title="6.4.4.&nbsp;Name Mapping in a UIMA Application"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.mvs.name_mapping_application">6.4.4.&nbsp;Name Mapping in a UIMA Application</h3></div></div></div>
      
      
      <p>Applications which instantiate UIMA components directly using the
        UIMAFramework methods can also create a top level Sofa mapping using the
        <span class="quote">&#8220;<span class="quote">additional parameters</span>&#8221;</span> capability.</p>
      
      
      <pre class="programlisting">//create a "root" UIMA context for your whole application

UimaContextAdmin rootContext =
   UIMAFramework.newUimaContext(UIMAFramework.getLogger(),
      UIMAFramework.newDefaultResourceManager(),
      UIMAFramework.newConfigurationManager());

input = new XMLInputSource("test.xml");
desc = UIMAFramework.getXMLParser().parseAnalysisEngineDescription(input);

//setup sofa name mappings using the api

HashMap sofamappings = new HashMap();
sofamappings.put("localName1", "globalName1");
sofamappings.put("localName2", "globalName2");
  
//create a UIMA Context for the new AE we are about to create

//first argument is unique key among all AEs used in the application
UimaContextAdmin childContext = rootContext.createChild("myAE", sofamap);

//instantiate AE, passing the UIMA Context through the additional
//parameters map

Map additionalParams = new HashMap();
additionalParams.put(Resource.PARAM_UIMA_CONTEXT, childContext);

AnalysisEngine ae = 
        UIMAFramework.produceAnalysisEngine(desc,additionalParams);</pre>
      
      <p>Sofa mappings are applied from the inside out, i.e., local to global. First, any
        aggregate mappings are applied, then any CPE mappings, and finally, any specified
        using this <span class="quote">&#8220;<span class="quote">additional parameters</span>&#8221;</span> capability.</p>
      
    </div>
    
    <div class="section" title="6.4.5.&nbsp;Name Mapping for Remote Services"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.mvs.name_mapping_remote_services">6.4.5.&nbsp;Name Mapping for Remote Services</h3></div></div></div>
      
      
      <p>Currently, no client-side Sofa mapping information is passed from a UIMA client
        to a remote service. This can cause complications for UIMA services in a Multi-View
        application.</p>
      
      <p>Remote Multi-View services will work only if the service is Single-View, or if the 
        Sofa names expected by the service exactly match the Sofa names produced by the client.</p>
      
      <p>If your application requires Sofa mappings for a remote Analysis Engine, you
        can wrap your remotely deployed AE in an aggregate (on the remote side), and specify
        the necessary Sofa mappings in the descriptor for that aggregate.</p>
    </div>
  </div>
  
  <div class="section" title="6.5.&nbsp;JCas extensions for Multiple Views"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.mvs.jcas_extensions_for_multi_views">6.5.&nbsp;JCas extensions for Multiple Views</h2></div></div></div>
    
    
    <p>The JCas interface to the CAS can be used with any / all views, as well as the base CAS
      sent to Multi-View components. You can always get a JCas object from an existing CAS
      object by using the method getJCas(); this call will create the JCas if it doesn't
      already exist. If it does exist, it just returns the existing JCas that corresponds to
      the CAS.</p>
    
    <p>JCas implements the getView(...) method, enabling switching to other named
      views, just like the corresponding method on the CAS. The JCas version, however,
      returns JCas objects, instead of CAS objects, corresponding to the view.</p>
  </div>
  
  <div class="section" title="6.6.&nbsp;Sample Multi-View Application"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.mvs.sample_application">6.6.&nbsp;Sample Multi-View Application</h2></div></div></div>
    
    
    <p>The UIMA SDK contains a simple Sofa example application which demonstrates many
      Sofa specific concepts and methods. The source code for the application driver is in
      <code class="literal">examples/src/org/apache/uima/examples/SofaExampleApplication.java</code>
      and the Multi-View annotator is given in
      <code class="literal">SofaExampleAnnotator.java</code> in the same directory.</p>
    
    <p>This sample application demonstrates a language translator annotator which
      expects an input text Sofa with an English document and creates an output text Sofa
      containing a German translation. Some of the key Sofa concepts illustrated here
      include:</p>
    
    <div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>Sofa creation.</p>
      </li><li class="listitem"><p>Access of multiple CAS views.</p></li><li class="listitem"><p>Unique feature structure index space for each view.</p>
        </li><li class="listitem"><p>Feature structures containing cross references between
        annotations in different CAS views.</p></li><li class="listitem"><p>The strong affinity of annotations with a specific Sofa. </p>
        </li></ul></div>
    
    <div class="section" title="6.6.1.&nbsp;Annotator Descriptor"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.mvs.sample_application.descriptor">6.6.1.&nbsp;Annotator Descriptor</h3></div></div></div>
      
      
      <p>The annotator descriptor in
        <code class="literal">examples/descriptors/analysis_engine/SofaExampleAnnotator.xml</code>
        declares an input Sofa named <span class="quote">&#8220;<span class="quote">EnglishDocument</span>&#8221;</span> and an output Sofa
        named <span class="quote">&#8220;<span class="quote">GermanDocument</span>&#8221;</span>. A custom type
        <span class="quote">&#8220;<span class="quote">CrossAnnotation</span>&#8221;</span> is also defined:</p>
      
      
      <pre class="programlisting">&lt;typeDescription&gt;
  &lt;name&gt;sofa.test.CrossAnnotation&lt;/name&gt;
  &lt;description/&gt;
  &lt;supertypeName&gt;uima.tcas.Annotation&lt;/supertypeName&gt;
  &lt;features&gt;
    &lt;featureDescription&gt;
      &lt;name&gt;otherAnnotation&lt;/name&gt;
      &lt;description/&gt;
      &lt;rangeTypeName&gt;uima.tcas.Annotation&lt;/rangeTypeName&gt;
    &lt;/featureDescription&gt;
  &lt;/features&gt;
&lt;/typeDescription&gt;</pre>
      
      <p>The <code class="literal">CrossAnnotation</code> type is derived from
        <code class="literal">uima.tcas.Annotation </code>and includes one new feature: a
        reference to another annotation.</p>
      
    </div>
    
    <div class="section" title="6.6.2.&nbsp;Application Setup"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.mvs.sample_application.setup">6.6.2.&nbsp;Application Setup</h3></div></div></div>
      
      
      <p>The application driver instantiates an analysis engine,
        <code class="literal">seAnnotator</code>, from the annotator descriptor, obtains a new
        base CAS using that engine's CAS definition, and creates the expected input
        Sofa using:</p>
      
      
      <pre class="programlisting">CAS cas = seAnnotator.newCAS();
CAS aView = cas.createView("EnglishDocument");</pre>
      
      <p>Since <code class="literal">seAnnotator</code> is a primitive component, and no Sofa
        mapping has been defined, the SofaID will be <span class="quote">&#8220;<span class="quote">EnglishDocument</span>&#8221;</span>.
        Local Sofa data is set using:</p>
      
      
      <pre class="programlisting">aView.setDocumentText("this beer is good");</pre>
      
      <p>At this point the CAS contains all necessary inputs for the translation
        annotator and its process method is called.</p>
      
    </div>
    
    <div class="section" title="6.6.3.&nbsp;Annotator Processing"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.mvs.sample_application.annotator_processing">6.6.3.&nbsp;Annotator Processing</h3></div></div></div>
      
      
      <p>Annotator processing consists of parsing the English document into individual
        words, doing word-by-word translation and concatenating the translations into a
        German translation. Analysis metadata on the English Sofa will be an annotation for
        each English word. Analysis metadata on the German Sofa will be a
        <code class="literal">CrossAnnotation</code> for each German word, where the
        <code class="literal">otherAnnotation</code> feature will be a reference to the associated
        English annotation.</p>
      
      <p>Code of interest includes two CAS views:</p>
      
      
      <pre class="programlisting">// get View of the English text Sofa
englishView = aCas.getView("EnglishDocument");

// Create the output German text Sofa
germanView = aCas.createView("GermanDocument");</pre>
      
      <p>the indexing of annotations with the appropriate view:</p>
      
      
      <pre class="programlisting">englishView.addFsToIndexes(engAnnot);
. . .
germanView.addFsToIndexes(germAnnot);</pre>
      
      <p>and the combining of metadata belonging to different Sofas in the same feature
        structure:</p>
      
      
      <pre class="programlisting">// add link to English text
germAnnot.setFeatureValue(other, engAnnot);</pre>
      
    </div>
    
    <div class="section" title="6.6.4.&nbsp;Accessing the results of analysis"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.mvs.sample_application.accessing_results">6.6.4.&nbsp;Accessing the results of analysis</h3></div></div></div>
      
      
      <p>The application needs to get the results of analysis, which may be in different
        views. Analysis results for each Sofa are dumped independently by iterating over all
        annotations for each associated CAS view. For the English Sofa:</p>
      
      
      <pre class="programlisting">//get annotation iterator for this CAS
FSIndex anIndex = aView.getAnnotationIndex();
FSIterator anIter = anIndex.iterator();
while (anIter.isValid()) {
  AnnotationFS annot = (AnnotationFS) anIter.get();
  System.out.println(" " + annot.getType().getName()
                         + ": " + annot.getCoveredText());
  anIter.moveToNext();
}</pre>
      
      <p>Iterating over all German annotations looks the same, except for the
        following:</p>
      
      
      <pre class="programlisting">if (annot.getType() == cross) {
  AnnotationFS crossAnnot =
          (AnnotationFS) annot.getFeatureValue(other);
  System.out.println("   other annotation feature: "
          + crossAnnot.getCoveredText());
}</pre>
      
      <p>Of particular interest here is the built-in Annotation type method
        <code class="literal">getCoveredText()</code>. This method uses the
        <span class="quote">&#8220;<span class="quote">begin</span>&#8221;</span> and <span class="quote">&#8220;<span class="quote">end</span>&#8221;</span> features of the annotation to create
        a substring from the CAS document. The SofaRef feature of the annotation is used to
        identify the correct Sofa's data from which to create the substring.</p>
      
      <p>The example program output is:</p>
      
      
      <pre class="programlisting">---Printing all annotations for English Sofa---
uima.tcas.DocumentAnnotation: this beer is good
uima.tcas.Annotation: this
uima.tcas.Annotation: beer
uima.tcas.Annotation: is
uima.tcas.Annotation: good
      
---Printing all annotations for German Sofa---
uima.tcas.DocumentAnnotation: das bier ist gut
sofa.test.CrossAnnotation: das
 other annotation feature: this
sofa.test.CrossAnnotation: bier
 other annotation feature: beer
sofa.test.CrossAnnotation: ist
 other annotation feature: is
sofa.test.CrossAnnotation: gut
 other annotation feature: good</pre>
      
    </div>
  </div>
  
  <div class="section" title="6.7.&nbsp;Views API Summary"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.mvs.views_api_summary">6.7.&nbsp;Views API Summary</h2></div></div></div>
    
    
    <p>The recommended way to deliver a particular CAS view to a <span class="bold-italic">Single-View</span> component is to use by Sofa-mapping in
      the CPE and/or aggregate descriptors.</p>
    
    <p>For <span class="bold-italic">Multi-View </span> components or
      applications, the following methods are used to create or get a reference to a CAS view
      for a particular Sofa:</p>
    
    <p>Creating a new View:</p>
    
    
    <pre class="programlisting">JCas newView = aJCas.createView(String localNameOfTheViewBeforeMapping);
CAS  newView = aCAS .createView(String localNameOfTheViewBeforeMapping);</pre>
    
    <p>Getting a View from a CAS or JCas:</p>
    
    
    <pre class="programlisting">JCas myView = aJCas.getView(String localNameOfTheViewBeforeMapping);
CAS  myView = aCAS .getView(String localNameOfTheViewBeforeMapping);
Iterator allViews = aCasOrJCas.getViewIterator();
Iterator someViews = aCasOrJCas.getViewIterator(String localViewNamePrefix);</pre>
    
    <p>The following methods are useful for all annotators and applications:</p>
    
    <p>Setting Sofa data for a CAS or JCas:</p>
    
    
    <pre class="programlisting">aCasOrJCas.setDocumentText(String docText);
aCasOrJCas.setSofaDataString(String docText, String mimeType);
aCasOrJCas.setSofaDataArray(FeatureStructure array, String mimeType);
aCasOrJCas.setSofaDataURI(String uri, String mimeType);</pre>
    
    <p>Getting Sofa data for a particular CAS or JCas:</p>
    
    
    <pre class="programlisting">String doc = aCasOrJCas.getDocumentText();
String doc = aCasOrJCas.getSofaDataString();
FeatureStructure array = aCasOrJCas.getSofaDataArray();
String uri = aCasOrJCas.getSofaDataURI();
InputStream is = aCasOrJCas.getSofaDataStream();</pre>
    
  </div>
  
  <div class="section" title="6.8.&nbsp;Sofa Incompatibilities between UIMA version 1 and version 2"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.mvs.sofa_incompatibilities_v1_v2">6.8.&nbsp;Sofa Incompatibilities between UIMA version 1 and version 2</h2></div></div></div>
    
    
    
    <p>A major change in version 2 is related to the support of Single-View components
      and applications. Given an analysis engine, <code class="literal">ae</code>, the API
      
      </p><pre class="programlisting">CAS cas = ae.newCas();</pre><p>
      used to return the base CAS. Now it returns a view of the Sofa named
      <span class="quote">&#8220;<span class="quote">_InitialView</span>&#8221;</span>. This Sofa will actually only be created if any Sofa data
      is set for this view. The initial view is used for Single-View applications and
      Multi-View annotators with no Sofa mapping.</p>
    
    <p>The process method of Multi-View annotators receive the base CAS, however the base
      CAS no longer has an index repository to hold <span class="quote">&#8220;<span class="quote">global</span>&#8221;</span> data. Global data
      needs to be put in a specific named CAS view of your choice.</p>
    
    <p>Because of these changes, the following scenarios will break with v2.0 clients:
      
      </p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>Any version 1.x services (you
        must migrate the services to version 2).</p></li><li class="listitem"><p>Applications or components explicitly referencing
          <span class="quote">&#8220;<span class="quote">_DefaultTextSofaName</span>&#8221;</span> in code or descriptors.</p>
          </li><li class="listitem"><p>Multi-View applications using the Base CAS index repository.
          </p></li></ul></div>
  </div>
</div>
  <div class="chapter" title="Chapter&nbsp;7.&nbsp;CAS Multiplier Developer's Guide" id="ugr.tug.cm"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;7.&nbsp;CAS Multiplier Developer's Guide</h2></div></div></div>
  
  
  
  <p>The UIMA analysis components (Annotators and CAS Consumers) described previously in this manual all take a
    single CAS as input, optionally make modifications to it, and output that same CAS. This chapter describes an
    advanced feature that became available in the UIMA SDK v2.0: a new type of analysis component called a
    <span class="emphasis"><em>CAS Multiplier</em></span>, which can create new CASes during processing.</p>
  
  <p>CAS Multipliers are often used to split a large artifact into manageable pieces. This is a common requirement
    of audio and video analysis applications, but can also occur in text analysis on very large documents. A CAS
    Multiplier would take as input a single CAS representing the large artifact (perhaps by a remote reference to the
    actual data &#8212; see <a href="tutorials_and_users_guides.html#ugr.tug.aas.sofa_data_formats" class="olink">Section&nbsp;5.2, &#8220;Formats of Sofa Data&#8221;</a>) and produce as output a series of new CASes each of which
    contains only a small portion of the original artifact.</p>
  
  <p>CAS Multipliers are not limited to dividing an artifact into smaller pieces, however. A CAS Multiplier can
    also be used to combine smaller segments together to form larger segments. In general, a CAS Multiplier is used to
    <span class="emphasis"><em>change</em></span> the segmentation of a series of CASes; that is, to change how a stream of data is
    divided among discrete CAS objects.</p>
  
  <div class="section" title="7.1.&nbsp;Developing the CAS Multiplier Code"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.cm.developing_multiplier_code">7.1.&nbsp;Developing the CAS Multiplier Code</h2></div></div></div>
    
    
    <div class="section" title="7.1.1.&nbsp;CAS Multiplier Interface Overview"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cm.cm_interface_overview">7.1.1.&nbsp;CAS Multiplier Interface Overview</h3></div></div></div>
      
      
      <p>CAS Multiplier implementations should extend from the
        <code class="literal">JCasMultiplier_ImplBase</code> or <code class="literal">CasMultiplier_ImplBase</code>
        classes, depending on which CAS interface they prefer to use. As with other types of analysis components, the
        CAS Multiplier ImplBase classes define optional <code class="literal">initialize</code>,
        <code class="literal">destroy</code>, and <code class="literal">reconfigure</code> methods. There are then three
        required methods: <code class="literal">process</code>, <code class="literal">hasNext</code>, and
        <code class="literal">next</code>. The framework interacts with these methods as follows:</p>
      
      <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
          <p>The framework calls the CAS Multiplier's <code class="literal">process</code> method, passing it an
            input CAS. The process method returns, but may hold on to a reference to the input CAS.</p>
        </li><li class="listitem">
          <p>The framework then calls the CAS Multiplier's <code class="literal">hasNext</code> method. The CAS
            Multiplier should return <code class="literal">true</code> from this method if it intends to output one or more
            new CASes (for instance, segments of this CAS), and <code class="literal">false</code> if not.</p>
        </li><li class="listitem">
          <p>If <code class="literal">hasNext</code> returned true, the framework will call the CAS Multiplier's
            <code class="literal">next</code> method. The CAS Multiplier creates a new CAS (we will see how in a moment),
            populates it, and returns it from the <code class="literal">next</code> method.</p>
        </li><li class="listitem">
          <p>Steps 2 and 3 continue until <code class="literal">hasNext</code> returns false. If the
          framework detects a situation where it needs to cancel this CAS Multiplier, it will stop
          calling the <code class="literal">hasNext</code> and <code class="literal">next</code> methods, and when
          another top-level CAS comes along it will call the annotator's <code class="literal">process</code> method again.
          User's annotator code should interpret this as a signal to cleanup 
          processing related to the previous CAS and then start processing with the new CAS.</p>
        </li></ol></div>
      
      <p>From the time when <code class="literal">process</code> is called until the <code class="literal">hasNext</code>
        method returns false (or <code class="literal">process</code> is called again), 
        the CAS Multiplier <span class="quote">&#8220;<span class="quote">owns</span>&#8221;</span> the CAS that was passed to its
        <code class="literal">process</code> method. The CAS Multiplier can store a reference to this CAS in a local field and
        can read from it or write to it during this time. Once the ending condition occurs, the CAS
        Multiplier gives up ownership of the input CAS and should no longer retain a reference to it.</p>
    </div>
    
    <div class="section" title="7.1.2.&nbsp;How to Get an Empty CAS Instance"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cm.how_to_get_empty_cas_instance">7.1.2.&nbsp;How to Get an Empty CAS Instance</h3></div></div></div>
      
      
      
      <p>The CAS Multiplier's <code class="literal">next</code> method must return a CAS instance that represents
        a new representation of the input artifact. Since CAS instances are managed by the framework, the CAS
        Multiplier cannot actually create a new CAS; instead it should request an empty CAS by calling the method:
        
        </p><pre class="programlisting">CAS getEmptyCAS()

or

JCas getEmptyJCas()</pre><p> which are
        defined on the <code class="literal">CasMultiplier_ImplBase</code> and
        <code class="literal">JCasMultiplier_ImplBase</code> classes, respectively.</p>
      
      <p>Note that if it is more convenient you can request an empty CAS during the <code class="literal">process</code> or
        <code class="literal">hasNext</code> methods, not just during the <code class="literal">next</code> method.</p>
      
      <p>By default, a CAS Multiplier is only allowed to hold one output CAS instance at a time. You must return the
        CAS from the <code class="literal">next</code> method before you can request a second CAS. If you try to call
        getEmptyCAS a second time you will get an Exception. You can change this default behavior by overriding the
        method <code class="literal">getCasInstancesRequired</code> to return the number of CAS instances that you need.
        Be aware that CAS instances consume a significant amount of memory, so setting this to a large value will cause
        your application to use a lot of RAM. So, for example, it is not a good practice to attempt to generate a large
        number of new CASes in the CAS Multiplier's <code class="literal">process</code> method. Instead, you should
        spread your processing out across the calls to the <code class="literal">hasNext</code> or
        <code class="literal">next</code> methods.</p>
      
      <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>You can only call <code class="literal">getEmptyCAS()</code> or <code class="literal">getEmptyJCas()</code>
        from your CAS Multiplier's <code class="literal">process</code>, <code class="literal">hasNext</code>, or
        <code class="literal">next</code> methods.  You cannot call it from other methods such as 
        <code class="literal">initialize</code>.  This is because the Aggregate AE's Type System is not available
        until all of the components of the aggregate have finished their initialization.
      </p></div>
      
      <p>The Type System of the empty CAS will contain all of the type definitions for all 
        components of the outermost Aggregate Analysis Engine or Collection Processing Engine
        that contains your CAS Multiplier.  Therefore downstream components that receive 
        these CASes can add new instances of any type that they define.</p>
                
      <div class="warning" title="Warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>Be careful to keep the Feature Structures that belong to each CAS separate.  You 
        cannot create references from a Feature Structure in one CAS to a Feature Structure in another CAS.
        You also cannot add a Feature Structure created in one CAS to the indexes of a different CAS.  
        If you attempt to do this, the results are undefined.      
      </p>        
      </div>
    </div>
    
    <div class="section" title="7.1.3.&nbsp;Example Code"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cm.example_code">7.1.3.&nbsp;Example Code</h3></div></div></div>
      
      
      <p>This section walks through the source code of an example CAS Multiplier that breaks text documents into
        smaller pieces. The Java class for the example is
        <code class="literal">org.apache.uima.examples.casMultiplier.SimpleTextSegmenter</code> and the source
        code is included in the UIMA SDK under the <code class="literal">examples/src</code> directory.</p>
      
      <div class="section" title="7.1.3.1.&nbsp;Overall Structure"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.cm.example_code.overall_structure">7.1.3.1.&nbsp;Overall Structure</h4></div></div></div>
        
        
        
        <pre class="programlisting">public class SimpleTextSegmenter extends JCasMultiplier_ImplBase {
  private String mDoc;
  private int mPos;
  private int mSegmentSize;
  private String mDocUri;  
  
  public void initialize(UimaContext aContext) 
          throws ResourceInitializationException
  { ... }

  public void process(JCas aJCas) throws AnalysisEngineProcessException
  { ... }

  public boolean hasNext() throws AnalysisEngineProcessException
  { ... }

  public AbstractCas next() throws AnalysisEngineProcessException
  { ... }
}</pre>
        
        <p>The <code class="literal">SimpleTextSegmenter</code> class extends
          <code class="literal">JCasMultiplier_ImplBase</code> and implements the optional
          <code class="literal">initialize</code> method as well as the required <code class="literal">process</code>,
          <code class="literal">hasNext</code>, and <code class="literal">next</code> methods. Each method is described
          below.</p>
        
      </div>
      
      <div class="section" title="7.1.3.2.&nbsp;Initialize Method"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.cm.example_code.initialize">7.1.3.2.&nbsp;Initialize Method</h4></div></div></div>
        
        
        
        <pre class="programlisting">public void initialize(UimaContext aContext) throws
                    ResourceInitializationException {
  super.initialize(aContext);
  mSegmentSize = ((Integer)aContext.getConfigParameterValue(
                            "segmentSize")).intValue();
}</pre>
        
        <p>Like an Annotator, a CAS Multiplier can override the initialize method and read configuration
          parameter values from the UimaContext. The SimpleTextSegmenter defines one parameter, <span class="quote">&#8220;<span class="quote">Segment
          Size</span>&#8221;</span>, which determines the approximate size (in characters) of each segment that it will
          produce.</p>
        
      </div>
      
      <div class="section" title="7.1.3.3.&nbsp;Process Method"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.cm.example_code.process">7.1.3.3.&nbsp;Process Method</h4></div></div></div>
        
        
        
        <pre class="programlisting">public void process(JCas aJCas) 
       throws AnalysisEngineProcessException {
  mDoc = aJCas.getDocumentText();
  mPos = 0;
  // retreive the filename of the input file from the CAS so that it can 
  // be added to each segment
  FSIterator it = aJCas.
          getAnnotationIndex(SourceDocumentInformation.type).iterator();
  if (it.hasNext()) {
    SourceDocumentInformation fileLoc = 
          (SourceDocumentInformation)it.next();
    mDocUri = fileLoc.getUri();
  }
  else {
    mDocUri = null;
  }
 }</pre>
        
        <p>The process method receives a new JCas to be processed(segmented) by this CAS Multiplier. The
          SimpleTextSegmenter extracts some information from this JCas and stores it in fields (the document text
          is stored in the field mDoc and the source URI in the field mDocURI). Recall that the CAS Multiplier is
          considered to <span class="quote">&#8220;<span class="quote">own</span>&#8221;</span> the JCas from the time when process is called until the time when hasNext
          returns false. Therefore it is acceptable to retain references to objects from the JCas in a CAS
          Multiplier, whereas this should never be done in an Annotator. The CAS Multiplier could have chosen to
          store a reference to the JCas itself, but that was not necessary for this example.</p>
        
        <p>The CAS Multiplier also initializes the mPos variable to 0. This variable is a position into the
          document text and will be incremented as each new segment is produced.</p>
        
      </div>
      
      <div class="section" title="7.1.3.4.&nbsp;HasNext Method"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.cm.example_code.hasnext">7.1.3.4.&nbsp;HasNext Method</h4></div></div></div>
        
        
        
        <pre class="programlisting">public boolean hasNext() throws AnalysisEngineProcessException {
  return mPos &lt; mDoc.length();
}</pre>
        
        <p>The job of the hasNext method is to report whether there are any additional output CASes to produce. For
          this example, the CAS Multiplier will break the entire input document into segments, so we know there will
          always be a next segment until the very end of the document has been reached.</p>
        
      </div>
      
      <div class="section" title="7.1.3.5.&nbsp;Next Method"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.cm.example_code.next">7.1.3.5.&nbsp;Next Method</h4></div></div></div>
        
        
        
        <pre class="programlisting">public AbstractCas next() throws AnalysisEngineProcessException {
  int breakAt = mPos + mSegmentSize;
  if (breakAt &gt; mDoc.length())
    breakAt = mDoc.length();
          
  // search for the next newline character. 
  // Note: this example segmenter implementation
  // assumes that the document contains many newlines. 
  // In the worst case, if this segmenter
  // is run on a document with no newlines, 
  // it will produce only one segment containing the
  // entire document text. 
  // A better implementation might specify a maximum segment size as
  // well as a minimum.
          
  while (breakAt &lt; mDoc.length() &amp;&amp; 
         mDoc.charAt(breakAt - 1) != '\n')
    breakAt++;

  JCas jcas = getEmptyJCas();
  try {
    jcas.setDocumentText(mDoc.substring(mPos, breakAt));
    // if original CAS had SourceDocumentInformation, 
          also add SourceDocumentInformatio
    // to each segment
    if (mDocUri != null) {
      SourceDocumentInformation sdi = 
          new SourceDocumentInformation(jcas);
      sdi.setUri(mDocUri);
      sdi.setOffsetInSource(mPos);
      sdi.setDocumentSize(breakAt - mPos);
      sdi.addToIndexes();

      if (breakAt == mDoc.length()) {
        sdi.setLastSegment(true);
      }
    }

    mPos = breakAt;
    return jcas;
  } catch (Exception e) {
    jcas.release();
    throw new AnalysisEngineProcessException(e);
  }
}</pre>
        
        <p>The <code class="literal">next</code> method actually produces the next segment and returns it. The
          framework guarantees that it will not call <code class="literal">next</code> unless
          <code class="literal">hasNext</code> has returned true since the last call to <code class="literal">process</code> or
          <code class="literal">next</code> .</p>
        
        <p>Note that in order to produce a segment, the CAS Multiplier must get an empty JCas to populate. This is
          done by the line:</p>
        
        <pre class="programlisting">JCas jcas = getEmptyJCas();</pre>
        
        <p>This requests an empty JCas from the framework, which maintains a pool of JCas instances to draw
          from.</p>
        
        <p>Also, note the use of the <code class="literal">try...catch</code> block to ensure that a JCas is released back
          to the pool if an exception occurs. This is very important to allow a CAS Multiplier to recover from
          errors.</p>
        
      </div>
    </div>
  </div>
  
  <div class="section" title="7.2.&nbsp;Creating the CAS Multiplier Descriptor"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.cm.creating_cm_descriptor">7.2.&nbsp;Creating the CAS Multiplier Descriptor</h2></div></div></div>
    
    
    
    <p>There is not a separate type of descriptor for a CAS Multiplier. CAS Multiplier are considered a type of
      Analysis Engine, and so their descriptors use the same syntax as any other Analysis Engine Descriptor.</p>
    
    <p>The descriptor for the <code class="literal">SimpleTextSegmenter</code> is located in the
      <code class="literal">examples/descriptors/cas_multiplier/SimpleTextSegmenter.xml</code> directory of the
      UIMA SDK.</p>
    
    <p>The Analysis Engine Description, in its <span class="quote">&#8220;<span class="quote">Operational Properties</span>&#8221;</span> section, now contains a
      new <span class="quote">&#8220;<span class="quote">outputsNewCASes</span>&#8221;</span> property which takes a Boolean value. If the Analysis Engine is a CAS
      Multiplier, this property should be set to true.</p>
    
    <p>If you use the CDE, be sure to check the <span class="quote">&#8220;<span class="quote">Outputs new CASes</span>&#8221;</span> box in the Runtime Information
      section on the Overview page, as shown here:
      
      
      </p><div class="screenshot">
    <div class="mediaobject"><table border="0" summary="manufactured viewport for HTML img" cellspacing="0" cellpadding="0" width="515"><tr><td><img src="images/tutorials_and_users_guides/tug.cas_multiplier/image002.jpg" width="515" alt="Screen shot of Component Descriptor Editor on Overview showing checking of &#34;Outputs new CASes&#34; box"></td></tr></table></div>
  </div>
    
    <p>If you edit the Analysis Engine Descriptor by hand, you need to add a
      <code class="literal">&lt;outputsNewCASes&gt;</code> element to your descriptor as shown here:</p>
    
    
    <pre class="programlisting">&lt;operationalProperties&gt;
    &lt;modifiesCas&gt;false&lt;/modifiesCas&gt;
    &lt;multipleDeploymentAllowed&gt;true&lt;/multipleDeploymentAllowed&gt;
    <span class="bold"><strong>&lt;outputsNewCASes&gt;true&lt;/outputsNewCASes&gt;</strong></span>
  &lt;/operationalProperties&gt;</pre>
    <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
    <p>The <span class="quote">&#8220;<span class="quote">modifiedCas</span>&#8221;</span> operational property refers to the input CAS, not the new output CASes
      produced. So our example SimpleTextSegmenter has modifiesCas set to false since it doesn't modify the
      input CAS. </p></div>
    
  </div>
  
  <div class="section" title="7.3.&nbsp;Using a CAS Multiplier in an Aggregate Analysis Engine"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.cm.using_cm_in_aae">7.3.&nbsp;Using a CAS Multiplier in an Aggregate Analysis Engine</h2></div></div></div>
    
    
    
    <p>You can include a CAS Multiplier as a component in an Aggregate Analysis Engine. For example, this allows
      you to construct an Aggregate Analysis Engine that takes each input CAS, breaks it up into segments, and runs a
      series of Annotators on each segment.</p>
    
    <div class="section" title="7.3.1.&nbsp;Adding the CAS Multiplier to the Aggregate"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cm.adding_cm_to_aggregate">7.3.1.&nbsp;Adding the CAS Multiplier to the Aggregate</h3></div></div></div>
      
      
      
      <p>Since CAS Multiplier are considered a type of Analysis Engine, adding them to an aggregate works the same
        way as for other Analysis Engines. Using the CDE, you just click the <span class="quote">&#8220;<span class="quote">Add...</span>&#8221;</span> button in the
        Component Engines view and browse to the Analysis Engine Descriptor of your CAS Multiplier. If editing the
        aggregate descriptor directly, just <code class="literal">import</code> the Analysis Engine Descriptor of your
        CAS Multiplier as usual.</p>
      
      <p>An example descriptor for an Aggregate Analysis Engine containing a CAS Multiplier is provided in
        <code class="literal">examples/descriptors/cas_multiplier/SegmenterAndTokenizerAE.xml</code>. This
        Aggregate runs the <code class="literal">SimpleTextSegmenter</code> example to break a large document into
        segments, and then runs each segment through the <code class="literal">SimpleTokenAndSentenceAnnotator</code>.
        Try running it in the Document Analyzer tool with a large text file as input, to see that it outputs multiple
        output CASes, one for each segment produced by the <code class="literal">SimpleTextSegmenter</code>.</p>
      
    </div>
    
    <div class="section" title="7.3.2.&nbsp;CAS Multipliers and Flow Control"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cm.cm_and_fc">7.3.2.&nbsp;CAS Multipliers and Flow Control</h3></div></div></div>
      
      
      <p>CAS Multipliers are only supported in the context of Fixed Flow or custom Flow Control. If you use the
        built-in <span class="quote">&#8220;<span class="quote">Fixed Flow</span>&#8221;</span> for your Aggregate Analysis Engine, you can position the CAS
        Multiplier anywhere in that flow. Processing then works as follows: When a CAS is input to the Aggregate AE,
        that CAS is routed to the components in the order specified by the Fixed Flow, until that CAS reaches a CAS
        Multiplier.</p>
      
      <p>Upon reaching a CAS Multiplier, if that CAS Multiplier produces new output CASes, then each output CAS
        from that CAS Multiplier will continue through the flow, starting at the node immediately after the CAS
        Multiplier in the Fixed Flow. No further processing will be done on the original input CAS after it has reached
        a CAS Multiplier &#8211; it will <span class="emphasis"><em>not</em></span> continue in the flow.</p>
      
      <p>If the CAS Multiplier does <span class="emphasis"><em>not</em></span> produce any output CASes for a given input CAS,
        then that input CAS <span class="emphasis"><em>will</em></span> continue in the flow. This behavior is appropriate, for
        example, for a CAS Multiplier that may segment an input CAS into pieces but only does so if the input CAS is
        larger than a certain size.</p>
      
      <p>It is possible to put more than one CAS Multiplier in your flow. In this case, when a new CAS output from the
        first CAS Multiplier reaches the second CAS Multiplier and if the second CAS Multiplier produces output
        CASes, then no further processing will occur on the input CAS, and any new output CASes produced by the second
        CAS Multiplier will continue the flow starting at the node after the second CAS Multiplier.</p>
      
      <p>This default behavior can be customized. The <code class="literal">FixedFlowController</code> component
        that implement's UIMA's default flow defines a configuration parameter
        <code class="literal">ActionAfterCasMultiplier</code> that can take the following values:</p>
      <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
          <p><code class="literal">continue</code> &#8211; the CAS continues on to the next element in the flow</p>
        </li><li class="listitem">
          <p><code class="literal">stop</code> &#8211; the CAS will no longer continue in the flow, and will be returned
            from the aggregate if possible.</p>
        </li><li class="listitem">
          <p><code class="literal">drop</code> &#8211; the CAS will no longer continue in the flow, and will be dropped
            (not returned from the aggregate) if possible.</p>
        </li><li class="listitem">
          <p><code class="literal">dropIfNewCasProduced</code> (the default) &#8211; if the CAS multiplier produced
            a new CAS as a result of processing this CAS, then this CAS will be dropped. If not, then this CAS will
            continue.</p>
        </li></ul></div>
      
      <p>You can override this parameter in your Aggregate Analysis Engine the same way you would override a
        parameter in a delegate Analysis Engine. But to do so you must first explicitly identify that you are using the
        <code class="literal">FixedFlowController</code> implementation by importing its descriptor into your
        aggregate as follows:</p>
      
      
      <pre class="programlisting">&lt;flowController key="FixedFlowController"&gt;
          &lt;import name="org.apache.uima.flow.FixedFlowController"/&gt;
        &lt;/flowController&gt;      </pre>
      
      <p>The parameter could then be overriden as, for example:</p>
      
      
      <pre class="programlisting">&lt;configurationParameters&gt;
          &lt;configurationParameter&gt;
            &lt;name&gt;ActionForIntermediateSegments&lt;/name&gt;
            &lt;type&gt;String&lt;/type&gt;
            &lt;multiValued&gt;false&lt;/multiValued&gt;
            &lt;mandatory&gt;false&lt;/mandatory&gt;
            &lt;overrides&gt;
              &lt;parameter&gt;
                FixedFlowController/ActionAfterCasMultiplier
              &lt;/parameter&gt;
            &lt;/overrides&gt;
          &lt;/configurationParameter&gt;   
        &lt;/configurationParameters&gt;
  
       &lt;configurationParameterSettings&gt;
         &lt;nameValuePair&gt;
           &lt;name&gt;ActionForIntermediateSegments&lt;/name&gt;
           &lt;value&gt;
             &lt;string&gt;drop&lt;/string&gt;
           &lt;/value&gt;
         &lt;/nameValuePair&gt;
       &lt;/configurationParameterSettings&gt;</pre>
      
      <p>This overriding can also be done using the Component Descriptor Editor tool. An example of an Analysis
        Engine that overrides this parameter can be found in
        <code class="literal">examples/descriptors/cas_multiplier/Segment_Annotate_Merge_AE.xml</code>. For more
        information about how to specify a flow controller as part of your Aggregate Analysis Engine descriptor, see
          <a href="tutorials_and_users_guides.html#ugr.tug.fc.adding_fc_to_aggregate" class="olink">Section&nbsp;4.3, &#8220;Adding Flow Controller to an Aggregate&#8221;</a>.</p>
      
      <p>If you would like to further customize the flow, you will need to implement a custom FlowController as
        described in <a href="tutorials_and_users_guides.html#ugr.tug.fc" class="olink">Chapter&nbsp;4, <i>Flow Controller Developer's Guide</i></a>. For example,
        you could implement a flow where a CAS that is input to a CAS Multiplier will be processed further by
        <span class="emphasis"><em>some</em></span> downstream components, but not others.</p>
      
    </div>
    
    <div class="section" title="7.3.3.&nbsp;Aggregate CAS Multipliers"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cm.aggregate_cms">7.3.3.&nbsp;Aggregate CAS Multipliers</h3></div></div></div>
      
      
      <p>An important consideration when you put a CAS Multiplier inside an Aggregate Analysis Engine is whether
        you want the Aggregate to also function as a CAS Multiplier
        &#8211; that is, whether you want the new output CASes produced within the Aggregate to be output from the
        Aggregate. This is controlled by the <code class="literal">&lt;outputsNewCASes&gt;</code> element in the
        Operational Properties of your Aggregate Analysis Engine descriptor. The syntax is the same as what was
        described in <a class="xref" href="#ugr.tug.cm.creating_cm_descriptor" title="7.2.&nbsp;Creating the CAS Multiplier Descriptor">Section&nbsp;7.2, &#8220;CAS Multiplier Descriptor&#8221;</a> .</p>
      
      <p>If you set this property to <code class="literal">true</code>, then any new output CASes produced by a CAS
        Multiplier inside this Aggregate will be output from the Aggregate. Thus the Aggregate will function as a CAS
        Multiplier and can be used in any of the ways in which a primitive CAS Multiplier can be used.</p>
      
      <p>If you set the &lt;outputsNewCASes&gt; property to <code class="literal">false</code> , then any new output
        CASes produced by a CAS Multiplier inside the Aggregate will be dropped (i.e. the CASes will be released back
        to the pool) once they have finished being processed. Such an Aggregate Analysis Engine functions just like a
        <span class="quote">&#8220;<span class="quote">normal</span>&#8221;</span> non-CAS-Multiplier Analysis Engine; the fact that CAS Multiplication is
        occurring inside it is hidden from users of that Analysis Engine.</p> <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
      <p>If you want to output some new Output CASes and not others, you need to implement a custom Flow Controller
        that makes this decision &#8212; see <a href="tutorials_and_users_guides.html#ugr.tug.fc.using_fc_with_cas_multipliers" class="olink">Section&nbsp;4.5, &#8220;Using Flow Controllers with CAS Multipliers&#8221;</a>. </p> </div>
      
    </div>
  </div>
  
  <div class="section" title="7.4.&nbsp;Using a CAS Multiplier in a Collection Processing Engine"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.cm.using_cm_in_cpe">7.4.&nbsp;Using a CAS Multiplier in a Collection Processing Engine</h2></div></div></div>
    
    
    
    <p>It is currently a limitation that CAS Multiplier cannot be deployed directly in a Collection Processing
      Engine. The only way that you can use a CAS Multiplier in a CPE is to first wrap it in an Aggregate Analysis Engine
      whose <code class="literal">outputsNewCASes </code>property is set to <code class="literal">false</code>, which in effect
      hides the existence of the CAS Multiplier from the CPE.</p>
    
    <p>Note that you can build an Aggregate Analysis Engine that consists of CAS Multipliers and Annotators,
      followed by CAS Consumers. This can simulate what a CPE would do, but without the deployment and error handling
      options that the CPE provides.</p>
    
  </div>
  
  <div class="section" title="7.5.&nbsp;Calling a CAS Multiplier from an Application"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.cm.calling_cm_from_app">7.5.&nbsp;Calling a CAS Multiplier from an Application</h2></div></div></div>
    
        
    
    <div class="section" title="7.5.1.&nbsp;Retrieving Output CASes from the CAS Multiplier"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cm.retrieving_output_cases">7.5.1.&nbsp;Retrieving Output CASes from the CAS Multiplier</h3></div></div></div>
      
      
      <p>The <code class="literal">AnalysisEngine</code> interface has the following methods that allow you to
        interact with CAS Multiplier:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
            <p><code class="literal">CasIterator processAndOutputNewCASes(CAS)</code></p>
          </li><li class="listitem">
            <p><code class="literal">JCasIterator processAndOutputNewCASes(JCas)</code></p>
          </li></ul></div>
      
      <p>From your application, you call <code class="literal">processAndOutputNewCASes</code> and pass it the input
        CAS. An iterator is returned that allows you to step through each of the new output CASes that are produced by
        the Analysis Engine.</p>
      
      <p>It is very important to realize that CASes are pooled objects and so your application must release each
        CAS (by calling the <code class="literal">CAS.release()</code> method) that it obtains from the CasIterator
        <span class="emphasis"><em>before</em></span> it calls the <code class="literal">CasIterator.next</code> method again.
        Otherwise, the CAS pool will be exhausted and a deadlock will occur.</p>
      
      <p>The example code in the class <code class="literal">org.apache.uima.examples.casMultiplier.
        CasMultiplierExampleApplication</code> illusrates this. Here is the main processing loop:</p>
      
      
      <pre class="programlisting">CasIterator casIterator = ae.processAndOutputNewCASes(initialCas);
while (casIterator.hasNext()) {
  CAS outCas = casIterator.next();

  //dump the document text and annotations for this segment
  System.out.println("********* NEW SEGMENT *********");
  System.out.println(outCas.getDocumentText());
  PrintAnnotations.printAnnotations(outCas, System.out); 

  //release the CAS (important)
  outCas.release();</pre>
      
      <p>Note that as defined by the CAS Multiplier contract in <a class="xref" href="#ugr.tug.cm.cm_interface_overview" title="7.1.1.&nbsp;CAS Multiplier Interface Overview">Section&nbsp;7.1.1, &#8220;CAS Multiplier Interface Overview&#8221;</a>, the CAS Multiplier owns the input CAS
        (<code class="literal">initialCas</code> in the example) until the last new output CAS has been produced. This means
        that the application should not try to make changes to <code class="literal">initialCas</code> until after the
        <code class="literal">CasIterator.hasNext</code> method has returned false, indicating that the segmenter has
        finished.</p>
      
      <p>Note that the processing time of the Analysis Engine is spread out over the calls to the
        <code class="literal">CasIterator's hasNext</code> and <code class="literal">next</code> methods. That is, the next
        output CAS may not actually be produced and annotated until the application asks for it. So the application
        should not expect calls to the <code class="literal">CasIterator</code> to necessarily complete quickly.</p>
      
      <p>Also, calls to the <code class="literal">CasIterator</code> may throw Exceptions indicating an error has
        occurred during processing. If an Exception is thrown, all processing of the input CAS will stop, and no more
        output CASes will be produced. There is currently no error recovery mechanism that will allow processing to
        continue after an exception.</p>
                
    </div>
    <div class="section" title="7.5.2.&nbsp;Using a CAS Multiplier with other Analysis Engines"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cm.using_cm_with_other_aes">7.5.2.&nbsp;Using a CAS Multiplier with other Analysis Engines</h3></div></div></div>
       
           
      <p>In your application you can take the output CASes from a CAS Multiplier and pass them to
        the <code class="literal">process</code> method of other Analysis Engines.  However there are some
        special considerations regarding the Type System of these CASes.</p>
      <p>By default, the output CASes of a CAS Multiplier will have a Type System that contains all
        of the types and features declared by any component in the outermost Aggregate Analysis Engine or
        Collection Processing Engine that contains the CAS Multiplier.  If in your application you
        create a CAS Multiplier and another Analysis Engine, where these are not enclosed in an aggregate,
        then the output CASes from the CAS Multiplier will not support any types or features that are 
        declared in the latter Analysis Engine but not in the CAS Multiplier.
      </p>
      <p>This can be remedied by forcing the CAS Multiplier and Analysis Engine to share a single
        <code class="literal">UimaContext</code> when they are created, as follows:
      </p><pre class="programlisting">//create a "root" UIMA context for your whole application

UimaContextAdmin rootContext =
   UIMAFramework.newUimaContext(UIMAFramework.getLogger(),
      UIMAFramework.newDefaultResourceManager(),
      UIMAFramework.newConfigurationManager());

XMLInputSource input = new XMLInputSource("MyCasMultiplier.xml");
AnalysisEngineDescription desc = UIMAFramework.getXMLParser().
        parseAnalysisEngineDescription(input);
 
//create a UIMA Context for the new AE we are about to create

//first argument is unique key among all AEs used in the application
UimaContextAdmin childContext = rootContext.createChild(
        "myCasMultiplier", Collections.EMPTY_MAP);

//instantiate CAS Multiplier AE, passing the UIMA Context through the 
//additional parameters map

Map additionalParams = new HashMap();
additionalParams.put(Resource.PARAM_UIMA_CONTEXT, childContext);

AnalysisEngine casMultiplierAE = UIMAFramework.produceAnalysisEngine(
        desc,additionalParams);

//repeat for another AE      
XMLInputSource input2 = new XMLInputSource("MyAE.xml");
AnalysisEngineDescription desc2 = UIMAFramework.getXMLParser().
        parseAnalysisEngineDescription(input2);
 
UimaContextAdmin childContext2 = rootContext.createChild(
        "myAE", Collections.EMPTY_MAP);

Map additionalParams2 = new HashMap();
additionalParams2.put(Resource.PARAM_UIMA_CONTEXT, childContext2);

AnalysisEngine myAE = UIMAFramework.produceAnalysisEngine(
        desc2, additionalParams2);</pre><p>
        
      </p>
    </div>
    
  </div>
  
  <div class="section" title="7.6.&nbsp;Using a CAS Multiplier to Merge CASes"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.cm.using_cm_to_merge_cases">7.6.&nbsp;Using a CAS Multiplier to Merge CASes</h2></div></div></div>
    
        
    
    <p>A CAS Multiplier can also be used to combine smaller CASes together to form larger CASes. In this section we
      describe how this works and walk through an example.</p>
    
    <div class="section" title="7.6.1.&nbsp;Overview of How to Merge CASes"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cm.overview_of_how_to_merge_cases">7.6.1.&nbsp;Overview of How to Merge CASes</h3></div></div></div>
      
            
      
      <div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
          <p>When the framework first calls the CAS Multiplier's <code class="literal">process</code> method,
            the CAS Multiplier requests an empty CAS (which we'll call the "merged CAS") and copies relevant data
            from the input CAS into the merged CAS. The class
            <code class="literal">org.apache.uima.util.CasCopier</code> provides utilities for copying Feature
            Structures between CASes.</p>
        </li><li class="listitem">
          <p>When the framework then calls the CAS Multiplier's <code class="literal">hasNext</code> method, the
            CAS Multiplier returns <code class="literal">false</code> to indicate that it has no output at this
            time.</p>
        </li><li class="listitem">
          <p>When the framework calls <code class="literal">process</code> again with a new input CAS, the CAS
            Multiplier copies data from that input CAS into the merged CAS, combining it with the data that was
            previously copied.</p>
        </li><li class="listitem">
          <p>Eventually, when the CAS Multiplier decides that it wants to output the merged CAS, it returns
            <code class="literal">true</code> from the <code class="literal">hasNext</code> method, and then when the framework
            subsequently calls the <code class="literal">next</code> method, the CAS Multiplier returns the merged
            CAS.</p>
        </li></ol></div> <div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
      <p>There is no explicit call to flush out any pending CASes from a CAS Multiplier when collection processing
        completes. It is up to the application to provide some mechanism to let a CAS Multiplier recognize the last CAS
        in a collection so that it can ensure that its final output CASes are complete.</p></div>
    </div>
    <div class="section" title="7.6.2.&nbsp;Example CAS Merger"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cm.example_cas_merger">7.6.2.&nbsp;Example CAS Merger</h3></div></div></div>
      
      <p>An example CAS Multiplier that merges CASes can be found is provided in the UIMA SDK. The Java class for
        this example is <code class="literal">org.apache.uima.examples.casMultiplier.SimpleTextMerger</code> and
        the source code is located under the <code class="literal">examples/src</code> directory.</p>
      <div class="section" title="7.6.2.1.&nbsp;Process Method"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.cm.example_cas_merger.process">7.6.2.1.&nbsp;Process Method</h4></div></div></div>
        
        <p>Almost all of the code for this example is in the <code class="literal">process</code> method. The first part of
          the <code class="literal">process</code> method shows how to copy Feature Structures from the input CAS to the
          "merged CAS":</p>
        
        
        <pre class="programlisting">public void process(JCas aJCas) throws AnalysisEngineProcessException {
    // procure a new CAS if we don't have one already
    if (mMergedCas == null) {
      mMergedCas = getEmptyJCas();
    }

    // append document text
    String docText = aJCas.getDocumentText();
    int prevDocLen = mDocBuf.length();
    mDocBuf.append(docText);

    // copy specified annotation types
    // CasCopier takes two args: the CAS to copy from.
    //                           the CAS to copy into.
    CasCopier copier = new CasCopier(aJCas.getCas(), mMergedCas.getCas());
    
    // needed in case one annotation is in two indexes (could    
    // happen if specified annotation types overlap)
    Set copiedIndexedFs = new HashSet(); 
    for (int i = 0; i &lt; mAnnotationTypesToCopy.length; i++) {
      Type type = mMergedCas.getTypeSystem()
          .getType(mAnnotationTypesToCopy[i]);
      FSIndex index = aJCas.getCas().getAnnotationIndex(type);
      Iterator iter = index.iterator();
      while (iter.hasNext()) {
        FeatureStructure fs = (FeatureStructure) iter.next();
        if (!copiedIndexedFs.contains(fs)) {
          Annotation copyOfFs = (Annotation) copier.copyFs(fs);
          // update begin and end
          copyOfFs.setBegin(copyOfFs.getBegin() + prevDocLen);
          copyOfFs.setEnd(copyOfFs.getEnd() + prevDocLen);
          mMergedCas.addFsToIndexes(copyOfFs);
          copiedIndexedFs.add(fs);
        }
      }
    }</pre>
        
        <p>The <code class="literal">CasCopier</code> class is used to copy Feature Structures of certain types
          (specified by a configuration parameter) to the merged CAS. The <code class="literal">CasCopier</code> does deep
          copies, meaning that if the copied FeatureStructure references another FeatureStructure, the
          referenced FeatureStructure will also be copied.</p>
        
        <p>This example also merges the document text using a separate <code class="literal">StringBuffer</code>. Note
          that we cannot append document text to the Sofa data of the merged CAS because Sofa data cannot be modified
          once it is set.</p>
        
        <p>The remainder of the <code class="literal">process</code> method determines whether it is time to output a new
          CAS. For this example, we are attempting to merge all CASes that are segments of one original artifact. This
          is done by checking the
          <code class="code">SourceDocumentInformation</code> Feature Structure in the CAS to see if its
          <code class="code">lastSegment</code> feature is set to <code class="literal">true</code>. That feature (which is set by the
          example
          <code class="code">SimpleTextSegmenter</code> discussed previously) marks the CAS as being the last segment of an
          artifact, so when the CAS Multiplier sees this segment it knows it is time to produce an output CAS.</p>
        
        
        <pre class="programlisting">// get the SourceDocumentInformation FS, 
// which indicates the sourceURI of the document
// and whether the incoming CAS is the last segment
FSIterator it = aJCas
        .getAnnotationIndex(SourceDocumentInformation.type).iterator();
if (!it.hasNext()) {
  throw new RuntimeException("Missing SourceDocumentInformation");
}
SourceDocumentInformation sourceDocInfo = 
      (SourceDocumentInformation) it.next();
if (sourceDocInfo.getLastSegment()) {
  // time to produce an output CAS
  // set the document text
  mMergedCas.setDocumentText(mDocBuf.toString());

  // add source document info to destination CAS
  SourceDocumentInformation destSDI = 
      new SourceDocumentInformation(mMergedCas);
  destSDI.setUri(sourceDocInfo.getUri());
  destSDI.setOffsetInSource(0);
  destSDI.setLastSegment(true);
  destSDI.addToIndexes();

  mDocBuf = new StringBuffer();
  mReadyToOutput = true;
}</pre>
        
        <p>When it is time to produce an output CAS, the CAS Multiplier makes final updates to the merged CAS
          (setting the document text and adding a <code class="literal">SourceDocumentInformation</code>
          FeatureStructure), and then sets the <code class="literal">mReadyToOutput</code> field to true. This field is
          then used in the <code class="literal">hasNext</code> and <code class="literal">next</code> methods.</p>
      </div>
      <div class="section" title="7.6.2.2.&nbsp;HasNext and Next Methods"><div class="titlepage"><div><div><h4 class="title" id="ugr.tug.cm.example_cas_merger.hasnext_and_next">7.6.2.2.&nbsp;HasNext and Next Methods</h4></div></div></div>
        
        <p>These methods are relatively simple:</p>
        
        
        <pre class="programlisting">public boolean hasNext() throws AnalysisEngineProcessException {
    return mReadyToOutput;
  }

  public AbstractCas next() throws AnalysisEngineProcessException {
    if (!mReadyToOutput) {
      throw new RuntimeException("No next CAS");
    }
    JCas casToReturn = mMergedCas;
    mMergedCas = null;
    mReadyToOutput = false;
    return casToReturn;
  }</pre>
        <p>When the merged CAS is ready to be output, <code class="literal">hasNext</code> will return true, and
          <code class="literal">next</code> will return the merged CAS, taking care to set the
          <code class="literal">mMergedCas</code> field to
          <code class="code">null</code> so that the next call to
          <code class="code">process</code> will start with a fresh CAS.</p>
      </div>
    </div>
    <div class="section" title="7.6.3.&nbsp;Using the SimpleTextMerger in an Aggregate Analysis Engine"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.cm.using_the_simple_text_merger_in_an_aggregate_ae">7.6.3.&nbsp;Using the SimpleTextMerger in an Aggregate Analysis Engine</h3></div></div></div>
      
      
      
      <p>An example descriptor for an Aggregate Analysis Engine that uses the
        <code class="literal">SimpleTextMerger</code> is provided in
        <code class="literal">examples/descriptors/cas_multiplier/Segment_Annotate_Merge_AE.xml</code>. This
        Aggregate first runs the <code class="literal">SimpleTextSegmenter</code> example to break a large document into
        segments. It then runs each segment through the example tokenizer and name recognizer annotators. Finally
        it runs the <code class="literal">SimpleTextMerger</code> to reassemble the segments back into one CAS. The
        <code class="literal">Name</code> annotations are copied to the final merged CAS but the <code class="literal">Token</code>
        annotations are not.</p>
      <p>This example illustrates how you can break large artifacts into pieces for more efficient processing
        and then reassemble a single output CAS containing only the results most useful to the application.
        Intermediate results such as tokens, which may consume a lot of space, need not be retained over the entire
        input artifact.</p>
      
      <p>The intermediate segments are dropped and are never output from the Aggregate Analysis Engine.  This
        is done by configuring the Fixed Flow Controller as described in 
        <a class="xref" href="#ugr.tug.cm.cm_and_fc" title="7.3.2.&nbsp;CAS Multipliers and Flow Control">Section&nbsp;7.3.2, &#8220;CAS Multipliers and Flow Control&#8221;</a>, above.</p>
      
      <p>Try running this Analysis Engine in the Document Analyzer tool with a large text file as input, to see that 
        it outputs just one CAS per input file, and that the final CAS contains only the <code class="literal">Name</code> annotations. </p>
    </div>
  </div>
</div>
  <div class="chapter" title="Chapter&nbsp;8.&nbsp;XMI and EMF Interoperability" id="ugr.tug.xmi_emf"><div class="titlepage"><div><div><h2 class="title">Chapter&nbsp;8.&nbsp;XMI and EMF Interoperability</h2></div></div></div>
  
  
  
  <div class="section" title="8.1.&nbsp;Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.xmi_emf.overview">8.1.&nbsp;Overview</h2></div></div></div>
    
    
    <p>In traditional object-oriented terms, a UIMA Type System is a class model and a UIMA CAS is an object graph.
      There are established standards in this area
      &#8211; specifically, <span class="trademark">UML</span>&reg; is an <span class="trademark">
      OMG</span>&#8482; standard for class models and XMI (XML Metadata Interchange) is an OMG standard for the XML
      representation of object graphs.</p>
    
    <p>Furthermore, the Eclipse Modeling Framework (EMF) is an open-source framework for model-based
      application development, and it is based on UML and XMI. In EMF, you define class models using a metamodel called
      Ecore, which is similar to UML. EMF provides tools for converting a UML model to Ecore. EMF can then generate Java
      classes from your model, and supports persistence of those classes in the XMI format.</p>
    
    <p>The UIMA SDK provides tools for interoperability with XMI and EMF. These tools allow conversions of UIMA
      Type Systems to and from Ecore models, as well as conversions of UIMA CASes to and from XMI format. This provides a
      number of advantages, including:</p>
    
    <div class="blockquote"><blockquote class="blockquote">
      <p>You can define a model using a UML Editor, such as Rational Rose or EclipseUML, and then automatically
        convert it to a UIMA Type System.</p>
      
      <p>You can take an existing UIMA application, convert its type system to Ecore, and save the CASes it
        produces to XMI. This data is now in a form where it can easily be ingested by an EMF-based application.</p>
    </blockquote></div>
    
    <p>More generally, we are adopting the well-documented, open standard XMI as the standard way to represent
      UIMA-compliant analysis results (replacing the UIMA-specific XCAS format). This use of an open standard
      enables other applications to more easily produce or consume these UIMA analysis results.</p>
    
    <p>For more information on XMI, see Grose et al. <span class="emphasis"><em>Mastering XMI. Java Programming with XMI, XML, and
      UML.</em></span> John Wiley &amp; Sons, Inc. 2002.</p>
    
    <p>For more information on EMF, see Budinsky et al. <span class="emphasis"><em>Eclipse Modeling Framework 2.0.</em></span>
      Addison-Wesley. 2006.</p>
    
    <p>For details of how the UIMA CAS is represented in XMI format, see <a href="references.html#ugr.ref.xmi" class="olink">Chapter&nbsp;7, <i>XMI CAS Serialization Reference</i></a> .</p>
    
  </div>
  
  <div class="section" title="8.2.&nbsp;Converting an Ecore Model to or from a UIMA Type System"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.xmi_emf.converting_ecore_to_from_uima_type_system">8.2.&nbsp;Converting an Ecore Model to or from a UIMA Type System</h2></div></div></div>
    
    
    <p>The UIMA SDK provides the following two classes:</p>
    
    <p><span class="bold"><strong><code class="literal">Ecore2UimaTypeSystem:</code>
      </strong></span> converts from an .ecore model developed using EMF to a UIMA-compliant
      TypeSystem descriptor. This is a Java class that can be run as a standalone program or
      invoked from another Java application. To run as a standalone program,
      execute:</p>
    
    <p><span class="command"><strong>java org.apache.uima.ecore.Ecore2UimaTypeSystem &lt;ecore
      file&gt; &lt;output file&gt;</strong></span></p>
    
    <p>The input .ecore file will be converted to a UIMA TypeSystem descriptor and written
      to the specified output file. You can then use the resulting TypeSystem descriptor in
      your UIMA application.</p>
    
    <p><span class="bold"><strong><code class="literal">UimaTypeSystem2Ecore:</code>
      </strong></span> converts from a UIMA TypeSystem descriptor to an .ecore model. This is a
      Java class that can be run as a standalone program or invoked from another Java
      application. To run as a standalone program, execute:</p>
    
    <p><span class="command"><strong>java org.apache.uima.ecore.UimaTypeSystem2Ecore
      &lt;TypeSystem descriptor&gt; &lt;output file&gt;</strong></span></p>
    
    <p>The input UIMA TypeSystem descriptor will be converted to an Ecore model file and
      written to the specified output file. You can then use the resulting Ecore model in EMF
      applications. The converted type system will include any
      <code class="literal">&lt;import...&gt;</code>ed TypeSystems; the fact that they were
      imported is currently not preserved.</p>
    
    <p>To run either of these converters, your classpath will need to include the UIMA jar
      files as well as the following jar files from the EMF distribution: common.jar,
      ecore.jar, and ecore.xmi.jar.</p>
    
    <p>Also, note that the uima-core.jar file contains the Ecore model file uima.ecore,
      which defines the built-in UIMA types. You may need to use this file from your EMF
      applications.</p>
    
  </div>
  
  <div class="section" title="8.3.&nbsp;Using XMI CAS Serialization"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="ugr.tug.xmi_emf.using_xmi_cas_serialization">8.3.&nbsp;Using XMI CAS Serialization</h2></div></div></div>
    
    
    <p>The UIMA SDK provides XMI support through the following two classes:</p>
    
    <p><span class="bold"><strong><code class="literal">XmiCasSerializer:</code></strong></span>
      can be run from within a UIMA application to write out a CAS to the standard XMI format. The
      XMI that is generated will be compliant with the Ecore model generated by
      <code class="literal">UimaTypeSystem2Ecore</code>. An EMF application could use this Ecore
      model to ingest and process the XMI produced by the XmiCasSerializer.</p>
    
    <p><span class="bold"><strong><code class="literal">XmiCasDeserializer:</code></strong></span>
      can be run from within a UIMA application to read in an XMI document and populate a CAS. The
      XMI must conform to the Ecore model generated by
      <code class="literal">UimaTypeSystem2Ecore</code>.</p>
    
    <p>Also, the uimaj-examples Eclipse project contains some example code that shows
      how to use the serializer and deserializer:

    </p><div class="blockquote"><blockquote class="blockquote">
    <p><code class="literal">org.apache.uima.examples.xmi.XmiWriterCasConsumer:</code>
      This is a CAS Consumer that writes each CAS to an output file in XMI format. It is analogous
      to the XCasWriter CAS Consumer that has existed in prior UIMA versions, except that it
      uses the XMI serialization format.</p>
    
    <p><code class="literal">org.apache.uima.examples.xmi.XmiCollectionReader:</code>
      This is a Collection Reader that reads a directory of XMI files and deserializes each of
      them into a CAS. For example, this would allow you to build a Collection Processing
      Engine that reads XMI files, which could contain some previous analysis results, and
      then do further analysis.</p>
    </blockquote></div>
    
    <p>Finally, in under the folder <code class="literal">uimaj-examples/ecore_src</code> is
      the class
      <code class="literal">org.apache.uima.examples.xmi.XmiEcoreCasConsumer</code>, which
      writes each CAS to XMI format and also saves the Type System as an Ecore file. Since this
      uses the <code class="literal">UimaTypeSystem2Ecore</code> converter, to compile it you must
      add to your classpath the EMF jars common.jar, ecore.jar, and ecore.xmi.jar &#8211;
      see ecore_src/readme.txt for instructions.</p>

    <div class="section" title="8.3.1.&nbsp;Character Encoding Issues with XML Serialization"><div class="titlepage"><div><div><h3 class="title" id="ugr.tug.xmi_emf.xml_character_issues">8.3.1.&nbsp;Character Encoding Issues with XML Serialization</h3></div></div></div>
    
    
    <p>Note that not all valid Unicode characters are valid XML characters, at least not in XML
      1.0.  Moreover, it is possible to create characters in Java that are not even valid Unicode
      characters, let alone XML characters.  As UIMA character data is translated directly into XML
      character data on serialization, this may lead to issues.  UIMA will therefore check that the
      character data that is being serialized is valid for the version of XML being used.  If 
      non-serializable character data is encountered during serialization, an exception is thrown
      and serialization fails (to avoid creating invalid XML data).  UIMA does not simply replace
      the offending characters with some valid replacement character; the assumption being that
      most applications would not like to have their data modified automatically.
    </p>
    
    <p>If you know you are going to use XML serialization, and you would like to avoid such issues
      on serialization, you should check any character data you create in UIMA ahead of time.  Issues
      most often arise with the document text, as documents may originate at various sources, and
      may be of varying quality.  So it's a particularly good idea to check the document text for
      characters that will cause issues for serialization.
    </p>
    
    <p>UIMA provides a handful of functions to assist you in checking Java character data.  Those
      methods are located in 
      <code class="literal">org.apache.uima.internal.util.XMLUtils.checkForNonXmlCharacters()</code>, with
      several overloads.  Please check the javadocs for further information.
    </p>
    
    <p>Please note that these issues are not specific to XMI serialization, they apply to the
      older XCAS format in the same way.
    </p>
  
    </div>
  </div>
  
</div>
</div></body></html>